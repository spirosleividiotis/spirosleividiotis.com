Tell Cursor agent:
"Find the existing layer item drop handler (around line 4900-4930 where layerItem.addEventListener('drop'...) is for standalone layers). Show me that complete drop handler code. We need to modify it to detect when a nested layer is being dropped on it and move the nested layer out of its folder first."
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qonto Motion Animation Tool</title>
    <style>
        @font-face {
            font-family: 'Polysans Qonto';
            src: url('PolysansQonto-Light.woff2') format('woff2');
            font-weight: 300;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Polysans Qonto';
            src: url('PolysansQonto-Regular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Polysans Qonto';
            src: url('PolysansQonto-Medium.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Polysans Qonto';
            src: url('PolysansQonto-SemiBold.woff2') format('woff2');
            font-weight: 600;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Polysans Qonto';
            src: url('PolysansQonto-Bold.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg: #0A0A0A;
            --bg-secondary: #151515;
            --bg-tertiary: #1F1F1F;
            --border: #2A2A2A;
            --text-primary: #FFFFFF;
            --text-secondary: #A0A0A0;
            --text-tertiary: #666666;
            --accent: #C6E6FB;
            --accent-hover: #A8D5F5;
            --accent-dim: rgba(198, 230, 251, 0.1);
            --danger: #EF4444;
        }
        
        body {
            font-family: 'Polysans Qonto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        .app-container {
            height: 100vh;
            width: 100vw;
            display: grid;
            grid-template-rows: 64px 1fr 0px;
            grid-template-columns: 320px 1fr 300px;
            grid-template-areas:
                "header header header"
                "left center right"
                "timeline timeline timeline";
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            transition: grid-template-rows 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .app-container.timeline-open {
            grid-template-rows: 64px 1fr 250px;
        }
        
        /* Ensure preview canvas stays visible when timeline is open */
        .app-container.timeline-open .preview-canvas {
            display: flex !important;
            height: auto !important;
            min-height: 0 !important;
        }
        
        .app-container.timeline-open .center-panel {
            display: flex !important;
            min-height: 0 !important;
        }
        
        /* Top Bar */
        .top-bar {
            grid-area: header;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }
        
        .logo-container {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }
        
        .logo {
            height: 28px;
            width: auto;
            display: block;
        }
        
        .logo-text {
            font-family: 'Polysans Qonto', sans-serif;
            font-size: 32px;
            font-weight: 400;
            color: white;
            letter-spacing: -0.02em;
            line-height: 1;
            margin-bottom: -3px;
        }
        
        .top-bar-links {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .ai-suggestion-btn {
            background: linear-gradient(135deg, #4EB2EF 0%, #1298E9 100%);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 16px;
        }
        
        .ai-suggestion-btn:hover {
            background: linear-gradient(135deg, #30A5EC 0%, #0F7AB8 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(18, 152, 233, 0.3);
        }
        
        .ai-suggestion-text {
            opacity: 0.9;
        }
        
        .ai-suggestion-pattern {
            font-weight: 600;
        }
        
        .get-code-btn {
            background: var(--accent);
            border: none;
            color: var(--bg);
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s ease;
            cursor: pointer;
            margin-right: 12px;
        }
        
        .get-code-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.02);
        }
        
        .docs-link {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 13px;
            transition: all 0.15s ease;
            cursor: pointer;
        }
        
        .docs-link:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .code-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .code-modal-overlay.active {
            display: flex;
        }
        
        .code-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .code-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .code-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .code-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .code-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .code-modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
        }
        
        .code-modal-tab {
            padding: 12px 16px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }
        
        .code-modal-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
        
        .code-modal-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        .code-block {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            color: var(--text-primary);
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .code-copy-btn {
            margin-top: 12px;
            padding: 8px 16px;
            background: var(--accent);
            color: var(--bg);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }
        
        .code-copy-btn:hover {
            background: var(--accent-hover);
        }
        
        /* Left Panel */
        .left-panel {
            grid-area: left;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            max-width: 320px;
        }
        
        .panel-header {
            padding: 12px 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }
        
        .panel-header-title {
            flex: 1;
        }
        
        .panel-header-icon {
            width: 16px;
            height: 16px;
            opacity: 0.6;
            transition: opacity 0.2s ease;
            flex-shrink: 0;
        }
        
        .panel-header:hover .panel-header-icon {
            opacity: 1;
        }
        
        .panel-header.collapsed + .settings-content,
        .panel-header.collapsed + .layers-section,
        .panel-header.collapsed + .panel-section {
            display: none;
        }
        
        /* Hide create-folder-row and layers-section when layers panel header is collapsed */
        .layers-panel .panel-header.collapsed + .create-folder-row,
        .layers-panel .panel-header.collapsed ~ .layers-section {
            display: none;
        }
        
        .panel-section {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .section-title-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .override-toggle-header {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            color: var(--text-secondary);
        }
        
        .override-toggle-header:hover {
            opacity: 1;
        }
        
        .override-toggle-header.active {
            opacity: 1;
            color: var(--accent);
        }
        
        .override-toggle-header svg {
            width: 16px;
            height: 16px;
        }
        
        #overridePanel.override-disabled .property-input {
            opacity: 0.4;
            cursor: default;
        }
        
        .property-group {
            margin-bottom: 16px;
        }
        
        .property-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .property-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            text-align: center;
            -moz-appearance: textfield;
        }
        
        .property-input::-webkit-outer-spin-button,
        .property-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .property-input:hover {
            border-color: var(--accent);
        }
        
        .property-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .property-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .property-group-with-override {
            position: relative;
        }
        
        .override-toggle {
            position: absolute;
            right: 8px;
            top: 28px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        
        .property-group-with-override:hover .override-toggle {
            opacity: 1;
        }
        
        .override-toggle.active {
            opacity: 1;
        }
        
        .override-toggle svg {
            width: 16px;
            height: 16px;
            fill: var(--accent);
        }
        
        .override-toggle.active svg {
            fill: var(--accent);
        }
        
        .property-input.override-disabled {
            opacity: 0.4;
            cursor: default;
        }
        
        .effects-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }
        
        .effects-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .effect-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .effect-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .effect-card-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: capitalize;
        }
        
        .remove-effect-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.15s ease;
        }
        
        .remove-effect-btn:hover {
            color: var(--accent);
            background: rgba(198, 230, 251, 0.15);
        }
        
        .from-to-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .single-value-effect .property-group {
            margin-bottom: 0;
        }
        
        .from-to-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .from-to-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }
        
        .add-effect-btn {
            width: 100%;
            padding: 10px 16px;
            background: transparent;
            border: 1px dashed var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .add-effect-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .new-effect-selector {
            width: 100%;
            margin-bottom: 12px;
        }
        
        .state-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 6px;
            margin-bottom: 16px;
        }
        
        .state-tab {
            flex: 1;
            padding: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .state-tab.active {
            background: var(--bg);
            color: var(--accent);
        }
        
        .no-selection {
            padding: 16px;
            text-align: center;
            color: var(--text-tertiary);
            font-size: 12px;
            font-style: italic;
        }
        
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 0 10px 10px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .upload-zone:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }
        
        .upload-zone-text {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        
        .upload-zone-text strong {
            color: var(--text-primary);
            font-size: 14px;
        }
        
        /* Center Panel */
        .center-panel {
            grid-area: center;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-width: 0;
            min-height: 0;
        }
        
        .preview-toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            gap: 8px;
        }
        
        .preview-toolbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 0 0 auto;
        }
        
        .preview-toolbar-center {
            display: flex;
            align-items: center;
            gap: 4px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .preview-toolbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 0 0 auto;
            margin-left: auto;
        }
        
        .mode-toggle-group {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 2px;
            gap: 0;
        }
        
        .mode-btn {
            padding: 6px 12px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .mode-btn.active {
            background: var(--bg);
            color: var(--accent);
        }
        
        .preview-toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .layout-bar {
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 8px;
        }
        
        .layout-label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .layout-input {
            width: 80px;
            padding: 4px 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .layout-input:hover {
            border-color: var(--accent);
        }
        
        .layout-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .layout-separator {
            color: var(--text-secondary);
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .layout-separator svg {
            width: 12px;
            height: 12px;
        }
        
        .composition-area {
            position: absolute;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05);
            pointer-events: none; /* Allow clicks to pass through to layers */
            z-index: 0;
            overflow: hidden; /* Clip assets that extend beyond boundaries */
        }
        
        /* Enable pointer events on child elements (layers) */
        .composition-area > * {
            pointer-events: auto;
        }
        
        .canvas-container.stacked .composition-area {
            z-index: 0; /* Below assets in stacked mode */
            position: relative;
            margin: 0 auto;
            overflow: hidden; /* Clip assets that extend beyond boundaries */
        }
        
        .canvas-container.stacked .preview-element {
            z-index: 10; /* Above composition in stacked mode - base z-index */
            position: absolute;
            /* Assets are inside composition-area, so they move naturally with it */
        }
        
        /* Disable transition when dragging */
        .canvas-container.stacked .preview-element.dragging {
            transition: none;
        }
        
        .canvas-container.side-by-side .composition-area {
            position: absolute;
            z-index: 0;
            overflow: hidden; /* Clip assets that extend beyond boundaries */
        }
        
        .canvas-container.side-by-side .preview-element {
            z-index: 2; /* Above composition in side-by-side mode */
            position: absolute;
            /* Assets can be big but will be clipped by composition area constraints */
        }
        
        /* Create a clipping container for stacked mode */
        .canvas-container.stacked {
            position: relative;
        }
        
        /* Clip preview elements to composition area in stacked mode using a wrapper approach */
        .canvas-container.stacked::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 5; /* Between composition (0) and assets (10+) */
        }
        
        .composition-area.dark-mode {
            background: #1A1A1A;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px;
            z-index: 10001;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .context-menu-item {
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .context-menu-item:hover {
            background: var(--bg-tertiary);
        }
        
        .play-button {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: var(--accent);
            border: none;
            color: var(--bg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            padding: 0;
        }
        
        .play-button svg {
            width: auto;
            height: 16px;
        }
        
        .play-button:hover {
            background: var(--accent-hover);
            transform: scale(1.05);
        }
        
        .reset-button {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s ease;
            height: 28px;
        }
        
        .reset-button:hover {
            border-color: var(--danger);
            color: var(--danger);
        }
        
        .undo-button, .redo-button {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            padding: 0;
        }
        
        .undo-button svg, .redo-button svg {
            width: 14px;
            height: 14px;
        }
        
        .undo-button:hover:not(:disabled), .redo-button:hover:not(:disabled) {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .undo-button:disabled, .redo-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .zoom-toggle-group {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 2px;
            gap: 0;
            align-items: center;
        }
        
        .zoom-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.15s ease;
            padding: 0;
        }
        
        .zoom-btn:hover {
            background: var(--bg);
            color: var(--accent);
        }
        
        .composition-mode-option {
            width: 24px;
            height: 24px;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .composition-mode-option:hover {
            transform: scale(1.1);
        }
        
        .composition-mode-option.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg);
        }
        
        .composition-mode-option:not(.active) {
            color: #A2A2A2;
        }
        
        .composition-mode-option svg {
            width: 16px;
            height: 16px;
        }
        
        .zoom-select-wrapper {
            position: relative;
            min-width: 50px;
            margin: 0;
        }
        
        .zoom-select-display {
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: block;
            user-select: none;
            text-align: center;
            height: 24px;
            line-height: 16px;
        }
        
        .zoom-select-display:hover {
            border-color: var(--accent);
        }
        
        .zoom-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            overflow: hidden;
        }
        
        .zoom-option {
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: background 0.15s ease;
        }
        
        .zoom-option:hover {
            background: var(--bg-tertiary);
        }
        
        .zoom-select {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            min-width: 80px;
            margin: 0 4px;
        }
        
        .zoom-select:hover {
            border-color: var(--accent);
        }
        
        .zoom-select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .zoom-level {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 45px;
            text-align: center;
        }
        
        .bg-selector {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-left: 12px;
        }
        
        .bg-option {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s ease;
        }
        
        .bg-option:hover {
            transform: scale(1.1);
        }
        
        .bg-option.active {
            border-color: var(--accent);
        }
        
        .bg-option.dark {
            background: #0A0A0A;
            border: 1px solid var(--border);
        }
        
        .bg-option.light {
            background: #E5E5E5;
            border: 1px solid #D0D0D0;
        }
        
        .bg-option.gray {
            background: #A2A2A2;
            border: 1px solid #8A8A8A;
        }
        
        .preview-canvas {
            flex: 1;
            overflow: auto;
            display: flex;
            position: relative;
            align-items: center;
            justify-content: center;
            padding: 40px;
            transition: background 0.3s ease;
            min-height: 100%;
        }
        
        /* Custom scrollbars - hidden by default, show on hover */
        .preview-canvas::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .preview-canvas::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .preview-canvas::-webkit-scrollbar-thumb {
            background: transparent;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .preview-canvas:hover::-webkit-scrollbar-thumb {
            background: rgba(198, 230, 251, 0.4);
        }
        
        .preview-canvas::-webkit-scrollbar-thumb:hover {
            background: rgba(198, 230, 251, 0.6) !important;
        }
        
        /* Show scrollbars when zoomed in */
        .preview-canvas.has-scroll::-webkit-scrollbar-thumb {
            background: rgba(198, 230, 251, 0.3);
        }
        
        .preview-canvas.has-scroll:hover::-webkit-scrollbar-thumb {
            background: rgba(198, 230, 251, 0.5);
        }
        
        .preview-canvas::-webkit-scrollbar-corner {
            background: transparent;
        }
        
        
        .preview-canvas.bg-dark {
            background: #0A0A0A;
        }
        
        .preview-canvas.bg-light {
            background: #E5E5E5;
        }
        
        .preview-canvas.bg-gray {
            background: #A2A2A2;
        }
        
        .canvas-container {
            position: relative;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            transform-origin: center center;
            will-change: transform;
        }
        
        .canvas-container.side-by-side {
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            align-items: center;
            justify-content: center;
            padding: 150px;
            min-width: fit-content;
        }
        
        .canvas-container.stacked {
            position: relative;
            width: 100%;
            height: 100%;
            min-width: 100%;
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .preview-element {
            display: inline-block;
            max-width: 300px;
            max-height: 300px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
            vertical-align: top;
        }
        
        .preview-element.dragging {
            transition: none !important;
            transform: none !important; /* Prevent any scaling transforms during drag */
        }
        
        .canvas-container.side-by-side .preview-element {
            max-width: 280px;
            max-height: 280px;
        }
        
        .canvas-container.stacked .preview-element {
            position: absolute;
            max-width: 400px;
            max-height: 400px;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .preview-element-img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .preview-element:hover:not(.selected) {
            transform: scale(1.02);
        }
        
        .canvas-container.side-by-side .preview-element:hover:not(.selected) {
            transform: scale(1.02);
        }
        
        .canvas-container.stacked .preview-element:hover:not(.selected) {
            transform: scale(1);
        }
        
        .preview-element.selected {
            border: 2px solid #C6E6FB !important;
            box-shadow: 
                0 0 0 2px rgba(198, 230, 251, 0.6),
                0 0 12px rgba(198, 230, 251, 0.5) !important;
            /* Removed transform: scale(1) !important; to allow animations to work */
        }
        
        .canvas-container.stacked .preview-element.selected {
            border: 2px solid #C6E6FB !important;
            box-shadow: 
                0 0 0 2px rgba(198, 230, 251, 0.6),
                0 0 12px rgba(198, 230, 251, 0.5) !important;
        }
        
        .canvas-container.side-by-side .preview-element.selected {
            border: 2px solid #C6E6FB !important;
            box-shadow: 
                0 0 0 2px rgba(198, 230, 251, 0.6),
                0 0 12px rgba(198, 230, 251, 0.5) !important;
        }
        
        /* Resize handles */
        .canvas-container.stacked .preview-element {
            position: absolute;
            cursor: grab;
            will-change: left, top;
        }
        
        .canvas-container.stacked .preview-element:active {
            cursor: grabbing;
        }
        
        .canvas-container.stacked .preview-element.selected {
            cursor: grab;
        }
        
        .empty-state {
            font-size: 14px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: color 0.2s ease;
            margin-top: -100px;
        }
        
        .empty-state-greeting {
            font-size: 32px;
            font-weight: 600;
            transition: color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .empty-state-emoji {
            font-size: 22px;
        }
        
        /* Text colors based on background */
        .bg-dark .empty-state,
        .bg-dark .empty-state-greeting {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .bg-gray .empty-state,
        .bg-gray .empty-state-greeting {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .bg-light .empty-state,
        .bg-light .empty-state-greeting {
            color: rgba(0, 0, 0, 0.9);
        }
        
        .bg-dark .dropzone-text,
        .bg-dark .dropzone-subtext {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .bg-gray .dropzone-text,
        .bg-gray .dropzone-subtext {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .bg-light .dropzone-text,
        .bg-light .dropzone-subtext {
            color: rgba(0, 0, 0, 0.9);
        }
        
        .empty-state-dropzone {
            margin-top: 32px;
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 600px;
            height: 300px;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .empty-state-dropzone:hover,
        .empty-state-dropzone.drag-over {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }
        
        .dropzone-text {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 500;
            margin-bottom: 12px;
        }
        
        .dropzone-subtext {
            font-size: 13px;
            color: var(--text-primary);
            margin-top: 8px;
            font-weight: 400;
        }
        
        .bg-dark .empty-state-dropzone {
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .bg-dark .empty-state-dropzone:hover {
            border-color: var(--accent);
            background: rgba(198, 230, 251, 0.05);
        }
        
        .bg-gray .empty-state-dropzone,
        .bg-light .empty-state-dropzone {
            border-color: rgba(0, 0, 0, 0.2);
        }
        
        .bg-gray .empty-state-dropzone:hover,
        .bg-light .empty-state-dropzone:hover {
            border-color: var(--accent);
            background: rgba(198, 230, 251, 0.05);
        }
        
        .upload-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            color: var(--text-primary);
            padding: 24px 32px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
            animation: slideInWarning 0.3s ease-out;
            max-width: 400px;
        }
        
        .upload-limit-warning strong {
            display: block;
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .upload-limit-warning p {
            margin: 0;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        @keyframes slideInWarning {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        /* Right Panel */
        .right-panel {
            grid-area: right;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            max-width: 300px;
        }
        
        .settings-panel {
            border-bottom: 0;
            padding-bottom: 0;
        }
        
        .settings-panel.hidden {
            display: none;
        }
        
        .settings-content {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .setting-group {
            margin-bottom: 0;
        }
        
        .setting-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .layout-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .layout-dimension-control {
            display: flex;
            align-items: center;
            gap: 4px;
            position: relative;
        }
        
        .dimension-label {
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
            position: relative;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.15s ease;
        }
        
        .dimension-label:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .dimension-label.scrubbing::after {
            content: 'â†”';
            margin-left: 4px;
            opacity: 0.7;
        }
        
        .dimension-input {
            width: 70px;
            padding: 4px 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
            text-align: center;
            -moz-appearance: textfield;
        }
        
        .dimension-input::-webkit-outer-spin-button,
        .dimension-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .dimension-input:hover {
            border-color: var(--accent);
        }
        
        .dimension-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .lock-aspect-btn {
            width: auto;
            height: auto;
            min-height: 24px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            padding: 4px 6px;
        }
        
        .lock-aspect-btn svg {
            width: 12px;
            height: 12px;
        }
        
        .lock-aspect-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .lock-aspect-btn.locked {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .layers-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .layers-panel.hidden {
            display: none;
        }
        
        .layer-properties-panel {
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
            margin-bottom: 12px;
        }
        
        .layer-properties-panel.hidden {
            display: none;
        }
        
        .layers-section {
            flex: 1;
            overflow-y: auto;
        }
        
        .create-folder-row {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
            padding: 0 20px;
            border-bottom: 1px solid var(--border);
            background: #1e1e1e;
            margin-bottom: 0;
        }
        
        .create-folder-row button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            padding: 0;
            cursor: pointer;
            color: #ffffff;
            transition: all 0.15s ease;
            background: transparent;
            border: none;
            border-radius: 4px;
            opacity: 0.8;
        }
        
        .create-folder-row button:hover:not(:disabled) {
            color: var(--accent);
            opacity: 1;
        }
        
        .create-folder-row button svg {
            width: 10px;
            height: 10px;
            display: block;
        }
        
        .create-folder-row button svg path {
            fill: currentColor;
            stroke: currentColor;
        }
        
        .create-folder-row button#createFolderBtn svg path {
            fill: none;
            stroke: currentColor;
        }
        
        .create-folder-row button.action-btn {
            opacity: 0.4;
            pointer-events: none;
        }
        
        .create-folder-row button.action-btn.enabled {
            opacity: 0.8;
            pointer-events: auto;
        }
        
        .create-folder-row button.action-btn.selected {
            opacity: 1;
            color: var(--accent);
            background: rgba(198, 230, 251, 0.15);
        }
        
        .create-folder-row button:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }
        
        .canvas-scale-popup {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
        }
        
        .scale-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .scale-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .scale-toggle-group {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 2px;
            gap: 0;
            align-items: center;
        }
        
        
        .scale-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.15s ease;
            padding: 0;
            flex-shrink: 0;
        }
        
        .scale-btn:hover {
            background: var(--bg);
            color: var(--accent);
        }
        
        .scale-input-group {
            display: flex;
            align-items: center;
            gap: 0;
            flex: 1;
            min-width: 0;
        }
        
        .scale-input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 12px;
            text-align: center;
            flex: 1;
            min-width: 0;
            padding: 2px 4px;
            -moz-appearance: textfield;
        }
        
        .scale-input::-webkit-outer-spin-button,
        .scale-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .scale-input:focus {
            outline: none;
        }
        
        .scale-percent {
            color: var(--text-primary);
            font-size: 12px;
            padding: 2px 4px 2px 2px;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }
        
        .opacity-toggle-group {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 2px;
            gap: 0;
            align-items: center;
        }
        
        
        .opacity-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.15s ease;
            padding: 0;
            flex-shrink: 0;
        }
        
        .opacity-btn:hover {
            background: var(--bg);
            color: var(--accent);
        }
        
        .opacity-input-group {
            display: flex;
            align-items: center;
            gap: 0;
            flex: 1;
            min-width: 0;
        }
        
        .opacity-input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 12px;
            text-align: center;
            flex: 1;
            min-width: 0;
            padding: 2px 4px;
            -moz-appearance: textfield;
        }
        
        .opacity-input::-webkit-outer-spin-button,
        .opacity-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .opacity-input:focus {
            outline: none;
        }
        
        .opacity-percent {
            color: var(--text-primary);
            font-size: 12px;
            padding: 2px 4px 2px 2px;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }
        
        .property-group-compact {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .property-group-compact .property-label {
            margin-bottom: 0;
            min-width: 60px;
        }
        
        .property-group-compact .scale-toggle-group,
        .property-group-compact .opacity-toggle-group {
            flex: 1;
            min-width: 0;
            width: 100%;
        }
        
        .shadow-control-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .shadow-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }
        
        .shadow-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }
        
        .shadow-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }
        
        .shadow-value {
            color: var(--text-secondary);
            font-size: 13px;
            min-width: 40px;
            text-align: right;
        }
        
        .layer-folder {
            border-bottom: 1px solid var(--border);
            transition: all 0.15s ease;
        }
        
        .layer-folder {
            background: #151515;
        }
        
        .layer-folder.selected {
            background: #2a2a2a; /* Lighter gray when selected */
        }
        
        .layer-folder.dragging {
            opacity: 0.5;
        }
        
        .layer-folder.drag-over {
            border-top: 2px solid var(--accent);
            background: rgba(198, 230, 251, 0.05);
        }
        
        .folder-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            transition: background 0.15s ease;
            user-select: none;
            cursor: grab;
        }
        
        .folder-header:active {
            cursor: grabbing;
        }
        
        .folder-header:hover {
            background: var(--bg-tertiary);
        }
        
        .folder-toggle {
            font-size: 12px;
            transition: transform 0.2s ease;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .folder-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .visibility-toggle {
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.15s ease;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            position: relative;
        }
        
        .visibility-toggle:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }
        
        /* Eye icon - visible state */
        .visibility-toggle {
            position: relative;
        }
        
        .visibility-toggle svg {
            width: 16px;
            height: 16px;
            display: block;
        }
        
        .visibility-toggle svg path {
            fill: currentColor;
        }
        
        /* Eye icon - hidden state */
        .visibility-toggle.hidden {
            color: var(--text-tertiary);
            opacity: 0.5;
        }
        
        .folder-icon {
            width: 24px;
            height: 24px;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s ease;
        }
        
        /* Blue highlight when folder is expanded */
        .folder-icon.open {
            color: #2081E2; /* Qonto blue */
        }
        
        .folder-icon.open svg path {
            stroke: #2081E2; /* Qonto blue */
        }
        
        .folder-icon:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .folder-icon svg {
            width: 16px;
            height: 16px;
            display: block;
        }
        
        .folder-icon svg path {
            stroke: currentColor;
            fill: none;
        }
        
        /* Only selected folders get lighter gray on icon */
        .layer-folder.selected .folder-icon {
            background: #2a2a2a; /* Lighter gray when selected */
        }
        
        .layer-folder.selected .folder-icon svg path {
            stroke: currentColor; /* Keep default color, no accent */
        }
        
        .folder-name {
            flex: 1;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.15s ease;
        }
        
        /* Remove hover background - same behavior as layers */
        
        .folder-name-input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--accent);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            outline: none;
        }
        
        .folder-count {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-right: 4px;
        }
        
        .visibility-toggle svg {
            pointer-events: none;
        }
        
        .folder-icon svg {
            pointer-events: none;
        }
        
        .folder-delete {
            background: transparent;
            border: none;
            color: var(--accent);
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 4px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        
        .folder-header:hover .folder-delete {
            opacity: 1;
        }
        
        .folder-delete:hover {
            background: rgba(198, 230, 251, 0.15);
        }
        
        .folder-content {
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: max-height 0.3s ease;
            pointer-events: auto; /* Ensure folder content allows pointer events for drag/drop */
        }
        
        .folder-content.collapsed {
            max-height: 0 !important;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            cursor: grab;
            border-bottom: 1px solid var(--border);
            transition: all 0.15s ease;
        }
        
        .layer-item {
            background: #151515;
        }
        
        .layer-item.nested {
            padding-left: 48px;
        }
        
        .layer-item:hover {
            background: var(--bg-tertiary);
        }
        
        .layer-item.selected {
            background: #2a2a2a; /* Lighter gray when selected */
        }
        
        .layer-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .layer-item.drag-over {
            border-top: 2px solid var(--accent);
        }
        
        .layer-icon {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        .layer-info {
            flex: 1;
            min-width: 0;
        }
        
        .layer-name {
            font-size: 13px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .layer-type {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        
        .layer-delete {
            display: none !important; /* Hide delete button on layer items - only show on folders */
        }
        
        .layer-item .layer-delete {
            display: none !important; /* Ensure no delete button on layer items */
        }
        
        .layer-split {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            padding: 4px;
            transition: all 0.15s ease;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }
        
        .layer-split:hover {
            color: var(--accent);
            background: rgba(198, 230, 251, 0.15);
        }
        
        .layer-split svg {
            width: 14px;
            height: 14px;
        }
        
        .layer-split svg path {
            fill: currentColor;
        }
        
        .add-layer-btn {
            margin: 16px;
            padding: 12px;
            background: transparent;
            border: 1px dashed var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .add-layer-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Timeline */
        .timeline-container {
            grid-area: timeline;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex;
            flex-direction: column;
        }
        
        .timeline-container.hidden {
            display: none;
        }
        
        .timeline-header {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .timeline-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .timeline-toggle {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.15s ease;
        }
        
        .timeline-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .timeline-content {
            height: 200px;
            display: flex;
            overflow-x: auto;
            overflow-y: auto;
        }
        
        .timeline-labels {
            width: 150px;
            background: var(--bg-tertiary);
            border-right: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        .timeline-labels-spacer {
            height: 30px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }
        
        .timeline-canvas {
            flex: 1;
            position: relative;
            min-width: 2000px;
        }
        
        .timeline-ruler {
            height: 30px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            position: relative;
        }
        
        .timeline-playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: var(--accent);
            z-index: 100;
            pointer-events: auto;
            cursor: ew-resize;
            transition: none;
        }
        
        .timeline-playhead-icon {
            position: absolute;
            top: -16px;
            left: -15px;
            width: 32px;
            height: 32px;
            pointer-events: none;
        }
        
        .timeline-playhead-icon svg {
            width: 100%;
            height: 100%;
        }
        
        .timeline-playhead-tooltip {
            position: absolute;
            top: -40px;
            left: -20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            color: var(--text-primary);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        
        .timeline-playhead:hover .timeline-playhead-tooltip,
        .timeline-playhead.dragging .timeline-playhead-tooltip {
            opacity: 1;
        }
        
        .timeline-playhead-icon svg {
            color: var(--accent);
        }
        
        .timeline-playhead.dragging {
            cursor: ew-resize;
        }
        
        .ruler-mark {
            position: absolute;
            top: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .ruler-mark::before {
            content: '';
            position: absolute;
            top: 0;
            width: 1px;
            height: 8px;
            background: var(--border);
        }
        
        .ruler-mark span {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-top: 12px;
        }
        
        .timeline-track {
            height: 40px;
            border-bottom: 1px solid var(--border);
            position: relative;
        }
        
        .timeline-track-label {
            height: 40px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-size: 12px;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            flex: 1;
            transition: all 0.15s ease;
        }
        
        .timeline-track-label:hover {
            background: var(--bg-tertiary);
        }
        
        .timeline-track-label.selected {
            background: rgba(198, 230, 251, 0.15);
            border-left: 3px solid var(--accent);
        }
        
        .timeline-eye-icon {
            display: inline-flex;
            align-items: center;
            width: 12px;
            height: 12px;
            color: var(--text-secondary);
            margin-left: 16px;
            margin-right: 8px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .timeline-eye-icon:hover {
            color: var(--text-primary);
        }
        
        .timeline-label-input {
            width: 100%;
            padding: 4px;
            border: 1px solid var(--accent);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text-primary);
            font-size: 12px;
        }
        
        .animation-bar {
            position: absolute;
            height: 28px;
            top: 6px;
            background: var(--accent);
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 11px;
            color: var(--bg);
            font-weight: 600;
            user-select: none;
        }
        
        .animation-bar:hover {
            background: var(--accent-hover);
        }
        
        .animation-bar.selected {
            outline: 2px solid white;
        }
        
        .resize-handle {
            position: absolute;
            width: 8px;
            height: 100%;
            top: 0;
            cursor: ew-resize;
        }
        
        .resize-handle.left {
            left: 0;
            border-left: 2px solid rgba(0,0,0,0.3);
        }
        
        .resize-handle.right {
            right: 0;
            border-right: 2px solid rgba(0,0,0,0.3);
        }
        
        .show-timeline-btn {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-bottom: none;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            color: var(--text-secondary);
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.15s ease;
            z-index: 50;
        }
        
        .show-timeline-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .show-timeline-btn.hidden {
            display: none;
        }
        
        .suggestion-banner {
            background: var(--accent-dim);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 12px;
            margin: 16px;
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-primary);
        }
        
        .suggestion-banner strong {
            color: var(--accent);
        }
        
        #fileInput {
            display: none;
        }
        
        .animation-suggestion {
            position: fixed;
            transform: translate(-50%, 0);
            background: #093B75;
            border: 1px solid white;
            border-radius: 6px;
            padding: 16px 20px;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(9, 59, 117, 0.5);
            animation: slideDownFadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 700px;
            pointer-events: auto;
        }
        
        .suggestion-content {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .suggestion-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .suggestion-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .suggestion-icon svg {
            width: 24px;
            height: 24px;
        }
        
        .suggestion-badge {
            background: #9BC5EA;
            border-radius: 6px;
            padding: 8px 16px;
            font-family: 'PolysansQonto-Bold', sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: black;
            white-space: nowrap;
        }
        
        .suggestion-middle {
            flex: 1;
        }
        
        .suggestion-description {
            font-family: 'PolysansQonto-Medium', sans-serif;
            font-size: 14px;
            margin: 0;
            color: white;
            line-height: 1.4;
        }
        
        .suggestion-detail {
            font-family: 'PolysansQonto-Medium', sans-serif;
            font-weight: 500;
        }
        
        .suggestion-apply-btn {
            background: #000000;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'PolysansQonto-Bold', sans-serif;
            font-weight: 700;
            font-size: 14px;
            transition: background 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .suggestion-apply-btn:hover {
            background: #1a1a1a;
        }
        
        .suggestion-dismiss-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            transition: opacity 0.2s;
            flex-shrink: 0;
            opacity: 0.7;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .suggestion-dismiss-btn:hover {
            opacity: 1;
        }
        
        .suggestion-dismiss-btn svg {
            width: 16px;
            height: 16px;
        }
        
        @keyframes slideDownFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
    </style>
</head>
<body>
    <div class="app-container" id="appContainer">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="logo-container">
                <svg class="logo" width="82" height="24" viewBox="0 0 82 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g clip-path="url(#clip0_6770_14427)">
                    <path d="M42.0567 23.1253H45.1923V14.066C45.1923 11.8462 46.6872 10.167 48.6802 10.167C50.6733 10.167 52.3142 11.8462 52.3142 14.066V23.1209H55.6861V13.8286C55.6861 9.89892 52.5805 6.93188 49.1785 6.93188C47.8899 6.93188 46.3564 7.34507 45.1923 8.98903V7.29232H42.0567V23.1253Z" fill="white"/>
                    <path d="M73.8515 6.92749C69.307 6.92749 65.8234 10.6154 65.8234 15.266C65.8234 20.0352 69.3113 23.4813 73.8515 23.4813C78.5121 23.4813 82 20.0308 82 15.266C82 10.6198 78.5121 6.92749 73.8515 6.92749ZM73.8515 20.1539C71.3001 20.1539 69.191 17.9956 69.191 15.266C69.191 12.3868 71.3001 10.2594 73.8515 10.2594C76.5491 10.2594 78.6281 12.3868 78.6281 15.266C78.6281 17.9956 76.5491 20.1539 73.8515 20.1539Z" fill="white"/>
                    <path d="M65.2349 23.1253V19.7978C62.8896 20.9978 60.6903 20.0396 60.6903 17.3978V10.4967H64.8827V7.28792H60.6903V3.2088H57.4387V16.8264C57.443 22.4044 61.1628 24.3253 65.2349 23.1253Z" fill="white"/>
                    <path d="M32.1514 6.92749C27.6068 6.92749 24.1232 10.6154 24.1232 15.266C24.1232 20.0352 27.6111 23.4813 32.1514 23.4813C36.8119 23.4813 40.2998 20.0308 40.2998 15.266C40.2955 10.6198 36.8076 6.92749 32.1514 6.92749ZM32.1514 20.1539C29.5741 20.1539 27.4908 17.9956 27.4908 15.266C27.4908 12.3868 29.5698 10.2594 32.1514 10.2594C34.8189 10.2594 36.9279 12.3868 36.9279 15.266C36.9279 17.9956 34.8146 20.1539 32.1514 20.1539Z" fill="white"/>
                    <path d="M11.2841 0C4.89251 0 0 5.01099 0 11.8198C0 18.356 4.89251 23.4857 11.2841 23.4857C17.8175 23.4857 22.7143 18.356 22.7143 11.8198C22.7143 5.01099 17.8175 0 11.2841 0ZM11.2841 20.0352C6.85982 20.0352 3.60388 16.5846 3.60388 11.8198C3.60388 6.93187 6.85553 3.33187 11.2841 3.33187C15.8287 3.33187 19.1104 6.93187 19.1104 11.8198C19.1061 16.5846 15.8244 20.0352 11.2841 20.0352Z" fill="white"/>
                    <path d="M22.1774 24C15.7943 23.2879 11.7051 19.9429 9.68622 13.7758L12.882 12.6813C14.4842 17.5736 17.4653 20.0044 22.5468 20.5714L22.1774 24Z" fill="white"/>
                    </g>
                    <defs>
                    <clipPath id="clip0_6770_14427">
                    <rect width="82" height="24" fill="white"/>
                    </clipPath>
                    </defs>
        </svg>
                <span class="logo-text">Motion</span>
            </div>
            
            <div class="top-bar-links">
                <button id="aiSuggestionBtn" class="ai-suggestion-btn" style="display: none;" onclick="applyAISuggestion()">
                    <span class="ai-suggestion-text">Recommended animation: </span>
                    <span class="ai-suggestion-pattern"></span>
                </button>
                <a href="https://www.notion.so/qonto/Motion-11831ee4c696802d9096fa098a9b9fe0" class="docs-link" target="_blank" rel="noopener noreferrer">Visit Motion System Documentation</a>
                <button class="get-code-btn" onclick="openCodeModal()">Get the code</button>
            </div>
        </div>
        
        <!-- Left Panel - Animation Properties -->
        <div class="left-panel">
            
            <div id="suggestionBanner"></div>
            <div id="propertiesContent">
                </div>
                </div>
        
        <!-- Center Panel - Preview -->
        <div class="center-panel">
            <div class="preview-toolbar">
                <div class="preview-toolbar-left">
                    <div class="mode-toggle-group">
                        <button class="mode-btn" data-mode="side-by-side" onclick="setPreviewMode('side-by-side')" title="Compare animation behaviors side by side">Side by Side</button>
                        <button class="mode-btn active" data-mode="stacked" onclick="setPreviewMode('stacked')" title="Create your own sequence of animation">Stacked</button>
                    </div>
                    <div class="zoom-toggle-group">
                        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
                        <div class="zoom-select-wrapper" onclick="event.stopPropagation()">
                            <span class="zoom-select-display" id="zoomSelectDisplay" onclick="toggleZoomDropdown()">100%</span>
                            <div class="zoom-dropdown" id="zoomDropdown" style="display: none;">
                                <div class="zoom-option" onclick="setZoom(25)">25%</div>
                                <div class="zoom-option" onclick="setZoom(50)">50%</div>
                                <div class="zoom-option" onclick="setZoom(75)">75%</div>
                                <div class="zoom-option" onclick="setZoom(100)">100%</div>
                            </div>
                        </div>
                        <button class="zoom-btn" onclick="zoomIn()">+</button>
                    </div>
                </div>
                <div class="preview-toolbar-center">
                    <button class="undo-button" id="undoBtn" onclick="undoAction()" title="Undo" disabled>
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M11.0154 30C10.4631 30 10.0154 29.5523 10.0154 29C10.0154 28.4477 10.4631 28 11.0154 28H21.499C26.1934 28 29.999 24.1944 29.999 19.5C29.999 14.8056 26.1934 11 21.499 11H3.06452L9.70348 17.28C10.1234 17.64 10.1434 18.28 9.76347 18.68C9.56351 18.9 9.28355 19 9.02359 19C8.78363 19 8.58366 18.92 8.38369 18.78L0.6449 11.44C-0.214967 10.66 -0.214967 9.3 0.6449 8.5L4.76426 4.68L8.3237 1.24H8.3437C8.3437 1.24 8.36369 1.22 8.36369 1.2C8.56366 1.06 8.76363 0.98 9.00359 0.98C9.24356 0.98 9.52351 1.08 9.72348 1.3C10.1034 1.7 10.0834 2.34 9.66349 2.7L6.10405 6.14C6.10405 6.14 6.08405 6.14 6.06405 6.18L3.06452 9H21.499C27.298 9 31.999 13.701 31.999 19.5C31.999 25.299 27.298 30 21.499 30H11.0154Z" fill="currentColor"/>
                        </svg>
                    </button>
                    <button class="redo-button" id="redoBtn" onclick="redoAction()" title="Redo" disabled>
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_30690_136)">
                                <path d="M20.9836 30C21.5359 30 21.9836 29.5523 21.9836 29C21.9836 28.4477 21.5359 28 20.9836 28L10.5 28C5.80558 28 2 24.1944 2 19.5C2 14.8056 5.80558 11 10.5 11L28.9345 11L22.2955 17.28C21.8756 17.64 21.8556 18.28 22.2355 18.68C22.4355 18.9 22.7155 19 22.9754 19C23.2154 19 23.4154 18.92 23.6153 18.78L31.3541 11.44C32.214 10.66 32.214 9.3 31.3541 8.5L27.2348 4.68L23.6753 1.24H23.6553C23.6553 1.24 23.6353 1.22 23.6353 1.2C23.4354 1.06 23.2354 0.98 22.9954 0.98C22.7555 0.98 22.4755 1.08 22.2755 1.3C21.8956 1.7 21.9156 2.34 22.3355 2.7L25.895 6.14C25.895 6.14 25.915 6.14 25.935 6.18L28.9345 9L10.5 9C4.70101 9 -3.8147e-06 13.701 -3.8147e-06 19.5C-3.8147e-06 25.299 4.70101 30 10.5 30L20.9836 30Z" fill="currentColor"/>
                            </g>
                            <defs>
                                <clipPath id="clip0_30690_136">
                                    <rect width="32" height="32" fill="white"/>
                                </clipPath>
                            </defs>
                        </svg>
                    </button>
                    <button class="play-button" id="playBtn" onclick="playAllAnimations()" title="Click here to see your animation">
                        <svg width="12" height="16" viewBox="0 0 12 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3.33334 9C2.59696 9 0.390525 8.55228 0.390525 8C0.390525 7.44771 -0.345854 7 0.390525 7L7.44772 7L0.390528 1.70711C-0.130172 1.31658 -0.130172 0.683418 0.390528 0.292893C0.911226 -0.0976313 1.75545 -0.0976314 2.27615 0.292893L11.6095 7.29289C12.1302 7.68342 12.1302 8.31658 11.6095 8.70711L2.27614 15.7071C1.75544 16.0976 0.911223 16.0976 0.390525 15.7071C-0.130175 15.3166 -0.130175 14.6834 0.390525 14.2929L7.44772 9L3.33334 9Z" fill="currentColor"/>
                            <path d="M-0.000104712 0.999998L8.9999 6.5V9L-0.000104712 15V0.999998Z" fill="currentColor"/>
                        </svg>
                    </button>
                    <button class="reset-button" onclick="resetAll()" title="Click here to start from scratch">Reset All</button>
                </div>
                <div class="preview-toolbar-right">
                    <div class="bg-selector" title="Choose your preview background color">
                        <div class="mode-toggle-group" id="compositionModeToggle">
                            <button class="mode-btn active" id="compositionModeBtnLight" data-mode="light" onclick="setCompositionMode('light')" title="Light mode">Light</button>
                            <button class="mode-btn" id="compositionModeBtnDark" data-mode="dark" onclick="setCompositionMode('dark')" title="Dark mode">Dark</button>
                        </div>
                        <div class="bg-option dark" data-bg="dark" onclick="setBackground('dark')" title="Dark"></div>
                        <div class="bg-option gray active" data-bg="gray" onclick="setBackground('gray')" title="Gray"></div>
                        <div class="bg-option light" data-bg="light" onclick="setBackground('light')" title="Light"></div>
                </div>
            </div>
        </div>


            <div class="preview-canvas bg-gray" id="canvasArea">
                <!-- Scale popup on canvas -->
                <div class="canvas-scale-popup" id="canvasScalePopup" style="display: none;">
                    <div class="scale-control">
                        <label class="scale-label">Scale</label>
                        <div class="scale-toggle-group">
                            <button class="scale-btn" onclick="adjustLayerScale(-10)">âˆ’</button>
                            <div class="scale-input-group">
                                <input type="number" class="scale-input" id="layerScaleInput" value="100" min="10" max="500" step="10">
                                <span class="scale-percent">%</span>
            </div>
                            <button class="scale-btn" onclick="adjustLayerScale(10)">+</button>
            </div>
                    </div>
                </div>
                <div class="canvas-container stacked" id="canvasContainer">
                    <div class="empty-state">
                        <div class="empty-state-greeting">
                            <span>Hello Qontoer</span>
                            <span class="empty-state-emoji">ðŸ‘‹ðŸ¼</span>
        </div>
                        <div class="empty-state-dropzone" id="emptyStateDropzone" onclick="document.getElementById('fileInput').click();">
                            <div class="dropzone-text">Add your images or svg</div>
                            <div class="dropzone-subtext">Drag and drop here, or click to browse</div>
            </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Settings and Layers -->
        <div class="right-panel">
            <!-- Settings Panel -->
            <div class="settings-panel">
                <div class="panel-header" data-panel="settings">
                    <span class="panel-header-title">Settings</span>
                    <span class="panel-header-icon collapse-icon">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_5089_1489)">
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M4.31461 18.72C4.31461 18.16 4.75406 17.72 5.31336 17.72H13.2235C13.5031 17.7 13.7828 17.8 14.0025 18.02C14.1823 18.2 14.3021 18.46 14.3021 18.72V26.72C14.3021 27.28 13.8627 27.72 13.3034 27.72C12.7441 27.72 12.3046 27.28 12.3046 26.72V21.14L1.71785 31.7C1.31835 32.1 0.699126 32.1 0.299625 31.7C-0.0998752 31.3 -0.0998752 30.68 0.299625 30.28L10.8664 19.7H5.29338C4.73408 19.7 4.29463 19.26 4.29463 18.7L4.31461 18.72Z" fill="currentColor"/>
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M27.6854 13.28C27.6854 13.84 27.2459 14.28 26.6866 14.28H18.7765C18.4969 14.3 18.2172 14.2 17.9975 13.98C17.8177 13.8 17.6979 13.54 17.6979 13.28V5.28C17.6979 4.72 18.1373 4.28 18.6966 4.28C19.2559 4.28 19.6954 4.72 19.6954 5.28V10.86L30.2822 0.3C30.6817 -0.1 31.3009 -0.1 31.7004 0.3C32.0999 0.7 32.0999 1.32 31.7004 1.72L21.1336 12.3H26.7066C27.2659 12.3 27.7054 12.74 27.7054 13.3L27.6854 13.28Z" fill="currentColor"/>
                            </g>
                            <defs>
                                <clipPath id="clip0_5089_1489">
                                    <rect width="32" height="32" fill="white"/>
                                </clipPath>
                            </defs>
                        </svg>
                    </span>
                    <span class="panel-header-icon expand-icon" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M12.58 17.9997L2 28.578V22.9989C2 22.439 1.56 21.9991 1 21.9991C0.44 21.9991 0 22.439 0 22.9989V30.9977C0 31.2776 0.12 31.5176 0.3 31.6975C0.52 31.9175 0.8 32.0175 1.08 31.9975H9C9.56 31.9975 10 31.5576 10 30.9977C10 30.4377 9.56 29.9978 9 29.9978H3.42L14 19.4195C14.4 19.0195 14.4 18.3996 14 17.9997C13.6 17.5997 12.98 17.5997 12.58 17.9997Z" fill="currentColor"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M31.7 0.302453C31.48 0.0824871 31.2 -0.0174973 30.92 0.00249961H23C22.44 0.00249961 22 0.442431 22 1.00234C22 1.56226 22.44 2.00219 23 2.00219H28.58L18 12.5805C17.6 12.9805 17.6 13.6004 18 14.0003C18.4 14.4002 19.02 14.4002 19.42 14.0003L30 3.42197V9.00109C30 9.56101 30.44 10.0009 31 10.0009C31.56 10.0009 32 9.56101 32 9.00109V1.00234C32 0.722387 31.88 0.482425 31.7 0.302453Z" fill="currentColor"/>
                        </svg>
                    </span>
                </div>
                <div class="settings-content">
                    <div class="setting-group">
                        <label class="setting-label">Layout</label>
                        <div class="layout-controls">
                            <div class="layout-dimension-control">
                                <span class="dimension-label" data-dimension="width" title="Click and drag to scrub">W</span>
                                <input type="number" class="dimension-input" id="layoutWidth" value="800" min="100" max="5000" step="1">
                            </div>
                            <div class="layout-dimension-control">
                                <span class="dimension-label" data-dimension="height" title="Click and drag to scrub">H</span>
                                <input type="number" class="dimension-input" id="layoutHeight" value="500" min="100" max="5000" step="1">
                            </div>
                            <button class="lock-aspect-btn" id="lockAspectBtn" title="Lock aspect ratio">
                                <svg width="12" height="12" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M8 11.9992V8.33916C8 4.15916 11.06 0.439163 15.22 0.0391629C20 -0.420837 24 3.31916 24 7.99916V11.9992H26C27.1 11.9992 28 12.8992 28 13.9992V29.9992C28 31.0992 27.1 31.9992 26 31.9992H5.64C4.74 31.9992 4 31.2592 4 30.3592V13.6392C4 12.7392 4.74 11.9992 5.64 11.9992H8ZM10 11.9992H22V7.99916C22 4.67916 19.32 1.99916 16 1.99916C12.68 1.99916 10 4.67916 10 7.99916V11.9992ZM26 29.9992H6V13.9992H26V29.9992Z" fill="currentColor"/>
                                    <path d="M16 25.9992C15.44 25.9992 15 25.5592 15 24.9992V20.9992C15 20.4392 15.44 19.9992 16 19.9992C16.56 19.9992 17 20.4392 17 20.9992V24.9992C17 25.5592 16.56 25.9992 16 25.9992Z" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Layers Panel -->
            <div class="layers-panel">
                <div class="panel-header" data-panel="layers" title="Reorganize your layers to edit your canvas order and preview">
                    <span class="panel-header-title">Layers</span>
                    <span class="panel-header-icon collapse-icon">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_5089_1489)">
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M4.31461 18.72C4.31461 18.16 4.75406 17.72 5.31336 17.72H13.2235C13.5031 17.7 13.7828 17.8 14.0025 18.02C14.1823 18.2 14.3021 18.46 14.3021 18.72V26.72C14.3021 27.28 13.8627 27.72 13.3034 27.72C12.7441 27.72 12.3046 27.28 12.3046 26.72V21.14L1.71785 31.7C1.31835 32.1 0.699126 32.1 0.299625 31.7C-0.0998752 31.3 -0.0998752 30.68 0.299625 30.28L10.8664 19.7H5.29338C4.73408 19.7 4.29463 19.26 4.29463 18.7L4.31461 18.72Z" fill="currentColor"/>
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M27.6854 13.28C27.6854 13.84 27.2459 14.28 26.6866 14.28H18.7765C18.4969 14.3 18.2172 14.2 17.9975 13.98C17.8177 13.8 17.6979 13.54 17.6979 13.28V5.28C17.6979 4.72 18.1373 4.28 18.6966 4.28C19.2559 4.28 19.6954 4.72 19.6954 5.28V10.86L30.2822 0.3C30.6817 -0.1 31.3009 -0.1 31.7004 0.3C32.0999 0.7 32.0999 1.32 31.7004 1.72L21.1336 12.3H26.7066C27.2659 12.3 27.7054 12.74 27.7054 13.3L27.6854 13.28Z" fill="currentColor"/>
                            </g>
                            <defs>
                                <clipPath id="clip0_5089_1489">
                                    <rect width="32" height="32" fill="white"/>
                                </clipPath>
                            </defs>
                        </svg>
                    </span>
                    <span class="panel-header-icon expand-icon" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M12.58 17.9997L2 28.578V22.9989C2 22.439 1.56 21.9991 1 21.9991C0.44 21.9991 0 22.439 0 22.9989V30.9977C0 31.2776 0.12 31.5176 0.3 31.6975C0.52 31.9175 0.8 32.0175 1.08 31.9975H9C9.56 31.9975 10 31.5576 10 30.9977C10 30.4377 9.56 29.9978 9 29.9978H3.42L14 19.4195C14.4 19.0195 14.4 18.3996 14 17.9997C13.6 17.5997 12.98 17.5997 12.58 17.9997Z" fill="currentColor"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M31.7 0.302453C31.48 0.0824871 31.2 -0.0174973 30.92 0.00249961H23C22.44 0.00249961 22 0.442431 22 1.00234C22 1.56226 22.44 2.00219 23 2.00219H28.58L18 12.5805C17.6 12.9805 17.6 13.6004 18 14.0003C18.4 14.4002 19.02 14.4002 19.42 14.0003L30 3.42197V9.00109C30 9.56101 30.44 10.0009 31 10.0009C31.56 10.0009 32 9.56101 32 9.00109V1.00234C32 0.722387 31.88 0.482425 31.7 0.302453Z" fill="currentColor"/>
                        </svg>
                    </span>
                    </div>
                
                <div class="create-folder-row" id="createFolderRow">
                    <button id="createFolderBtn" class="create-folder-btn-small" title="Create folder" onclick="createNewFolder(); event.stopPropagation();">
                        <svg width="10" height="10" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2.08008 4H10.9199C11.2046 4 11.4473 4.10157 11.6328 4.28711L14.4805 7.13379C14.8555 7.50885 15.3641 7.71973 15.8945 7.71973H30C30.5476 7.71973 30.9998 8.17213 31 8.71973V26.9199C31 27.5076 30.5076 28 29.9199 28H2.08008C1.49236 28 1 27.5076 1 26.9199V5.08008C1 4.49236 1.49236 4 2.08008 4Z" stroke="currentColor" stroke-width="2" fill="none"/>
                        </svg>
                    </button>
                    <button id="splitLayerBtn" class="action-btn" title="Split layer" disabled>
                        <svg width="10" height="10" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M27.9998 8.5H3.99977C3.43977 8.5 2.99977 8.06 2.99977 7.5C2.99977 6.94 3.43977 6.5 3.99977 6.5H27.9998C28.5598 6.5 28.9998 6.94 28.9998 7.5C28.9998 8.06 28.5598 8.5 27.9998 8.5Z" fill="currentColor"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M23.9998 3H7.99977C7.43977 3 6.99977 2.56 6.99977 2C6.99977 1.44 7.43977 1 7.99977 1H23.9998C24.5598 1 24.9998 1.44 24.9998 2C24.9998 2.56 24.5598 3 23.9998 3Z" fill="currentColor"/>
                            <path d="M30.9431 12.0059C31.5005 12.0685 31.907 12.5873 31.8172 13.1562L29.1326 30.1562L29.115 30.2451C29.0115 30.6557 28.6587 30.9575 28.2371 30.9961L28.1453 31H3.85426L3.76247 30.9961C3.34085 30.9575 2.98801 30.6557 2.88454 30.2451L2.86696 30.1562L0.182387 13.1562C0.0925507 12.5873 0.498998 12.0685 1.05641 12.0059L1.16969 12H30.8298L30.9431 12.0059ZM4.70875 29H27.2908L29.659 14H2.34059L4.70875 29Z" fill="currentColor"/>
                        </svg>
                    </button>
                    <button id="deleteLayerBtn" class="action-btn" title="Delete" disabled>
                        <svg width="10" height="10" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_86_588)">
                                <path d="M16 0C7.16 0 0 7.16 0 16C0 24.84 7.16 32 16 32C24.84 32 32 24.84 32 16C32 7.16 24.84 0 16 0ZM16 30C8.28 30 2 23.72 2 16C2 8.28 8.28 2 16 2C23.72 2 30 8.28 30 16C30 23.72 23.72 30 16 30Z" fill="currentColor"/>
                                <path d="M21.76 20.28C22.16 20.68 22.16 21.34 21.76 21.74C21.56 21.94 21.3 22.04 21.04 22.04C20.78 22.04 20.52 21.94 20.32 21.74L16.02 17.44L11.7 21.74C11.5 21.94 11.24 22.04 10.98 22.04C10.72 22.04 10.46 21.94 10.26 21.74C9.86 21.34 9.86 20.68 10.26 20.28L14.56 16L10.26 11.72C9.86 11.34 9.86 10.68 10.26 10.28C10.66 9.88 11.3 9.88 11.7 10.28L16.02 14.56L20.32 10.28C20.72 9.88 21.36 9.88 21.76 10.28C22.16 10.68 22.16 11.34 21.76 11.72L17.46 16L21.76 20.28Z" fill="currentColor"/>
                            </g>
                            <defs>
                                <clipPath id="clip0_86_588">
                                    <rect width="32" height="32" fill="white"/>
                                </clipPath>
                            </defs>
                        </svg>
                    </button>
                    </div>
                
                <div class="layers-section" id="layersList">
                    <!-- Layers added dynamically -->
                    </div>
            </div>
            
            <!-- Layer Properties Panel -->
            <div class="layer-properties-panel" id="layerPropertiesPanel">
                <div class="panel-header" data-panel="properties">
                    <span class="panel-header-title">Layer Properties</span>
                    <span class="panel-header-icon collapse-icon">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_5089_1489)">
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M4.31461 18.72C4.31461 18.16 4.75406 17.72 5.31336 17.72H13.2235C13.5031 17.7 13.7828 17.8 14.0025 18.02C14.1823 18.2 14.3021 18.46 14.3021 18.72V26.72C14.3021 27.28 13.8627 27.72 13.3034 27.72C12.7441 27.72 12.3046 27.28 12.3046 26.72V21.14L1.71785 31.7C1.31835 32.1 0.699126 32.1 0.299625 31.7C-0.0998752 31.3 -0.0998752 30.68 0.299625 30.28L10.8664 19.7H5.29338C4.73408 19.7 4.29463 19.26 4.29463 18.7L4.31461 18.72Z" fill="currentColor"/>
                                <path fill-rule="evenodd" clip-rule="evenodd" d="M27.6854 13.28C27.6854 13.84 27.2459 14.28 26.6866 14.28H18.7765C18.4969 14.3 18.2172 14.2 17.9975 13.98C17.8177 13.8 17.6979 13.54 17.6979 13.28V5.28C17.6979 4.72 18.1373 4.28 18.6966 4.28C19.2559 4.28 19.6954 4.72 19.6954 5.28V10.86L30.2822 0.3C30.6817 -0.1 31.3009 -0.1 31.7004 0.3C32.0999 0.7 32.0999 1.32 31.7004 1.72L21.1336 12.3H26.7066C27.2659 12.3 27.7054 12.74 27.7054 13.3L27.6854 13.28Z" fill="currentColor"/>
                            </g>
                            <defs>
                                <clipPath id="clip0_5089_1489">
                                    <rect width="32" height="32" fill="white"/>
                                </clipPath>
                            </defs>
                        </svg>
                    </span>
                    <span class="panel-header-icon expand-icon" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M12.58 17.9997L2 28.578V22.9989C2 22.439 1.56 21.9991 1 21.9991C0.44 21.9991 0 22.439 0 22.9989V30.9977C0 31.2776 0.12 31.5176 0.3 31.6975C0.52 31.9175 0.8 32.0175 1.08 31.9975H9C9.56 31.9975 10 31.5576 10 30.9977C10 30.4377 9.56 29.9978 9 29.9978H3.42L14 19.4195C14.4 19.0195 14.4 18.3996 14 17.9997C13.6 17.5997 12.98 17.5997 12.58 17.9997Z" fill="currentColor"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M31.7 0.302453C31.48 0.0824871 31.2 -0.0174973 30.92 0.00249961H23C22.44 0.00249961 22 0.442431 22 1.00234C22 1.56226 22.44 2.00219 23 2.00219H28.58L18 12.5805C17.6 12.9805 17.6 13.6004 18 14.0003C18.4 14.4002 19.02 14.4002 19.42 14.0003L30 3.42197V9.00109C30 9.56101 30.44 10.0009 31 10.0009C31.56 10.0009 32 9.56101 32 9.00109V1.00234C32 0.722387 31.88 0.482425 31.7 0.302453Z" fill="currentColor"/>
                        </svg>
                    </span>
                    </div>
                <div class="panel-section">
                    <div class="property-group property-group-compact">
                        <label class="property-label">Scale</label>
                        <div class="scale-toggle-group">
                            <button class="scale-btn" onclick="adjustLayerScale(-10)">âˆ’</button>
                            <div class="scale-input-group">
                                <input type="number" class="scale-input" id="layerScaleInput" value="100" min="10" max="500" step="1">
                                <span class="scale-percent">%</span>
                    </div>
                            <button class="scale-btn" onclick="adjustLayerScale(10)">+</button>
                        </div>
                    </div>
                    <div class="property-group property-group-compact">
                        <label class="property-label">Opacity</label>
                        <div class="opacity-toggle-group">
                            <button class="opacity-btn" onclick="adjustLayerOpacity(-10)">âˆ’</button>
                            <div class="opacity-input-group">
                                <input type="number" class="opacity-input" id="layerOpacityInput" value="100" min="0" max="100" step="1">
                                <span class="opacity-percent">%</span>
                            </div>
                            <button class="opacity-btn" onclick="adjustLayerOpacity(10)">+</button>
                        </div>
                    </div>
                    <div class="property-group property-group-compact">
                        <label class="property-label">Shadow</label>
                        <div class="shadow-control-group">
                            <input type="range" class="shadow-slider" id="layerShadowInput" value="0" min="0" max="20" step="1">
                            <span class="shadow-value" id="layerShadowValue">0px</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Upload Zone -->
            <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click();" style="display: none;">
                <div class="upload-zone-text">
                    <strong>Upload more assets</strong><br>
                    Drag and drop or click to browse
                    </div>
            </div>
            
            <input type="file" id="fileInput" accept="image/*,.svg" multiple>
                    </div>
        
        <!-- Code Modal -->
        <div class="code-modal-overlay" id="codeModalOverlay" onclick="if(event.target.id === 'codeModalOverlay') closeCodeModal()">
            <div class="code-modal" onclick="event.stopPropagation()">
                <div class="code-modal-header">
                    <div class="code-modal-title">Get the code</div>
                    <button class="code-modal-close" onclick="closeCodeModal()"><svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_86_588)"><path d="M16 0C7.16 0 0 7.16 0 16C0 24.84 7.16 32 16 32C24.84 32 32 24.84 32 16C32 7.16 24.84 0 16 0ZM16 30C8.28 30 2 23.72 2 16C2 8.28 8.28 2 16 2C23.72 2 30 8.28 30 16C30 23.72 23.72 30 16 30Z" fill="currentColor"/><path d="M21.76 20.28C22.16 20.68 22.16 21.34 21.76 21.74C21.56 21.94 21.3 22.04 21.04 22.04C20.78 22.04 20.52 21.94 20.32 21.74L16.02 17.44L11.7 21.74C11.5 21.94 11.24 22.04 10.98 22.04C10.72 22.04 10.46 21.94 10.26 21.74C9.86 21.34 9.86 20.68 10.26 20.28L14.56 16L10.26 11.72C9.86 11.34 9.86 10.68 10.26 10.28C10.66 9.88 11.3 9.88 11.7 10.28L16.02 14.56L20.32 10.28C20.72 9.88 21.36 9.88 21.76 10.28C22.16 10.68 22.16 11.34 21.76 11.72L17.46 16L21.76 20.28Z" fill="currentColor"/></g><defs><clipPath id="clip0_86_588"><rect width="32" height="32" fill="white"/></clipPath></defs></svg></button>
                    </div>
                <div class="code-modal-tabs">
                    <button class="code-modal-tab active" data-tab="css" onclick="switchCodeTab('css')">CSS</button>
                    <button class="code-modal-tab" data-tab="ios" onclick="switchCodeTab('ios')">iOS</button>
                    <button class="code-modal-tab" data-tab="android" onclick="switchCodeTab('android')">Android</button>
                    <button class="code-modal-tab" data-tab="visual-specs" onclick="switchCodeTab('visual-specs')">Visual Specs</button>
                </div>
                <div class="code-modal-content">
                    <div id="codeContent"></div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Timeline -->
        <div class="timeline-container hidden" id="timelineContainer">
            <div class="timeline-header">
                <span class="timeline-title">Timeline</span>
                <button class="timeline-toggle" id="timelineToggle" onclick="toggleTimeline()">
                    <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <g clip-path="url(#clip0_370_58)">
                            <path d="M15 9C15 8.44771 15.4477 8 16 8C16.5523 8 17 8.44772 17 9V20.5858L22.2929 15.2929C22.6834 14.9024 23.3166 14.9024 23.7071 15.2929C24.0976 15.6834 24.0976 16.3166 23.7071 16.7071L16.7071 23.7071C16.3166 24.0976 15.6834 24.0976 15.2929 23.7071L8.29289 16.7071C7.90237 16.3166 7.90237 15.6834 8.29289 15.2929C8.68342 14.9024 9.31658 14.9024 9.70711 15.2929L15 20.5858V9Z" fill="currentColor"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M0 16C0 7.16 7.16 0 16 0C24.84 0 32 7.16 32 16C32 24.84 24.84 32 16 32C7.16 32 0 24.84 0 16ZM2 16C2 23.72 8.28 30 16 30C23.72 30 30 23.72 30 16C30 8.28 23.72 2 16 2C8.28 2 2 8.28 2 16Z" fill="currentColor"/>
                        </g>
                        <defs>
                            <clipPath id="clip0_370_58">
                                <rect width="32" height="32" fill="white"/>
                            </clipPath>
                        </defs>
                    </svg>
                    <span>Hide Timeline</span>
                </button>
                    </div>
            <div class="timeline-content">
                <div class="timeline-labels" id="timelineLabels">
                    <!-- Layer labels -->
                    </div>
                <div class="timeline-canvas" id="timelineCanvas">
                    <div class="timeline-ruler" id="timelineRuler"></div>
                    <div id="timelineTracks"></div>
                    <div class="timeline-playhead" id="timelinePlayhead">
                        <div class="timeline-playhead-icon">
                            <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M23.6994 13.2273L17.0564 20.0573C16.7754 20.3382 16.3946 20.496 15.9975 20.496C15.6004 20.496 15.2196 20.3382 14.9386 20.0573L8.30056 13.2273C8.20541 13.1342 8.12981 13.023 8.0782 12.9002C8.02659 12.7774 8 12.6455 8 12.5123C8 12.3791 8.02659 12.2472 8.0782 12.1245C8.12981 12.0017 8.20541 11.8904 8.30056 11.7973C8.48773 11.6111 8.74091 11.5065 9.00482 11.5065L22.9927 11.504C23.124 11.504 23.2539 11.5299 23.3752 11.5803C23.4965 11.6306 23.6067 11.7043 23.6994 11.7973C23.7946 11.8904 23.8702 12.0017 23.9218 12.1245C23.9734 12.2472 24 12.3791 24 12.5123C24 12.6455 23.9734 12.7774 23.9218 12.9002C23.8702 13.023 23.7946 13.1342 23.6994 13.2273Z" fill="currentColor"/>
                            </svg>
                        </div>
                        <div class="timeline-playhead-tooltip" id="playheadTooltip">0ms</div>
                    </div>
                    </div>
                    </div>
            </div>
        
        <!-- Show Timeline Button -->
        <button class="show-timeline-btn" id="showTimelineBtn" onclick="toggleTimeline()" title="Explore your animation on an editable timeline view">
            <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g clip-path="url(#clip0_370_61)">
                    <path d="M17 23C17 23.5523 16.5523 24 16 24C15.4477 24 15 23.5523 15 23L15 11.4142L9.70711 16.7071C9.31658 17.0976 8.68342 17.0976 8.29289 16.7071C7.90237 16.3166 7.90237 15.6834 8.29289 15.2929L15.2929 8.29289C15.6834 7.90237 16.3166 7.90237 16.7071 8.29289L23.7071 15.2929C24.0976 15.6834 24.0976 16.3166 23.7071 16.7071C23.3166 17.0976 22.6834 17.0976 22.2929 16.7071L17 11.4142V23Z" fill="currentColor"/>
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M32 16C32 24.84 24.84 32 16 32C7.16 32 -7.72817e-07 24.84 0 16C7.72817e-07 7.16 7.16 -7.72817e-07 16 0C24.84 7.72817e-07 32 7.16 32 16ZM30 16C30 8.28 23.72 2 16 2C8.28 2 2 8.28 2 16C2 23.72 8.28 30 16 30C23.72 30 30 23.72 30 16Z" fill="currentColor"/>
                </g>
                <defs>
                    <clipPath id="clip0_370_61">
                        <rect width="32" height="32" fill="white"/>
                    </clipPath>
                </defs>
            </svg>
            <span>Show Timeline</span>
        </button>
                    </div>
            
    <script>
        // Pattern definitions organized by category
        const patternCategories = {
            'slide': {
                'motion-slide-up': { transform: 'translateY(100%)', opacity: 0, duration: 300, easing: 'cubic-bezier(0, 0, 0.2, 1)' },
                'motion-slide-down': { transform: 'translateY(-100%)', opacity: 0, duration: 300, easing: 'cubic-bezier(0, 0, 0.2, 1)' },
                'motion-slide-horizontal-in': { transform: 'translateX(100%)', opacity: 0, duration: 300, easing: 'cubic-bezier(0, 0, 0.2, 1)' },
                'motion-slide-horizontal-out': { transform: 'translateX(-100%)', opacity: 0, duration: 300, easing: 'cubic-bezier(0, 0, 0.2, 1)' }
            },
            'fade': {
                'motion-fade-in': { opacity: 0, duration: 300, easing: 'cubic-bezier(0.4, 0, 0.6, 1)' },
                'motion-fade-out': { opacity: 1, duration: 250, easing: 'cubic-bezier(0.4, 0, 1, 1)' }
            },
            'scale-fade': {
                'motion-scale-fade-in': { transform: 'scale(0.85)', opacity: 0, duration: 300, easing: 'cubic-bezier(0, 0, 0.2, 1)' },
                'motion-scale-fade-out': { transform: 'scale(0.85)', opacity: 0, duration: 250, easing: 'cubic-bezier(0.4, 0, 1, 1)' },
                'motion-scale-fade-small': { transform: 'scale(0.95)', opacity: 0, duration: 150, easing: 'cubic-bezier(0, 0, 0.2, 1)' }
            },
            'expand-collapse': {
                'motion-expand': { transform: 'scaleY(0)', transformOrigin: 'top', opacity: 0, duration: 300, easing: 'cubic-bezier(0, 0, 0.2, 1)' },
                'motion-collapse': { transform: 'scaleY(0)', transformOrigin: 'top', opacity: 0, duration: 250, easing: 'cubic-bezier(0.4, 0, 1, 1)' }
            },
            'press': {
                'motion-press': { transform: 'scale(0.95)', duration: 150, easing: 'cubic-bezier(0.4, 0, 0.2, 1)' }
            },
            'hover-lift': {
                'motion-lift': { transform: 'translateY(-4px)', duration: 150, easing: 'cubic-bezier(0.4, 0, 0.2, 1)' },
                'motion-grow': { transform: 'scale(1.05)', duration: 150, easing: 'cubic-bezier(0.4, 0, 0.2, 1)' }
            },
            'stagger': {
                'motion-stagger-light': { transform: 'translateY(20px)', opacity: 0, duration: 200, easing: 'cubic-bezier(0, 0, 0.2, 1)', staggerDelay: 50 },
                'motion-stagger-relaxed': { transform: 'translateY(20px)', opacity: 0, duration: 200, easing: 'cubic-bezier(0, 0, 0.2, 1)', staggerDelay: 100 }
            }
        };
        
        const springs = {
            'gentle': 'cubic-bezier(0.34, 1.2, 0.64, 1)',
            'bouncy': 'cubic-bezier(0.34, 1.56, 0.64, 1)',
            'smooth': 'cubic-bezier(0.4, 0, 0.2, 1)'
        };
        
        // Effect values
        const effectValues = {
            'blur': {
                'motion-blur-0': '0px',
                'motion-blur-4': '4px',
                'motion-blur-8': '8px',
                'motion-blur-12': '12px',
                'motion-blur-16': '16px',
                'motion-blur-24': '24px',
                'motion-blur-32': '32px',
                'motion-blur-100': '100px'
            },
            'scale': {
                'motion-scale-0': '0',
                'motion-scale-50': '0.5',
                'motion-scale-75': '0.75',
                'motion-scale-85': '0.85',
                'motion-scale-90': '0.9',
                'motion-scale-95': '0.95',
                'motion-scale-100': '1',
                'motion-scale-105': '1.05',
                'motion-scale-110': '1.1',
                'motion-scale-125': '1.25',
                'motion-scale-150': '1.5'
            },
            'rotation': {
                'motion-rotation-0': '0deg',
                'motion-rotation-45': '45deg',
                'motion-rotation-90': '90deg',
                'motion-rotation-180': '180deg',
                'motion-rotation-270': '270deg',
                'motion-rotation-360': '360deg',
                'motion-rotation--45': '-45deg',
                'motion-rotation--90': '-90deg',
                'motion-rotation--180': '-180deg'
            },
            'alpha': {
                'motion-alpha-0': '0',
                'motion-alpha-10': '0.1',
                'motion-alpha-20': '0.2',
                'motion-alpha-30': '0.3',
                'motion-alpha-40': '0.4',
                'motion-alpha-50': '0.5',
                'motion-alpha-60': '0.6',
                'motion-alpha-70': '0.7',
                'motion-alpha-80': '0.8',
                'motion-alpha-90': '0.9',
                'motion-alpha-100': '1'
            },
            'spring': {
                'motion-spring-gentle': 'cubic-bezier(0.34, 1.2, 0.64, 1)',
                'motion-spring-bouncy': 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                'motion-spring-smooth': 'cubic-bezier(0.4, 0, 0.2, 1)'
            },
            'radius': {
                'radius-0': '0px',
                'radius-2': '2px',
                'radius-4': '4px',
                'radius-6': '6px',
                'radius-8': '8px',
                'radius-12': '12px',
                'radius-16': '16px',
                'radius-20': '20px',
                'radius-24': '24px',
                'radius-32': '32px',
                'radius-50': '50%'
            },
            'translateY': {
                // Support numeric values directly (used in presets)
                '-100': '-100%',
                '-50': '-50%',
                '-35': '-35px',
                '-20': '-20px',
                '-10': '-10px',
                '-4': '-4px',
                '0': '0px',
                '4': '4px',
                '10': '10px',
                '20': '20px',
                '35': '35px',
                '50': '50%',
                '100': '100%'
            },
            'translateX': {
                '-100': '-100%',
                '-50': '-50%',
                '0': '0px',
                '50': '50%',
                '100': '100%'
            },
            'scaleY': {
                '0': '0',
                '0.5': '0.5',
                '0.75': '0.75',
                '0.85': '0.85',
                '0.9': '0.9',
                '0.95': '0.95',
                '1': '1',
                '1.05': '1.05',
                '1.1': '1.1'
            },
            'opacity': {
                // Map opacity to alpha values for compatibility
                '0': '0',
                '0.1': '0.1',
                '0.2': '0.2',
                '0.3': '0.3',
                '0.4': '0.4',
                '0.5': '0.5',
                '0.6': '0.6',
                '0.7': '0.7',
                '0.8': '0.8',
                '0.9': '0.9',
                '1': '1'
            }
        };
        
        // Undo/Redo history
        let historyStack = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;
        
        function saveState() {
            // Remove any future states if we're not at the end
            historyStack = historyStack.slice(0, historyIndex + 1);
            
            // Save current state
            const state = {
                layers: JSON.parse(JSON.stringify(layers)),
                layerGroups: JSON.parse(JSON.stringify(layerGroups)),
                splitStates: JSON.parse(JSON.stringify(splitStates)), // Include split states for undo/redo
                selectedLayerId: selectedLayerId,
                selectedFolderId: selectedFolderId
            };
            
            historyStack.push(state);
            historyIndex++;
            
            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
                historyIndex--;
            }
            
            updateUndoRedoButtons();
        }
        
        function undoAction() {
            if (historyIndex > 0) {
                historyIndex--;
                const state = historyStack[historyIndex];
                restoreState(state);
            }
        }
        
        function redoAction() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                const state = historyStack[historyIndex];
                restoreState(state);
            }
        }
        
        function restoreState(state) {
            layers = JSON.parse(JSON.stringify(state.layers));
            layerGroups = JSON.parse(JSON.stringify(state.layerGroups));
            splitStates = JSON.parse(JSON.stringify(state.splitStates || {})); // Restore split states
            selectedLayerId = state.selectedLayerId;
            selectedFolderId = state.selectedFolderId;
            
            // Re-render everything
            renderLayersPanel();
            renderPropertiesPanel();
            updateTimeline();
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = historyIndex <= 0;
            if (redoBtn) redoBtn.disabled = historyIndex >= historyStack.length - 1;
        }
        
        // Composition management
        let compositionWidth = 800;
        let compositionHeight = 500;
        
        function updateCompositionSize(fromUserInput = false) {
            console.log('ðŸ” updateCompositionSize called from:', new Error().stack);
            console.log('ðŸ” Initial compositionWidth:', compositionWidth, 'compositionHeight:', compositionHeight);
            console.log('ðŸ” fromUserInput:', fromUserInput);
            
            // Calculate from largest asset if layers exist - BUT SKIP if user is manually changing dimensions
            if (layers.length > 0 && !fromUserInput) {
                let maxWidth = 0;
                let maxHeight = 0;
                
                layers.forEach(layer => {
                    const element = document.getElementById(layer.id);
                    if (element) {
                        const img = element.querySelector('img');
                        if (img) {
                            const scale = (layer.scale || 100) / 100;
                            maxWidth = Math.max(maxWidth, img.naturalWidth * scale);
                            maxHeight = Math.max(maxHeight, img.naturalHeight * scale);
                        }
                    }
                });
                
                if (maxWidth > 0 && maxHeight > 0) {
                    compositionWidth = Math.round(maxWidth);
                    compositionHeight = Math.round(maxHeight);
                }
            }
            
            // Update layout inputs
            const widthInput = document.getElementById('layoutWidth');
            const heightInput = document.getElementById('layoutHeight');
            if (widthInput) widthInput.value = compositionWidth;
            if (heightInput) heightInput.value = compositionHeight;
            
            // DON'T recreate composition - just update its size if it exists
            // Recreating it causes layers to be removed and re-added, which breaks positioning
            const container = document.getElementById('canvasContainer');
            const composition = container ? container.querySelector('.composition-area') : null;
            if (composition && previewMode === 'stacked') {
                // Just update the size, don't recreate
                const oldWidth = parseFloat(composition.style.width) || composition.offsetWidth;
                const oldHeight = parseFloat(composition.style.height) || composition.offsetHeight;
                
                console.log('ðŸ”§ Setting composition size to:', compositionWidth, 'x', compositionHeight);
                composition.style.width = `${compositionWidth}px`;
                composition.style.height = `${compositionHeight}px`;
                console.log('ðŸ”§ Composition size after setting:', composition.style.width, 'x', composition.style.height);
                
                // Only log if size actually changed
                if (Math.abs(oldWidth - compositionWidth) > 1 || Math.abs(oldHeight - compositionHeight) > 1) {
                    console.log('ðŸ“ updateCompositionSize: Updated size from', oldWidth, 'x', oldHeight, 'to', compositionWidth, 'x', compositionHeight);
                }
            } else if (previewMode === 'stacked') {
                console.warn('âš ï¸ updateCompositionSize: No composition found, creating it and re-parenting layers');
                
                // Create composition
                renderComposition(true);
                
                // Wait for composition to be created, then re-parent layers
                setTimeout(() => {
                    const newComposition = container ? container.querySelector('.composition-area') : null;
                    if (newComposition) {
                        layers.forEach(layer => {
                            const element = document.getElementById(layer.id);
                            if (element && element.parentElement !== newComposition) {
                                newComposition.appendChild(element);
                                
                                // Respect visibility state
                                const groupId = layer.groupId;
                                const group = groupId ? layerGroups[groupId] : null;
                                const shouldBeVisible = layer.visible !== false && (!group || group.visible);
                                
                                if (shouldBeVisible) {
                                    element.style.display = 'block';
                                    element.style.visibility = 'visible';
                                } else {
                                    element.style.display = 'none';
                                }
                                
                                console.log(`âœ… Re-parented layer ${layer.id} to composition`);
                            }
                        });
                    } else {
                        console.error('âŒ Composition still not found after renderComposition()');
                    }
                }, 100);
            } else {
                // Side-by-side mode needs recreation
                console.log('ðŸ“ updateCompositionSize: Side-by-side mode, recreating');
                renderComposition(true);
            }
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
        }
        
        function renderComposition(skipPositionRestore = false) {
            const stackTrace = new Error().stack;
            const caller = stackTrace.split('\n')[2] || 'unknown';
            console.log('ðŸŽ¨ renderComposition called from:', caller.trim());
            
            // Only show composition if we have at least one layer
            if (layers.length === 0) {
                const existing = document.querySelectorAll('.composition-area');
                existing.forEach(el => el.remove());
                return;
            }
            
            const canvasArea = document.querySelector('.preview-canvas');
            const container = document.getElementById('canvasContainer');
            if (!canvasArea || !container) return;
            
            // If composition already exists in stacked mode and skipPositionRestore is true, don't recreate it
            // This prevents unnecessary recreation when updateCompositionSize is called
            // BUT: Only skip if composition actually exists and has the right dimensions
            if (previewMode === 'stacked' && skipPositionRestore) {
                const existingComposition = container.querySelector('.composition-area');
                if (existingComposition) {
                    // Check if composition has correct dimensions - if not, recreate it
                    const currentWidth = parseFloat(existingComposition.style.width) || existingComposition.offsetWidth;
                    const currentHeight = parseFloat(existingComposition.style.height) || existingComposition.offsetHeight;
                    // Allow 1px tolerance for rounding
                    if (Math.abs(currentWidth - compositionWidth) <= 1 && Math.abs(currentHeight - compositionHeight) <= 1) {
                        console.log('ðŸŽ¨ renderComposition: Composition already exists with correct size, skipping recreation');
                        return;
                    } else {
                        console.log('ðŸŽ¨ renderComposition: Composition exists but size mismatch', { current: { currentWidth, currentHeight }, target: { compositionWidth, compositionHeight }}, 'recreating');
                    }
                } else {
                    console.log('ðŸŽ¨ renderComposition: No composition found, will create it');
                }
            }
            
            // Store current layer positions and elements before removing composition
            const layerPositions = new Map();
            const layerElements = new Map();
            if (previewMode === 'stacked' && !skipPositionRestore) {
                layers.forEach(layer => {
                    const element = document.getElementById(layer.id);
                    if (element && layer.positionRelativeToComposition) {
                        layerPositions.set(layer.id, {
                            position: { ...layer.position },
                            isCompRelative: true
                        });
                        // Store element temporarily (it will be removed when composition is removed)
                        layerElements.set(layer.id, element);
                    }
                });
            }
            
            // Before removing composition, move layers out to preserve them
            const existing = container.querySelectorAll('.composition-area');
            existing.forEach(compEl => {
                // Move all layer elements out of composition before removing it
                const layerElements = Array.from(compEl.querySelectorAll('.preview-element'));
                layerElements.forEach(layerEl => {
                    container.appendChild(layerEl); // Move to container temporarily
                    console.log(`ðŸ”„ Moved layer ${layerEl.id} out of composition before removal`);
                });
                compEl.remove(); // Now safe to remove composition
                console.log('ðŸ—‘ï¸ Removed old composition');
            });
            
            // In side-by-side mode, create composition squares based on layer count
            if (previewMode === 'side-by-side') {
                console.log('ðŸŽ¨ renderComposition: Creating side-by-side grids');
                const visibleLayers = layers.filter(l => l.visible !== false);
                console.log('ðŸŽ¨ Visible layers:', visibleLayers.length);
                const layerCount = Math.min(visibleLayers.length, 6); // Max 6 squares
                console.log('ðŸŽ¨ Layer count for grid:', layerCount);
                
                if (layerCount === 0) {
                    console.log('ðŸŽ¨ No layers to display, returning');
                    return;
                }
                
                const containerRect = container.getBoundingClientRect();
                const gap = 20; // Gap between squares
                const squareSize = Math.min(compositionWidth, compositionHeight);
                
                // Calculate grid layout based on layer count (3x2 grid for up to 6 layers)
                let cols, rows;
                if (layerCount === 1) {
                    cols = 1; rows = 1;
                } else if (layerCount === 2) {
                    cols = 2; rows = 1;
                } else if (layerCount === 3) {
                    cols = 3; rows = 1;
                } else if (layerCount === 4) {
                    cols = 2; rows = 2;
                } else if (layerCount === 5 || layerCount === 6) {
                    cols = 3; rows = 2;
                }
                
                const totalWidth = (squareSize * cols) + (gap * (cols - 1));
                const totalHeight = (squareSize * rows) + (gap * (rows - 1));
                
                // Center grid within container (accounting for zoom)
                const containerWidth = container.offsetWidth;
                const containerHeight = container.offsetHeight;
                const startX = (containerWidth - totalWidth) / 2;
                const startY = (containerHeight - totalHeight) / 2;
                
                // Calculate zoom factor (zoomValue is percentage, convert to decimal)
                const zoomFactor = (typeof zoomValue !== 'undefined' ? zoomValue / 100 : 1);
                
                console.log('ðŸ“ Side-by-side grid layout:', {
                    layerCount,
                    cols,
                    rows,
                    squareSize,
                    totalWidth,
                    totalHeight,
                    containerWidth,
                    containerHeight,
                    startX,
                    startY,
                    zoomFactor,
                    zoomValue: typeof zoomValue !== 'undefined' ? zoomValue : 'undefined'
                });
                
                // Create composition squares
                let squareIndex = 0;
                for (let row = 0; row < rows && squareIndex < layerCount; row++) {
                    for (let col = 0; col < cols && squareIndex < layerCount; col++) {
                        const composition = document.createElement('div');
                        composition.className = 'composition-area';
                        composition.dataset.squareIndex = squareIndex;
                        
                        const left = startX + (col * (squareSize + gap));
                        const top = startY + (row * (squareSize + gap));
                        
                        composition.style.width = `${squareSize}px`;
                        composition.style.height = `${squareSize}px`;
                        composition.style.left = `${left}px`;
                        composition.style.top = `${top}px`;
                        
                        // Apply mode
                        if (compositionMode === 'dark') {
                            composition.classList.add('dark-mode');
                        }
                        
                        // Add number indicator
                        const numberLabel = document.createElement('div');
                        numberLabel.className = 'square-number';
                        numberLabel.textContent = squareIndex + 1;
                        numberLabel.style.cssText = `
                            position: absolute;
                            top: 8px;
                            left: 8px;
                            width: 15px;
                            height: 15px;
                            background: rgba(59, 130, 246, 0.1);
                            border: 1px solid rgba(59, 130, 246, 0.3);
                            border-radius: 3px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 9px;
                            font-weight: 600;
                            color: #000000;
                            pointer-events: none;
                            z-index: 1000;
                        `;
                        
                        composition.appendChild(numberLabel);
                        container.appendChild(composition);
                        
                        // Update position manager with first composition (for side-by-side mode)
                        if (squareIndex === 0) {
                            positionManager.compositionElement = composition;
                        }
                        
                        squareIndex++;
                    }
                }
                
                // Position layers in their corresponding squares
                positionLayersInSquares(visibleLayers.slice(0, layerCount));
            } else {
                // In stacked mode, create single composition area
                const composition = document.createElement('div');
                composition.className = 'composition-area';
                
                // Use CSS centering (container already has flexbox centering)
                composition.style.width = `${compositionWidth}px`;
                composition.style.height = `${compositionHeight}px`;
                
                // Apply mode
                if (compositionMode === 'dark') {
                    composition.classList.add('dark-mode');
                }
                
                container.appendChild(composition);
                
                // Update position manager with composition element
                positionManager.compositionElement = composition;
                
                // After creating new composition, move layers back into it
                if (previewMode === 'stacked') {
                    const tempLayers = Array.from(container.querySelectorAll('.preview-element'));
                    if (tempLayers.length > 0) {
                        tempLayers.forEach(layerEl => {
                            composition.appendChild(layerEl);
                            console.log(`âœ… Moved layer ${layerEl.id} back into new composition`);
                        });
                    }
                }
                
                // Move existing assets into composition-area (they may have been in container or old composition)
                if (previewMode === 'stacked') {
                    layers.forEach(layer => {
                        const element = document.getElementById(layer.id);
                        if (element && element.parentElement !== composition) {
                            // Element is not in composition-area, move it there
                            composition.appendChild(element);
                            
                            // Respect visibility state
                            const groupId = layer.groupId;
                            const group = groupId ? layerGroups[groupId] : null;
                            const shouldBeVisible = layer.visible !== false && (!group || group.visible);
                            
                            if (shouldBeVisible) {
                                element.style.display = 'block';
                                element.style.visibility = 'visible';
                            } else {
                                element.style.display = 'none';
                            }
                            
                            // Update position to be relative to composition-area
                            if (layer.positionRelativeToComposition) {
                                element.style.left = `${layer.position.x}px`;
                                element.style.top = `${layer.position.y}px`;
                                // Preserve transform for centered elements
                                const compWidth = composition.offsetWidth;
                                const compHeight = composition.offsetHeight;
                                const isCentered = Math.abs(layer.position.x - compWidth / 2) < 1 && Math.abs(layer.position.y - compHeight / 2) < 1;
                                element.style.transform = isCentered ? 'translate(-50%, -50%)' : '';
                            }
                        }
                    });
                }
            }
            
            // Apply shadows to all layers that have shadow set (regardless of selection)
            setTimeout(() => {
                applyAllLayerShadows();
                // Apply clipping to all assets
                applyCompositionClipping();
            }, 50);
        }
        
        function applyCompositionClipping() {
            const container = document.getElementById('canvasContainer');
            if (!container) return;
            
            const compositions = container.querySelectorAll('.composition-area');
            if (compositions.length === 0) {
                // Remove clipping from all assets if no composition exists
                layers.forEach(layer => {
                    const element = document.getElementById(layer.id);
                    if (element) {
                        element.style.clipPath = 'none';
                    }
                });
                return;
            }
            
            layers.forEach(layer => {
                const element = document.getElementById(layer.id);
                if (!element) return;
                
                if (previewMode === 'stacked') {
                    // In stacked mode, clip to the single composition area
                    const composition = compositions[0];
                    if (composition) {
                        const compRect = composition.getBoundingClientRect();
                        const elementRect = element.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        // Calculate composition bounds relative to container
                        const compLeft = compRect.left - containerRect.left;
                        const compTop = compRect.top - containerRect.top;
                        const compRight = compLeft + compRect.width;
                        const compBottom = compTop + compRect.height;
                        
                        // Calculate element position relative to container
                        const elementLeft = elementRect.left - containerRect.left;
                        const elementTop = elementRect.top - containerRect.top;
                        
                        // Calculate clip-path coordinates relative to element
                        const clipLeft = Math.max(0, compLeft - elementLeft);
                        const clipTop = Math.max(0, compTop - elementTop);
                        const clipRight = Math.min(elementRect.width, compRight - elementLeft);
                        const clipBottom = Math.min(elementRect.height, compBottom - elementTop);
                        
                        // Apply clip-path using inset (more reliable than polygon)
                        if (clipLeft >= 0 && clipTop >= 0 && clipRight <= elementRect.width && clipBottom <= elementRect.height) {
                            element.style.clipPath = `inset(${clipTop}px ${elementRect.width - clipRight}px ${elementRect.height - clipBottom}px ${clipLeft}px)`;
                        } else {
                            // If element is completely outside, hide it
                            element.style.clipPath = 'inset(100%)';
                        }
                    }
                } else if (previewMode === 'side-by-side') {
                    // In side-by-side mode, find which composition square this layer belongs to
                    const visibleLayers = layers.filter(l => l.visible !== false);
                    const visibleIndex = visibleLayers.findIndex(l => l.id === layer.id);
                    
                    if (visibleIndex >= 0 && visibleIndex < compositions.length) {
                        const composition = Array.from(compositions).sort((a, b) => 
                            parseInt(a.dataset.squareIndex) - parseInt(b.dataset.squareIndex)
                        )[visibleIndex];
                        
                        if (composition) {
                            const compRect = composition.getBoundingClientRect();
                            const elementRect = element.getBoundingClientRect();
                            const containerRect = container.getBoundingClientRect();
                            
                            // Calculate composition bounds relative to container
                            const compLeft = compRect.left - containerRect.left;
                            const compTop = compRect.top - containerRect.top;
                            const compRight = compLeft + compRect.width;
                            const compBottom = compTop + compRect.height;
                            
                            // Calculate element position relative to container
                            const elementLeft = elementRect.left - containerRect.left;
                            const elementTop = elementRect.top - containerRect.top;
                            
                            // Calculate clip-path coordinates relative to element
                            const clipLeft = Math.max(0, compLeft - elementLeft);
                            const clipTop = Math.max(0, compTop - elementTop);
                            const clipRight = Math.min(elementRect.width, compRight - elementLeft);
                            const clipBottom = Math.min(elementRect.height, compBottom - elementTop);
                            
                            // Apply clip-path using inset
                            if (clipLeft >= 0 && clipTop >= 0 && clipRight <= elementRect.width && clipBottom <= elementRect.height) {
                                element.style.clipPath = `inset(${clipTop}px ${elementRect.width - clipRight}px ${elementRect.height - clipBottom}px ${clipLeft}px)`;
                            } else {
                                // If element is completely outside, hide it
                                element.style.clipPath = 'inset(100%)';
                            }
                        }
                    }
                }
            });
        }
        
        // Position layers in their corresponding composition squares (side-by-side mode)
        function positionLayersInSquares(layersToPosition) {
            console.log('ðŸ“ positionLayersInSquares called with', layersToPosition.length, 'layers');
            console.log('ðŸ“ Layer IDs:', layersToPosition.map(l => l.id));
            
            const container = document.getElementById('canvasContainer');
            if (!container || previewMode !== 'side-by-side') {
                console.log('âš ï¸ positionLayersInSquares: Skipping - container:', !!container, 'mode:', previewMode);
                return;
            }
            
            const compositions = Array.from(container.querySelectorAll('.composition-area'))
                .sort((a, b) => parseInt(a.dataset.squareIndex) - parseInt(b.dataset.squareIndex));
            
            console.log('ðŸ“ Found', compositions.length, 'composition squares');
            
            layersToPosition.forEach((layer, index) => {
                if (index >= compositions.length) {
                    console.warn('âš ï¸ Layer index', index, 'exceeds composition count', compositions.length);
                    return;
                }
                
                const element = document.getElementById(layer.id);
                const composition = compositions[index];
                
                console.log(`ðŸ“ Layer ${index}:`, {
                    id: layer.id,
                    name: layer.name,
                    elementExists: !!element,
                    visible: element?.style.display,
                    opacity: element?.style.opacity,
                    compositionExists: !!composition
                });
                
                if (!element) {
                    console.error('âŒ Element not found for layer:', layer.id);
                    return;
                }
                if (!composition) {
                    console.error('âŒ Composition not found for index:', index);
                    return;
                }
                
                const compRect = composition.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                // Get composition bounds with 45px margin
                const margin = 45;
                const compLeft = (compRect.left - containerRect.left) + margin;
                const compTop = (compRect.top - containerRect.top) + margin;
                const compRight = (compRect.right - containerRect.left) - margin;
                const compBottom = (compRect.bottom - containerRect.top) - margin;
                const compWidth = compRight - compLeft;
                const compHeight = compBottom - compTop;
                
                // Get element natural dimensions
                const img = element.querySelector('img');
                if (!img) {
                    console.error('âŒ No img element found in layer:', layer.id);
                    return;
                }
                
                // Wait for image to load
                const applyScaling = () => {
                    const naturalWidth = img.naturalWidth || img.width;
                    const naturalHeight = img.naturalHeight || img.height;
                    
                    if (!naturalWidth || !naturalHeight) {
                        console.log('â³ Waiting for image to load:', layer.id, 'naturalWidth:', naturalWidth, 'naturalHeight:', naturalHeight);
                        setTimeout(applyScaling, 50);
                        return;
                    }
                    
                    console.log(`âœ… Image loaded for ${layer.id}:`, {
                        naturalWidth,
                        naturalHeight,
                        compWidth,
                        compHeight,
                        compLeft,
                        compTop
                    });
                    
                    // Calculate scale to fit with margin
                    const scaleX = compWidth / naturalWidth;
                    const scaleY = compHeight / naturalHeight;
                    const scale = Math.min(scaleX, scaleY, 1); // Don't scale up
                    
                    const scaledWidth = naturalWidth * scale;
                    const scaledHeight = naturalHeight * scale;
                    
                    // Center in composition area
                    const compCenterX = compLeft + (compWidth / 2);
                    const compCenterY = compTop + (compHeight / 2);
                    const elementX = compCenterX - (scaledWidth / 2);
                    const elementY = compCenterY - (scaledHeight / 2);
                    
                    console.log(`ðŸ“ Positioning ${layer.id}:`, {
                        scale,
                        scaledWidth,
                        scaledHeight,
                        elementX,
                        elementY,
                        compCenterX,
                        compCenterY
                    });
                    
                    // Respect visibility state - only show if layer is visible
                    if (layer.visible !== false) {
                        element.style.display = 'block';
                        element.style.visibility = 'visible';
                        element.style.opacity = '1';
                    } else {
                        element.style.display = 'none';
                        return; // Skip positioning for hidden layers
                    }
                    
                    element.style.position = 'absolute';
                    element.style.left = `${elementX}px`;
                    element.style.top = `${elementY}px`;
                    element.style.width = `${scaledWidth}px`;
                    element.style.height = `${scaledHeight}px`;
                    element.style.transform = '';
                    element.style.maxWidth = 'none';
                    element.style.maxHeight = 'none';
                    
                    console.log(`âœ… Positioned ${layer.id} at (${elementX}, ${elementY}) with size ${scaledWidth}x${scaledHeight}`);
                    
                    // Update layer position and scale
                    layer.position.x = elementX;
                    layer.position.y = elementY;
                    layer.scale = scale * 100;
                    
                    // Update scale input if this layer is selected
                    if (selectedLayerId === layer.id) {
                        const scaleInputs = document.querySelectorAll('#layerScaleInput');
                        scaleInputs.forEach(input => {
                            input.value = Math.round(layer.scale);
                        });
                    }
                    
                    // Ensure z-index is set correctly
                    element.style.zIndex = '2';
                    
                    // Apply shadow if layer has one set (regardless of selection)
                    if (layer.shadow !== undefined && layer.shadow > 0) {
                        applyLayerShadow(layer.id, layer.shadow);
                    } else {
                        // Remove shadow if shadow is 0 or undefined
                        const el = document.getElementById(layer.id);
                        if (el) el.style.filter = 'none';
                    }
                };
                
                if (img.complete) {
                    applyScaling();
                } else {
                    img.addEventListener('load', applyScaling);
                    setTimeout(applyScaling, 100);
                }
            });
        }
        
        // Lock aspect ratio
        let aspectRatioLocked = false;
        let lockedAspectRatio = 1;
        
        // Figma-style dimension controls
        let isDraggingDimension = false;
        let dragDimensionType = null;
        let dimensionDragStartX = 0;
        let dimensionDragStartValue = 0;
        let updateCompositionTimeout = null;
        
        function setupDimensionControls() {
            const widthLabel = document.querySelector('[data-dimension="width"]');
            const heightLabel = document.querySelector('[data-dimension="height"]');
            
            [widthLabel, heightLabel].forEach(label => {
                if (!label) return;
                
                label.addEventListener('mousedown', (e) => {
                    // Don't prevent default if clicking on the input field itself
                    if (e.target.classList.contains('dimension-input') || 
                        e.target.tagName === 'INPUT') {
                        return; // Allow normal input behavior
                    }
                    
                    e.preventDefault();
                    label.classList.add('scrubbing');
                    isDraggingDimension = true;
                    dragDimensionType = label.dataset.dimension;
                    dimensionDragStartX = e.clientX;
                    const input = label.nextElementSibling;
                    dimensionDragStartValue = parseInt(input.value) || 0;
                    
                    document.addEventListener('mousemove', onDimensionDrag);
                    document.addEventListener('mouseup', stopDimensionDrag);
                });
            });
        }
        
        function onDimensionDrag(e) {
            if (!isDraggingDimension) return;
            
            const deltaX = e.clientX - dimensionDragStartX;
            const deltaValue = Math.round(deltaX / 2); // Adjust sensitivity
            const newValue = Math.max(100, Math.min(5000, dimensionDragStartValue + deltaValue));
            
            const input = document.getElementById(`layout${dragDimensionType.charAt(0).toUpperCase() + dragDimensionType.slice(1)}`);
            if (input) {
                input.value = newValue;
                if (dragDimensionType === 'width') {
                    compositionWidth = newValue;
                    if (aspectRatioLocked) {
                        compositionHeight = Math.round(newValue / lockedAspectRatio);
                        const heightInput = document.getElementById('layoutHeight');
                        if (heightInput) heightInput.value = compositionHeight;
                    }
                } else {
                    compositionHeight = newValue;
                    if (aspectRatioLocked) {
                        compositionWidth = Math.round(newValue * lockedAspectRatio);
                        const widthInput = document.getElementById('layoutWidth');
                        if (widthInput) widthInput.value = compositionWidth;
                    }
                }
                // Throttle composition updates during drag
                if (updateCompositionTimeout) {
                    clearTimeout(updateCompositionTimeout);
                }
                updateCompositionTimeout = setTimeout(() => {
                    updateCompositionSize(true); // User is manually changing dimensions via drag
                }, 50); // Only update every 50ms during drag
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
            }
        }
        
        function stopDimensionDrag() {
            isDraggingDimension = false;
            dragDimensionType = null;
            document.querySelectorAll('.dimension-label').forEach(l => l.classList.remove('scrubbing'));
            document.removeEventListener('mousemove', onDimensionDrag);
            document.removeEventListener('mouseup', stopDimensionDrag);
        }
        
        function toggleAspectLock() {
            const lockBtn = document.getElementById('lockAspectBtn');
            if (!lockBtn) return;
            
            aspectRatioLocked = !aspectRatioLocked;
            lockBtn.classList.toggle('locked', aspectRatioLocked);
            
            if (aspectRatioLocked) {
                lockedAspectRatio = compositionWidth / compositionHeight;
            }
        }
        
        // Setup layout input handlers
        function setupLayoutInputs() {
            const widthInput = document.getElementById('layoutWidth');
            const heightInput = document.getElementById('layoutHeight');
            const lockBtn = document.getElementById('lockAspectBtn');
            
            if (lockBtn) {
                lockBtn.addEventListener('click', toggleAspectLock);
            }
            
            if (widthInput) {
                widthInput.addEventListener('change', (e) => {
                    const newWidth = parseInt(e.target.value) || 800;
                    if (aspectRatioLocked) {
                        compositionHeight = Math.round(newWidth / lockedAspectRatio);
                        if (heightInput) heightInput.value = compositionHeight;
                    }
                    compositionWidth = newWidth;
                    console.log('ðŸ“ Width changed to:', compositionWidth);
                    console.log('ðŸ“ Composition element exists:', !!document.querySelector('.composition-area'));
                    console.log('ðŸ“ Layers on canvas:', layers.map(l => ({
                        id: l.id, 
                        element: !!document.getElementById(l.id),
                        parent: document.getElementById(l.id)?.parentElement?.className
                    })));
                    updateCompositionSize(true); // User is manually changing dimensions
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
                });
                
                widthInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur(); // Trigger the change event
                    }
                });
            }
            
            if (heightInput) {
                heightInput.addEventListener('change', (e) => {
                    const newHeight = parseInt(e.target.value) || 500;
                    if (aspectRatioLocked) {
                        compositionWidth = Math.round(newHeight * lockedAspectRatio);
                        if (widthInput) widthInput.value = compositionWidth;
                    }
                    compositionHeight = newHeight;
                    console.log('ðŸ“ Height changed to:', compositionHeight);
                    console.log('ðŸ“ Composition element exists:', !!document.querySelector('.composition-area'));
                    console.log('ðŸ“ Layers on canvas:', layers.map(l => ({
                        id: l.id, 
                        element: !!document.getElementById(l.id),
                        parent: document.getElementById(l.id)?.parentElement?.className
                    })));
                    updateCompositionSize(true); // User is manually changing dimensions
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
                });
                
                heightInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur(); // Trigger the change event
                    }
                });
            }
            
            // Setup Figma-style controls
            setupDimensionControls();
        }
        
        // Get available effects - always use 'in' state
        function getAvailableEffects(state) {
            // In state has all effects except radius
            const { radius, ...inEffects } = effectValues;
            return inEffects;
        }
        
        // Reverse pattern mapping for "out" state
        const reversePatterns = {
            'motion-slide-up': 'motion-slide-down',
            'motion-slide-down': 'motion-slide-up',
            'motion-slide-horizontal-in': 'motion-slide-horizontal-out',
            'motion-slide-horizontal-out': 'motion-slide-horizontal-in',
            'motion-fade-in': 'motion-fade-out',
            'motion-fade-out': 'motion-fade-in',
            'motion-scale-fade-in': 'motion-scale-fade-out',
            'motion-scale-fade-out': 'motion-scale-fade-in'
        };
        
        let layers = [];
        
        // Position Lock System - prevents accidental repositioning
        let positionLockEnabled = true; // Locks are enabled by default
        let allowPositionChange = false; // Must be explicitly set to true to change positions
        
        // Helper functions for position lock
        function unlockPositions(callback) {
            allowPositionChange = true;
            try {
                callback();
            } finally {
                allowPositionChange = false;
            }
        }
        
        function canChangePosition() {
            return !positionLockEnabled || allowPositionChange;
        }
        
        let layerGroups = {}; // Store folder/group structure: { groupId: { name, layers: [] } }
        let selectedLayerId = null;
        let selectedFolderId = null;
        let selectedLayerIds = new Set(); // For multi-select
        let selectedFolderIds = new Set(); // For multi-select
        let previewMode = 'stacked';
        let previewBg = 'gray';
        let isPlaying = false;
        let zoomValue = 100;
        let timelineOpen = false;
        let pixelsPerMs = 1; // 1ms = 1px on timeline
        let currentPlayTime = 0; // Current playback time in ms
        let playStartTime = 0; // Timestamp when playback started
        let animationFrameId = null; // For requestAnimationFrame
        let isDraggingPlayhead = false;
        let collapsedFolders = new Set(); // Track which folders are collapsed
        let splitStates = {}; // Track split layers: { groupId: { originalLayer, originalSvgContent, originalElements } }
        
        // ============================================
        // POSITION MANAGER - Single Source of Truth
        // ============================================
        class PositionManager {
            constructor() {
                this.containerElement = null;
                this.compositionElement = null;
            }
            
            // Initialize - call this once on page load
            init() {
                this.containerElement = document.getElementById('canvasContainer');
                this.compositionElement = this.containerElement?.querySelector('.composition-area');
            }
            
            // Get composition position relative to container
            getCompositionOffset() {
                if (!this.containerElement || !this.compositionElement) {
                    return { left: 0, top: 0 };
                }
                
                const containerRect = this.containerElement.getBoundingClientRect();
                const compRect = this.compositionElement.getBoundingClientRect();
                
                return {
                    left: compRect.left - containerRect.left,
                    top: compRect.top - containerRect.top
                };
            }
            
            // Convert composition-relative position to absolute position (for CSS)
            compositionToAbsolute(layer) {
                if (!layer.position) return { x: 0, y: 0 };
                
                const offset = this.getCompositionOffset();
                return {
                    x: offset.left + layer.position.x,
                    y: offset.top + layer.position.y
                };
            }
            
            // Convert absolute position to composition-relative (for storage)
            absoluteToComposition(absoluteX, absoluteY) {
                const offset = this.getCompositionOffset();
                return {
                    x: absoluteX - offset.left,
                    y: absoluteY - offset.top
                };
            }
            
            // Get element's current composition-relative position
            getElementCompositionPosition(elementId) {
                const element = document.getElementById(elementId);
                if (!element || !this.containerElement) return { x: 0, y: 0 };
                
                const elementRect = element.getBoundingClientRect();
                const containerRect = this.containerElement.getBoundingClientRect();
                const offset = this.getCompositionOffset();
                
                const hasTransform = element.style.transform && element.style.transform.includes('translate');
                
                if (hasTransform) {
                    // Element is centered
                    const centerX = elementRect.left - containerRect.left + (elementRect.width / 2);
                    const centerY = elementRect.top - containerRect.top + (elementRect.height / 2);
                    return {
                        x: centerX - offset.left,
                        y: centerY - offset.top
                    };
                } else {
                    // Element uses top-left
                    const left = elementRect.left - containerRect.left;
                    const top = elementRect.top - containerRect.top;
                    return {
                        x: left - offset.left,
                        y: top - offset.top
                    };
                }
            }
            
            // Apply position to element (updates CSS)
            applyPositionToElement(elementId, layer) {
                const element = document.getElementById(elementId);
                if (!element || !layer.position) return;
                
                const absolute = this.compositionToAbsolute(layer);
                const hasTransform = element.style.transform && element.style.transform.includes('translate');
                
                element.style.left = `${absolute.x}px`;
                element.style.top = `${absolute.y}px`;
                element.style.transform = hasTransform ? 'translate(-50%, -50%)' : '';
            }
            
            // Update all layer positions (call after composition moves)
            updateAllLayerPositions(layers) {
                layers.forEach(layer => {
                    if (layer.position) {
                        this.applyPositionToElement(layer.id, layer);
                    }
                });
            }
        }
        
        // Create global instance
        const positionManager = new PositionManager();
        
        // Timeline drag state
        let draggedBar = null;
        let dragStartX = 0;
        let dragStartDelay = 0;
        let dragStartDuration = 0;
        let resizeHandle = null;
        
        // Layer reorder drag state
        let draggedLayerItem = null;
        let draggedLayerId = null;
        
        // Layer position drag state (for stacked mode)
        let isDraggingLayer = false;
        let draggedLayerElement = null;
        let layerDragStartX = 0;
        let layerDragStartY = 0;
        let layerInitialX = 0;
        let layerInitialY = 0;
        let lastDragEndTime = 0;
        
        // Initialize - File upload is now handled by inline onclick handlers
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.addEventListener('change', handleFileUpload);
        }
        
        // Add drag-and-drop handlers for empty state dropzone
        function setupDropzoneHandlers() {
            const emptyDropzone = document.getElementById('emptyStateDropzone');
            const uploadZone = document.getElementById('uploadZone');
            
            function handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.add('drag-over');
            }
            
            function handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
            }
            
            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    // Check if adding files would exceed side-by-side limit
                    if (previewMode === 'side-by-side' && layers.length + files.length > 6) {
                        showUploadLimitWarning();
                        return;
                    }
                    
                    const fileArray = Array.from(files);
                    const isSingleUpload = fileArray.length === 1;
                    fileArray.forEach((file, index) => {
                        const assetGroupId = 'asset-' + Date.now() + '-' + index;
                        setTimeout(() => {
                            if (file.type === 'image/svg+xml') {
                                handleSVGUpload(file, assetGroupId, isSingleUpload);
                            } else {
                                handleImageUpload(file, assetGroupId, isSingleUpload);
                            }
                        }, index * 50);
                    });
                }
            }
            
            // Setup empty state dropzone
            if (emptyDropzone) {
                emptyDropzone.addEventListener('dragover', handleDragOver);
                emptyDropzone.addEventListener('dragleave', handleDragLeave);
                emptyDropzone.addEventListener('drop', handleDrop);
            }
            
            // Setup upload zone (when layers exist)
            if (uploadZone) {
                uploadZone.addEventListener('dragover', handleDragOver);
                uploadZone.addEventListener('dragleave', handleDragLeave);
                uploadZone.addEventListener('drop', handleDrop);
            }
        }
        
        // Setup dropzone handlers on load
        setupDropzoneHandlers();
        setupLayoutInputs();
        renderComposition();
        
        // Arrow key navigation for selected layer
        document.addEventListener('keydown', (e) => {
            // Spacebar for play/pause
            if (e.key === ' ' && !e.target.matches('input, textarea, select')) {
                e.preventDefault();
                playAllAnimations();
                return;
            }
            
            // Handle arrow keys for selected layer or folder
            if (!e.target.matches('input, textarea, select')) {
                const step = e.shiftKey ? 10 : 1; // Shift = 10px, normal = 1px
                let moved = false;
                let layersToMove = [];
                
                // If folder is selected, move all layers in folder
                if (selectedFolderId && layerGroups[selectedFolderId]) {
                    const group = layerGroups[selectedFolderId];
                    layersToMove = group.layers.map(layerId => layers.find(l => l.id === layerId)).filter(l => l);
                } 
                // If layer is selected, move just that layer
                else if (selectedLayerId) {
                    const layer = layers.find(l => l.id === selectedLayerId);
                    if (layer) layersToMove = [layer];
                }
                
                if (layersToMove.length > 0) {
                    if (e.key === 'ArrowUp') {
                        layersToMove.forEach(layer => {
                            layer.position.y -= step;
                            moved = true;
                        });
                    } else if (e.key === 'ArrowDown') {
                        layersToMove.forEach(layer => {
                            layer.position.y += step;
                            moved = true;
                        });
                    } else if (e.key === 'ArrowLeft') {
                        layersToMove.forEach(layer => {
                            layer.position.x -= step;
                            moved = true;
                        });
                    } else if (e.key === 'ArrowRight') {
                        layersToMove.forEach(layer => {
                            layer.position.x += step;
                            moved = true;
                        });
                    }
                    
                    if (moved && previewMode === 'stacked') {
                        layersToMove.forEach(layer => {
                            const element = document.getElementById(layer.id);
                            if (element) {
                                element.style.left = `${layer.position.x}px`;
                                element.style.top = `${layer.position.y}px`;
                                element.style.transform = '';
                            }
                        });
                        e.preventDefault();
                        saveState();
                    }
                }
            }
        });
        
        // Deselect layers when clicking on empty canvas area (but not on layers or composition-area)
        document.getElementById('canvasContainer').addEventListener('click', (e) => {
            // Only deselect if clicking directly on canvas container or composition-area (not on layers)
            const target = e.target;
            if (target.id === 'canvasContainer' || 
                (target.classList.contains('canvas-container') && !target.closest('.preview-element')) ||
                (target.classList.contains('composition-area') && !target.closest('.preview-element'))) {
                deselectAll();
            }
        });
        
        // Right-click context menu for canvas
        let compositionMode = 'light'; // 'light' or 'dark'
        
        // Initialize light mode on page load
        setCompositionMode('light');
        
        document.getElementById('canvasArea').addEventListener('contextmenu', (e) => {
            // Check if right-click is on composition area
            const composition = e.target.closest('.composition-area');
            if (!composition) {
                // Allow default context menu if not on composition
                return;
            }
            
            e.preventDefault();
            
            // Remove existing menu
            const existingMenu = document.querySelector('.canvas-context-menu');
            if (existingMenu) existingMenu.remove();
            
            // Create context menu
            const menu = document.createElement('div');
            menu.className = 'canvas-context-menu';
            menu.style.left = `${e.pageX}px`;
            menu.style.top = `${e.pageY}px`;
            
            menu.innerHTML = `
                <div class="context-menu-item" onclick="setCompositionMode('light')">Light mode</div>
                <div class="context-menu-item" onclick="setCompositionMode('dark')">Dark mode</div>
            `;
            
            document.body.appendChild(menu);
            
            // Close menu on click outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }, { once: true });
            }, 0);
        });
        
        function setCompositionMode(mode) {
            compositionMode = mode;
            const compositions = document.querySelectorAll('.composition-area');
            compositions.forEach(composition => {
                if (mode === 'dark') {
                    composition.classList.add('dark-mode');
                } else {
                    composition.classList.remove('dark-mode');
                }
            });
            const menu = document.querySelector('.canvas-context-menu');
            if (menu) menu.remove();
            
            // Update toggle button states
            const lightBtn = document.getElementById('compositionModeBtnLight');
            const darkBtn = document.getElementById('compositionModeBtnDark');
            if (lightBtn && darkBtn) {
                if (mode === 'light') {
                    lightBtn.classList.add('active');
                    darkBtn.classList.remove('active');
                } else {
                    lightBtn.classList.remove('active');
                    darkBtn.classList.add('active');
                }
            }
        }
        
        document.getElementById('canvasArea').addEventListener('click', (e) => {
            if (e.target.id === 'canvasArea' || e.target.classList.contains('preview-canvas')) {
                deselectAll();
            }
        });
        
        // Smooth canvas navigation with mouse wheel zoom
        const canvasArea = document.getElementById('canvasArea');
        
        // Mouse wheel zoom with Ctrl/Cmd key for smooth zooming
        canvasArea.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                
                // Zoom in/out with smooth increments
                const delta = -e.deltaY;
                const zoomSpeed = 0.1;
                const newZoom = zoomValue + (delta > 0 ? zoomSpeed * 10 : -zoomSpeed * 10);
                
                // Clamp zoom between 10% and 200%
                zoomValue = Math.max(10, Math.min(200, newZoom));
                updateZoom();
            }
        }, { passive: false });
        
        
        // File upload
        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // Check if adding files would exceed side-by-side limit
            if (previewMode === 'side-by-side' && layers.length + files.length > 6) {
                showUploadLimitWarning();
                event.target.value = '';
                return;
            }
            
            // Process each file with its group context
            const isSingleUpload = files.length === 1;
            files.forEach((file, index) => {
                const assetGroupId = 'asset-' + Date.now() + '-' + index;
                setTimeout(() => {
                    // Check if it's an SVG file
                    if (file.type === 'image/svg+xml') {
                        handleSVGUpload(file, assetGroupId, isSingleUpload);
                    } else {
                        handleImageUpload(file, assetGroupId, isSingleUpload);
                    }
                }, index * 50); // Small delay between files for smooth loading
            });
            
            // Reset file input
            event.target.value = '';
        }
        
        // Show upload limit warning
        function showUploadLimitWarning() {
            const uploadZone = document.getElementById('uploadZone');
            const emptyDropzone = document.getElementById('emptyStateDropzone');
            const target = uploadZone || emptyDropzone;
            
            if (!target) return;
            
            // Remove existing warning
            const existing = target.querySelector('.upload-limit-warning');
            if (existing) existing.remove();
            
            const warning = document.createElement('div');
            warning.className = 'upload-limit-warning';
            warning.innerHTML = `
                <strong>âš ï¸ Side-by-side mode supports up to 6 layers</strong>
                <p>Switch to Stacked mode to add more layers</p>
            `;
            
            target.appendChild(warning);
            
            // Auto-remove after 5 seconds
            setTimeout(() => warning.remove(), 5000);
        }
        
        function handleImageUpload(file, assetGroupId, isSingleUpload = false) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const layerId = 'layer-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                const layer = {
                    id: layerId,
                    name: file.name,
                    type: 'Image',
                    src: e.target.result,
                    state: 'in',
                    category: '',
                    pattern: '',
                    duration: 300,
                    easing: '',
                    delay: 0,
                    visible: true,
                    effectsIn: [],
                    effectsOut: [],
                    effectsHover: [],
                    position: { x: 0, y: 0 },
                    scale: 100,
                    opacity: 100,
                    shadow: 0,
                    groupId: null  // No folder for single images
                };
                
                layers.push(layer);
                addLayerToCanvas(layer, isSingleUpload);
                renderLayersPanel();
                updateLayerZIndexes();
                selectLayer(layerId);
                updateTimeline();
                
            // Update composition size after image loads
            const img = new Image();
            img.onload = () => {
                updateCompositionSize();
                // Re-position layers if in side-by-side mode
                if (previewMode === 'side-by-side') {
                    setTimeout(() => {
                        renderComposition();
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
                        setTimeout(() => {
                            const visibleLayers = layers.filter(l => l.visible !== false);
                            const layerCount = Math.min(visibleLayers.length, 6);
                            positionLayersInSquares(visibleLayers.slice(0, layerCount));
                        }, 50);
                    }, 50);
                }
            };
            img.src = e.target.result;
                
                // Apply smart recommendations based on filename
                applySmartRecommendations(layer);
            };
            reader.readAsDataURL(file);
        }
        
        function applySmartRecommendations(layer) {
            const fileName = layer.name.toLowerCase();
            let suggestion = null;
            
            // Pattern matching for common UI elements
            if (fileName.includes('modal') || fileName.includes('dialog') || fileName.includes('popup')) {
                suggestion = {
                    pattern: 'motion-slide-up',
                    category: 'entry',
                    duration: 300,
                    easing: 'cubic-bezier(0, 0, 0.2, 1)',
                    message: 'ðŸ’¡ Modal detected! Suggested: slide-up animation'
                };
            } else if (fileName.includes('button') || fileName.includes('btn')) {
                suggestion = {
                    pattern: 'motion-press',
                    category: 'interactive',
                    duration: 150,
                    easing: 'cubic-bezier(0.4, 0, 0.6, 1)',
                    message: 'ðŸ’¡ Button detected! Suggested: press animation'
                };
            } else if (fileName.includes('card') || fileName.includes('tile')) {
                suggestion = {
                    pattern: 'motion-fade-in',
                    category: 'entry',
                    duration: 300,
                    easing: 'cubic-bezier(0.4, 0, 0.6, 1)',
                    message: 'ðŸ’¡ Card detected! Suggested: fade-in animation'
                };
            } else if (fileName.includes('menu') || fileName.includes('nav')) {
                suggestion = {
                    pattern: 'motion-slide-down',
                    category: 'entry',
                    duration: 250,
                    easing: 'cubic-bezier(0, 0, 0.2, 1)',
                    message: 'ðŸ’¡ Menu detected! Suggested: slide-down animation'
                };
            } else if (fileName.includes('tooltip') || fileName.includes('hint')) {
                suggestion = {
                    pattern: 'motion-fade-in-up',
                    category: 'entry',
                    duration: 200,
                    easing: 'cubic-bezier(0, 0, 0.2, 1)',
                    message: 'ðŸ’¡ Tooltip detected! Suggested: fade-in-up animation'
                };
            } else if (fileName.includes('notification') || fileName.includes('toast') || fileName.includes('alert')) {
                suggestion = {
                    pattern: 'motion-slide-in-right',
                    category: 'entry',
                    duration: 300,
                    easing: 'cubic-bezier(0, 0, 0.2, 1)',
                    message: 'ðŸ’¡ Notification detected! Suggested: slide-in-right animation'
                };
            } else if (fileName.includes('dropdown') || fileName.includes('select')) {
                suggestion = {
                    pattern: 'motion-expand',
                    category: 'entry',
                    duration: 200,
                    easing: 'cubic-bezier(0, 0, 0.2, 1)',
                    message: 'ðŸ’¡ Dropdown detected! Suggested: expand animation'
                };
            }
            
            if (suggestion) {
                // Apply suggestion
                layer.pattern = suggestion.pattern;
                layer.category = suggestion.category;
                layer.duration = suggestion.duration;
                layer.easing = suggestion.easing;
                
                // Store suggestion for later use
                layer.aiSuggestion = suggestion;
                
                // Show suggestion button
                const suggestionBtn = document.getElementById('aiSuggestionBtn');
                if (suggestionBtn) {
                    suggestionBtn.style.display = 'flex';
                    const patternSpan = suggestionBtn.querySelector('.ai-suggestion-pattern');
                    if (patternSpan) {
                        patternSpan.textContent = suggestion.pattern;
                    }
                }
            }
        }
        
        function applyAISuggestion() {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer || !layer.aiSuggestion) return;
            
            const suggestion = layer.aiSuggestion;
            layer.pattern = suggestion.pattern;
            layer.category = suggestion.category;
            layer.duration = suggestion.duration;
            layer.easing = suggestion.easing;
            
            renderPropertiesPanel();
            updateTimeline();
            
            // Hide suggestion button after applying
            const suggestionBtn = document.getElementById('aiSuggestionBtn');
            if (suggestionBtn) {
                suggestionBtn.style.display = 'none';
            }
        }
        
        // Load motion tokens from external HTML files
        async function loadMotionTokens() {
            const tokenFiles = [
                'duration-table-only-new/index.html',
                'easing-table-new/index.html',
            ];
            
            const tokens = {
                duration: {},
                easing: {},
                descriptions: {}
            };
            
            for (const file of tokenFiles) {
                try {
                    const response = await fetch(file);
                    const html = await response.text();
                    
                    // Parse HTML to extract tokens and descriptions
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Extract token definitions from table rows
                    const tokenRows = doc.querySelectorAll('.table-row');
                    
                    tokenRows.forEach(row => {
                        const nameEl = row.querySelector('.token-name-text');
                        const name = nameEl ? nameEl.textContent.trim() : null;
                        
                        if (!name) return;
                        
                        // Check if it's a duration token
                        if (name.includes('duration')) {
                            const valueEl = row.querySelector('.token-value-text[data-value]');
                            const value = valueEl ? parseInt(valueEl.getAttribute('data-value')) : null;
                            
                            if (value) {
                                tokens.duration[name] = value;
                            }
                        }
                        // Check if it's an easing token
                        else if (name.includes('easing')) {
                            const valueCell = row.querySelector('.token-value-cell');
                            const value = valueCell ? valueCell.getAttribute('data-design') || valueCell.getAttribute('data-web') : null;
                            
                            if (value) {
                                tokens.easing[name] = value;
                            }
                        }
                        
                        // Extract description
                        const descEl = row.querySelector('.token-description');
                        if (descEl) {
                            tokens.descriptions[name] = descEl.textContent.trim();
                        }
                    });
                } catch (error) {
                    console.warn('Could not load token file:', file, error);
                }
            }
            
            return tokens;
        }
        
        // Initialize tokens on page load
        let motionTokens = null;
        loadMotionTokens().then(tokens => {
            motionTokens = tokens;
            console.log('âœ… Motion tokens loaded:', tokens);
        });
        
        // Code generation
        let currentCodeTab = 'css';
        
        function openCodeModal() {
            const modal = document.getElementById('codeModalOverlay');
            if (modal) {
                modal.classList.add('active');
                generateCode();
            }
        }
        
        function closeCodeModal() {
            const modal = document.getElementById('codeModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        function switchCodeTab(tab) {
            currentCodeTab = tab;
            document.querySelectorAll('.code-modal-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
            generateCode();
        }
        
        function generateCode() {
            const content = document.getElementById('codeContent');
            if (!content) return;
            
            if (layers.length === 0) {
                content.innerHTML = '<p>No layers to generate code for. Please add some layers first.</p>';
                return;
            }
            
            let code = '';
            
            if (currentCodeTab === 'css') {
                code = generateCSSCode();
            } else if (currentCodeTab === 'ios') {
                code = generateiOSCode();
            } else if (currentCodeTab === 'android') {
                code = generateAndroidCode();
            } else if (currentCodeTab === 'visual-specs') {
                code = generateVisualSpecsCode();
            }
            
            content.innerHTML = `
                <div class="code-block">${code}</div>
                <button class="code-copy-btn" onclick="copyCode()">Copy code</button>
            `;
        }
        
        function generateCSSCode() {
            return layers.map(layer => {
                const effects = layer.effectsIn || [];
                const transforms = effects.map(e => {
                    if (e.type === 'scale') return `scale(${e.to})`;
                    if (e.type === 'rotation') return `rotate(${e.to})`;
                    if (e.type === 'translate') return `translate(${e.to})`;
                    return '';
                }).filter(t => t).join(' ');
                
                return `.${layer.id} {
  animation: ${layer.pattern || 'fade-in'} ${layer.duration || 300}ms ${layer.easing || 'ease-out'} ${layer.delay || 0}ms;
  opacity: ${effects.find(e => e.type === 'alpha')?.to || 1};
  transform: ${transforms || 'none'};
}`;
            }).join('\n\n');
        }
        
        function generateiOSCode() {
            return layers.map(layer => {
                return `UIView.animate(withDuration: ${(layer.duration || 300) / 1000.0}, delay: ${(layer.delay || 0) / 1000.0}, options: [.curveEaseOut], animations: {
    // ${layer.name}
    // Animation: ${layer.pattern || 'fade-in'}
})`;
            }).join('\n\n');
        }
        
        function generateAndroidCode() {
            return layers.map(layer => {
                return `ObjectAnimator.ofFloat(view, "alpha", 0f, 1f)
    .setDuration(${layer.duration || 300})
    .setStartDelay(${layer.delay || 0})
    .start();`;
            }).join('\n\n');
        }
        
        function generateVisualSpecsCode() {
            return layers.map(layer => {
                const duration = layer.duration || 1000;
                const delay = layer.delay || 0;
                const easing = layer.easing || 'default';
                
                return `${layer.name}:



## Display Animation

1. Position animation:

   - Duration: motion-duration-${duration}

   - Delay: motion-delay-${delay}

   - Easing: motion-easing-${easing} [cubic-bezier(0.4, 0, 0.2, 1)]

   - Transform: ${layer.effectsIn ? layer.effectsIn.map(e => `${e.type}: ${e.from} â†’ ${e.to}`).join(', ') : 'None'}



2. Opacity animation:

   - Duration: motion-duration-${duration}

   - Delay: motion-delay-${delay}

   - Easing: motion-easing-linear

   - Opacity: ${layer.effectsIn?.find(e => e.type === 'opacity')?.from || 0} â†’ ${layer.effectsIn?.find(e => e.type === 'opacity')?.to || 1}



## Other Properties

- Z-index: motion-z-index-1

`;
            }).join('\n\n---\n\n');
        }
        
        // Get animation preset using loaded motion tokens
        // ONLY returns presets for patterns that exist in patternCategories
        function getAnimationPresetFromTokens(componentType) {
            if (!motionTokens) {
                console.warn('âš ï¸ Motion tokens not loaded yet');
                return null;
            }
            
            // Map component types to actual patterns in patternCategories
            const componentToPattern = {
                modal: { category: 'scale-fade', pattern: 'motion-scale-fade-in' },
                toast: { category: 'slide', pattern: 'motion-slide-up' },
                button: { category: 'fade', pattern: 'motion-fade-in' },
                dropdown: { category: 'expand-collapse', pattern: 'motion-expand' }
            };
            
            const patternMapping = componentToPattern[componentType];
            
            // Check if the pattern actually exists in patternCategories
            if (!patternMapping || !patternCategories[patternMapping.category] || !patternCategories[patternMapping.category][patternMapping.pattern]) {
                console.log(`âš ï¸ No matching pattern found for component type: ${componentType}`);
                return null;
            }
            
            // Build preset based on component type and actual pattern
            const presets = {
                modal: {
                    name: "Modal",
                    description: "Standard modal entrance animation",
                    category: 'scale-fade',
                    pattern: 'motion-scale-fade-in',
                    suggestedPattern: 'motion-scale-fade-in',
                    tokenUsed: 'motion-duration-350',
                    tokenDescription: `Suggests pattern: motion-scale-fade-in with ${motionTokens.duration['motion-duration-350'] || 350}ms duration`,
                    display: {
                        duration: motionTokens.duration['motion-duration-350'] || 350,
                        delay: motionTokens.duration['motion-duration-0'] || 0,
                        easing: motionTokens.easing['motion-easing-default'] || 'cubic-bezier(0, 0, 0.2, 1)',
                        effects: [
                            { type: 'opacity', from: 0, to: 1 },
                            { type: 'scale', from: 0.85, to: 1 }
                        ]
                    }
                },
                toast: {
                    name: "Toast Notification",
                    description: "Toast/snackbar display animation",
                    category: 'slide',
                    pattern: 'motion-slide-up',
                    suggestedPattern: 'motion-slide-up',
                    tokenUsed: 'motion-duration-300',
                    tokenDescription: `Suggests pattern: motion-slide-up with ${motionTokens.duration['motion-duration-300'] || 300}ms duration`,
                    display: {
                        duration: motionTokens.duration['motion-duration-300'] || 300,
                        delay: motionTokens.duration['motion-duration-100'] || 100,
                        easing: motionTokens.easing['motion-easing-default'] || 'cubic-bezier(0, 0, 0.2, 1)',
                        effects: [
                            { type: 'translateY', from: 100, to: 0 },
                            { type: 'opacity', from: 0, to: 1 }
                        ]
                    }
                },
                button: {
                    name: "Button/Toggle",
                    description: "Quick micro-interaction",
                    category: 'fade',
                    pattern: 'motion-fade-in',
                    suggestedPattern: 'motion-fade-in',
                    tokenUsed: 'motion-duration-200',
                    tokenDescription: `Suggests pattern: motion-fade-in with ${motionTokens.duration['motion-duration-200'] || 200}ms duration`,
                    display: {
                        duration: motionTokens.duration['motion-duration-200'] || 200,
                        delay: motionTokens.duration['motion-duration-0'] || 0,
                        easing: motionTokens.easing['motion-easing-default'] || 'cubic-bezier(0, 0, 0.2, 1)',
                        effects: [
                            { type: 'opacity', from: 0, to: 1 }
                        ]
                    }
                },
                dropdown: {
                    name: "Dropdown Menu",
                    description: "Dropdown expansion animation",
                    category: 'expand-collapse',
                    pattern: 'motion-expand',
                    suggestedPattern: 'motion-expand',
                    tokenUsed: 'motion-duration-250',
                    tokenDescription: `Suggests pattern: motion-expand with ${motionTokens.duration['motion-duration-250'] || 250}ms duration`,
                    display: {
                        duration: motionTokens.duration['motion-duration-250'] || 250,
                        delay: motionTokens.duration['motion-duration-0'] || 0,
                        easing: motionTokens.easing['motion-easing-default'] || 'cubic-bezier(0, 0, 0.2, 1)',
                        effects: [
                            { type: 'scaleY', from: 0, to: 1 },
                            { type: 'opacity', from: 0, to: 1 }
                        ]
                    }
                }
            };
            
            return presets[componentType];
        }
        
        // Analyze layer and suggest animation preset
        function suggestAnimationPreset(layer) {
            if (!layer || !layer.name) {
                console.log('âš ï¸ No layer or layer name provided');
                return null;
            }
            
            const name = layer.name.toLowerCase();
            console.log(`ðŸ” Checking layer name for animation preset: "${layer.name}"`);
            
            // More specific matching patterns with word boundaries
            const patterns = {
                modal: /\b(modal|dialog|popup|overlay)\b/i,
                toast: /\b(toast|snack|notification|alert|banner)\b/i,
                button: /\b(button|btn|cta)\b/i,  // Removed 'toggle|switch' to be more specific
                dropdown: /\b(dropdown|menu|select|popover)\b/i
            };
            
            // Check each pattern with word boundaries
            for (const [type, regex] of Object.entries(patterns)) {
                if (regex.test(name)) {
                    console.log(`âœ… Detected ${type} from name: "${layer.name}"`);
                    return getAnimationPresetFromTokens(type);
                }
            }
            
            // Fallback: analyze dimensions - but be more conservative
            const width = layer.width || 0;
            const height = layer.height || 0;
            
            console.log(`ðŸ“ No name match, dimensions: ${width}x${height}`);
            
            // Only suggest if dimensions are very clear indicators
            // AND the name doesn't contradict it
            if (width > 300 && height > 200 && width < 600 && height < 400) {
                console.log('âœ… Detected modal from dimensions');
                return getAnimationPresetFromTokens('modal');
            }
            
            // Don't suggest for ambiguous cases (like small dimensions that could be anything)
            console.log(`âš ï¸ No clear pattern match for: "${layer.name}" (${width}x${height})`);
            return null;
        }
        
        // Show animation suggestion banner
        function showAnimationSuggestion(layerId, preset) {
            if (!preset) return;
            
            // Remove any existing suggestions
            const existing = document.querySelector('.animation-suggestion');
            if (existing) existing.remove();
            
            const banner = document.createElement('div');
            banner.className = 'animation-suggestion';
            banner.innerHTML = `
                <div class="suggestion-content">
                    <div class="suggestion-left">
                        <div class="suggestion-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L14.5 9.5L22 12L14.5 14.5L12 22L9.5 14.5L2 12L9.5 9.5L12 2Z" fill="white"/>
                                <path d="M19 4L19.5 6L21.5 6.5L19.5 7L19 9L18.5 7L16.5 6.5L18.5 6L19 4Z" fill="white"/>
                            </svg>
                        </div>
                        <div class="suggestion-badge">${preset.name} detected</div>
                    </div>
                    <div class="suggestion-middle">
                        <p class="suggestion-description">Suggests: <span class="suggestion-detail">Duration: ${preset.tokenUsed}</span>, <span class="suggestion-detail">Pattern: ${preset.pattern}</span></p>
                    </div>
                    <button class="suggestion-apply-btn">Apply Suggestion</button>
                    <button class="suggestion-dismiss-btn">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4L4 12M4 4L12 12" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            `;
            
            // Store preset data
            banner.dataset.presetData = JSON.stringify(preset);
            banner.dataset.layerId = layerId;
            
            // Position fixed relative to viewport
            document.body.appendChild(banner);
            
            // Position it above the canvas container
            const canvasContainer = document.getElementById('canvasContainer');
            if (canvasContainer) {
                const containerRect = canvasContainer.getBoundingClientRect();
                banner.style.top = `${containerRect.top + 20}px`;
                banner.style.left = `${containerRect.left + containerRect.width / 2}px`;
            }
            
            // Add click handler for apply button
            const applyBtn = banner.querySelector('.suggestion-apply-btn');
            if (applyBtn) {
                applyBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    try {
                        const storedPreset = JSON.parse(banner.dataset.presetData);
                        const storedLayerId = banner.dataset.layerId;
                        console.log('ðŸŽ¯ Applying preset:', storedPreset, 'to layer:', storedLayerId);
                        applyAnimationPreset(storedLayerId, storedPreset);
                    } catch (error) {
                        console.error('âŒ Error applying preset:', error);
                    }
                });
            }
            
            // Add click handler for dismiss button
            const dismissBtn = banner.querySelector('.suggestion-dismiss-btn');
            if (dismissBtn) {
                dismissBtn.addEventListener('click', () => banner.remove());
            }
        }
        
        // Apply suggested animation preset
        function applyAnimationPreset(layerId, preset) {
            console.log('ðŸŽ¯ applyAnimationPreset called:', { layerId, preset });
            
            const layer = layers.find(l => l.id === layerId);
            if (!layer) {
                console.error('âŒ Layer not found:', layerId);
                return;
            }
            
            if (!preset || !preset.display) {
                console.error('âŒ Invalid preset structure');
                return;
            }
            
            console.log('âœ… Found layer:', layer.name);
            
            // Use category and pattern from preset if available (they're now included in the preset)
            if (preset.category && preset.pattern) {
                layer.category = preset.category;
                layer.pattern = preset.pattern;
                console.log('âœ… Set category and pattern from preset:', preset.category, '/', preset.pattern);
            } else {
                // Fallback: Map preset names to actual patterns
                const patternMap = {
                    'Modal': { category: 'scale-fade', pattern: 'motion-scale-fade-in' },
                    'Toast Notification': { category: 'slide', pattern: 'motion-slide-up' },
                    'Button/Toggle': { category: 'fade', pattern: 'motion-fade-in' },
                    'Dropdown Menu': { category: 'expand-collapse', pattern: 'motion-expand' }
                };
                
                const mapping = patternMap[preset.name];
                if (mapping && patternCategories[mapping.category] && patternCategories[mapping.category][mapping.pattern]) {
                    layer.category = mapping.category;
                    layer.pattern = mapping.pattern;
                    console.log('âœ… Mapped to pattern:', mapping.category, '/', mapping.pattern);
                } else {
                    console.warn('âš ï¸ No valid pattern mapping found for:', preset.name);
                }
            }
            
            // Apply effects from preset (if available)
            if (preset.display && preset.display.effects) {
                layer.effectsIn = preset.display.effects;
                console.log('âœ… Applied preset effects:', layer.effectsIn);
            }
            
            // Apply duration, delay, easing from preset
            layer.duration = preset.display.duration;
            layer.delay = preset.display.delay;
            layer.easing = preset.display.easing;
            
            // Store as overrides so they show in UI
            layer.durationOverride = preset.display.duration;
            layer.delayOverride = preset.display.delay;
            layer.easingOverride = preset.display.easing;
            
            console.log('âœ… Applied values:', {
                category: layer.category,
                pattern: layer.pattern,
                duration: layer.duration,
                delay: layer.delay,
                easing: layer.easing,
                effects: layer.effectsIn
            });
            
            // Update UI - force full re-render
            selectLayer(layerId);
            updateTimeline();
            renderLayersPanel();
            saveState();
            
            // Remove suggestion banner
            const banner = document.querySelector('.animation-suggestion');
            if (banner) {
                banner.remove();
                console.log('âœ… Removed suggestion banner');
            }
            
            console.log('âœ¨ Applied animation preset:', preset.tokenUsed);
        }
        
        function copyCode() {
            const codeBlock = document.querySelector('.code-block');
            if (codeBlock) {
                navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                    const btn = document.querySelector('.code-copy-btn');
                    if (btn) {
                        const original = btn.textContent;
                        btn.textContent = 'Copied!';
                        setTimeout(() => btn.textContent = original, 2000);
                    }
                });
            }
        }
        
        function handleSVGUpload(file, assetGroupId, isSingleUpload = false) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const svgContent = e.target.result;
                
                // Always create as single layer during upload
                // Splitting only happens when switching to stacked mode
                createSingleLayerFromSVG(svgContent, file.name, assetGroupId, isSingleUpload);
            };
            reader.readAsText(file);
        }
        
        function createSingleLayerFromSVG(svgContent, fileName, assetGroupId, isSingleUpload = false) {
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const layerId = 'layer-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            const layer = {
                id: layerId,
                name: fileName,
                type: 'SVG',
                src: url,
                svgContent: svgContent,
                state: 'in',
                category: '',
                pattern: '',
                duration: 300,
                easing: '',
                visible: true,
                delay: 0,
                effectsIn: [],
                effectsOut: [],
                effectsHover: [],
                position: { x: 0, y: 0 },
                scale: 100,
                groupId: null  // No folder for single SVG layers
            };
            
            layers.push(layer);
            addLayerToCanvas(layer, isSingleUpload);
            renderLayersPanel();
            updateLayerZIndexes();
            selectLayer(layerId);
            updateTimeline();
            
            // Update composition size after SVG loads
            const img = new Image();
            img.onload = () => {
                updateCompositionSize();
                // Re-position layers if in side-by-side mode
                if (previewMode === 'side-by-side') {
                    setTimeout(() => {
                        renderComposition();
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
                        setTimeout(() => {
                            const visibleLayers = layers.filter(l => l.visible !== false);
                            const layerCount = Math.min(visibleLayers.length, 6);
                            positionLayersInSquares(visibleLayers.slice(0, layerCount));
                        }, 50);
                    }, 50);
                }
            };
            img.src = url;
        }
        
        function createLayersFromSVGGroups(svgElement, groups, fileName, assetGroupId) {
            const baseDelay = 0;
            const delayIncrement = 100; // Stagger by 100ms
            
            // Create main group
            if (!layerGroups[assetGroupId]) {
                layerGroups[assetGroupId] = {
                    id: assetGroupId,
                    name: fileName,
                    layers: [],
                    visible: true
                };
            }
            
            groups.forEach((group, index) => {
                // Create a new SVG for this group
                const newSvg = svgElement.cloneNode(false);
                newSvg.appendChild(group.cloneNode(true));
                
                // Serialize to string
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(newSvg);
                
                // Create blob URL
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                // Get layer name from id or data-name attribute
                const layerName = group.getAttribute('data-name') || 
                                 group.getAttribute('id') || 
                                 `Layer ${index + 1}`;
                
                const layerId = 'layer-' + Date.now() + '-' + index + '-' + Math.random().toString(36).substr(2, 9);
                const layer = {
                    id: layerId,
                    name: layerName,
                    type: 'SVG Layer',
                    src: url,
                    svgContent: svgString,
                    state: 'in',
                    category: '',
                    pattern: '',
                    duration: 300,
                    easing: '',
                    visible: true,
                    delay: baseDelay + (index * delayIncrement), // Auto-stagger
                    effectsIn: [],
                    effectsOut: [],
                    effectsHover: [],
                    position: { x: 0, y: 0 },
                    scale: 100,
                    groupId: assetGroupId
                };
                
                layerGroups[assetGroupId].layers.push(layerId);
                layers.push(layer);
                addLayerToCanvas(layer);
            });
            
            // Render panel and select first layer
            renderLayersPanel();
            updateLayerZIndexes();
            if (groups.length > 0) {
                const firstLayerId = layers[layers.length - groups.length].id;
                selectLayer(firstLayerId);
            }
            
            updateTimeline();
            
            // Notify user
            setTimeout(() => {
                alert(
                    `âœ“ Created ${groups.length} layers in folder "${fileName}"!\n\n` +
                    `Delays auto-staggered by ${delayIncrement}ms for preview.\n` +
                    `Adjust in timeline or properties as needed.`
                );
            }, 100);
        }
        
        function addLayerToCanvas(layer, isSingleUpload = false) {
            const container = document.getElementById('canvasContainer');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            // Check if layer already exists on canvas - if so, don't recreate it!
            const existingElement = document.getElementById(layer.id);
            if (existingElement) {
                console.log('âš ï¸ addLayerToCanvas: Layer already exists, skipping:', layer.id);
                return; // Layer already exists, don't recreate it
            }
            
            // Create wrapper for the layer
            const wrapper = document.createElement('div');
            wrapper.id = layer.id;
            wrapper.className = 'preview-element';
            wrapper.dataset.layerId = layer.id;
            // Default to visible if not explicitly set
            if (layer.visible === undefined) {
                layer.visible = true;
            }
            wrapper.style.display = layer.visible !== false ? 'block' : 'none';
            
            // Create the image
            const img = document.createElement('img');
            img.src = layer.src;
            img.style.display = 'block';
            img.style.pointerEvents = 'none'; // Let clicks pass through to wrapper
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100%';
            img.className = 'preview-element-img';
            
            // Set wrapper dimensions when image loads
            img.addEventListener('load', () => {
                const scale = layer.scale || 100;
                const width = img.naturalWidth * (scale / 100);
                const height = img.naturalHeight * (scale / 100);
                
                wrapper.style.width = `${width}px`;
                wrapper.style.height = `${height}px`;
                
                console.log(`âœ… Layer ${layer.id} sized:`, { width, height, scale });
            });
            
            // Apply position for stacked mode
            if (previewMode === 'stacked') {
                wrapper.style.position = 'absolute';
                wrapper.style.zIndex = '10'; // Base z-index, will be updated by updateLayerZIndexes
                
                // Wait for composition to be rendered
                // Position the new layer
                setTimeout(() => {
                    // Only set position if this is a NEW layer being added
                    // Don't reposition existing layers
                    const existingElement = document.getElementById(layer.id);
                    if (!existingElement) {
                        const composition = container.querySelector('.composition-area');
                        if (composition) {
                            const compWidth = composition.offsetWidth;
                            const compHeight = composition.offsetHeight;
                            
                            // Check if layer already has a position set (from split or other operations)
                            // If positionRelativeToComposition is true, use that position directly
                            if (layer.positionRelativeToComposition && (layer.position.x !== 0 || layer.position.y !== 0)) {
                                // Layer already has a position - use it directly
                                wrapper.style.left = `${layer.position.x}px`;
                                wrapper.style.top = `${layer.position.y}px`;
                                // Check if this is a centered element (at composition center)
                                const isCentered = Math.abs(layer.position.x - compWidth / 2) < 1 && Math.abs(layer.position.y - compHeight / 2) < 1;
                                wrapper.style.transform = isCentered ? 'translate(-50%, -50%)' : '';
                                console.log('âž• addLayerToCanvas: Using existing position:', layer.id, { x: layer.position.x, y: layer.position.y, isCentered });
                            } else if (layer.position.x === 0 && layer.position.y === 0 && !layer.positionRelativeToComposition) {
                                // Truly new layer with no position - center it
                                wrapper.style.left = `${compWidth / 2}px`;
                                wrapper.style.top = `${compHeight / 2}px`;
                                wrapper.style.transform = 'translate(-50%, -50%)';
                                layer.position.x = compWidth / 2;
                                layer.position.y = compHeight / 2;
                                layer.positionRelativeToComposition = true;
                                console.log('âž• addLayerToCanvas: New layer centered:', layer.id, { x: layer.position.x, y: layer.position.y });
                            } else {
                                // Legacy: convert container-relative to composition-relative
                                const compRect = composition.getBoundingClientRect();
                                const containerRect = container.getBoundingClientRect();
                                const compLeft = compRect.left - containerRect.left;
                                const compTop = compRect.top - containerRect.top;
                                layer.position.x = layer.position.x - compLeft;
                                layer.position.y = layer.position.y - compTop;
                                layer.positionRelativeToComposition = true;
                                wrapper.style.left = `${layer.position.x}px`;
                                wrapper.style.top = `${layer.position.y}px`;
                                wrapper.style.transform = '';
                                console.log('âž• addLayerToCanvas: Converted legacy position:', layer.id, { x: layer.position.x, y: layer.position.y });
                            }
                        } else {
                            // Fallback if no composition yet
                            wrapper.style.left = '50%';
                            wrapper.style.top = '50%';
                            wrapper.style.transform = 'translate(-50%, -50%)';
                            console.warn('âš ï¸ addLayerToCanvas: No composition found, using fallback positioning');
                        }
                    } else {
                        console.log('âš ï¸ addLayerToCanvas: Layer already positioned, skipping:', layer.id);
                    }
                }, 50);
            }
            
            wrapper.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent canvas deselect
                if (!isDraggingLayer) {
                    selectLayer(layer.id);
                }
            });
            
            // Add drag functionality for stacked mode
            wrapper.addEventListener('mousedown', (e) => {
                if (previewMode === 'stacked' && !isPlaying) {
                    e.preventDefault();
                    startLayerDrag(e, layer);
                }
            });
            
            wrapper.appendChild(img);
            
            // In stacked mode, append to composition-area so assets move naturally with it
            if (previewMode === 'stacked') {
                const composition = container.querySelector('.composition-area');
                if (composition) {
                    composition.appendChild(wrapper);
                } else {
                    // Fallback: append to container if composition doesn't exist yet
                    container.appendChild(wrapper);
                }
            } else {
                container.appendChild(wrapper);
            }
            
            // Apply scale, opacity, and shadow if set
            if (layer.scale && layer.scale !== 100) {
                applyLayerScale(layer.id, layer.scale);
            }
            if (layer.opacity !== undefined && layer.opacity !== 100) {
                applyLayerOpacity(layer.id, layer.opacity);
            }
            // Apply shadow if layer has one set
            if (layer.shadow !== undefined && layer.shadow > 0) {
                applyLayerShadow(layer.id, layer.shadow);
            }
            
            // Auto-fit zoom after adding
            setTimeout(() => {
                if (previewMode === 'side-by-side') {
                    // Re-render composition squares and position layers (needed for side-by-side)
                    renderComposition();
                    setTimeout(() => {
                        const visibleLayers = layers.filter(l => l.visible !== false);
                        const layerCount = Math.min(visibleLayers.length, 4);
                        positionLayersInSquares(visibleLayers.slice(0, layerCount));
                        zoomToFit();
                    }, 50);
                } else if (previewMode === 'stacked') {
                    // Update z-indexes so layers stack correctly
                    updateLayerZIndexes();
                    // DON'T re-render composition - it already exists and we just added a layer to it
                    // Only render composition if it doesn't exist yet
                    const existingComposition = container.querySelector('.composition-area');
                    if (!existingComposition) {
                        renderComposition();
                    }
                    
                    // Auto-fit zoom for stacked mode (only if needed)
                    setTimeout(() => {
                        zoomToFit();
                    }, 100);
                }
            }, 100);
            
            // After layer is added and positioned, suggest animation preset
            // Only show suggestion if this is a single upload, not bulk
            if (isSingleUpload) {
                const suggestion = suggestAnimationPreset(layer);
                if (suggestion) {
                    setTimeout(() => showAnimationSuggestion(layer.id, suggestion), 500);
                }
            }
        }
        
        function centerViewOnAssets() {
            const canvasArea = document.querySelector('.preview-canvas');
            const container = document.getElementById('canvasContainer');
            
            if (!canvasArea || !container) return;
            
            // Get all visible preview elements
            const elements = Array.from(container.querySelectorAll('.preview-element'))
                .filter(el => el.style.display !== 'none');
            
            if (elements.length === 0) return;
            
            // For side-by-side mode, calculate center of all elements
            if (previewMode === 'side-by-side') {
                requestAnimationFrame(() => {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    
                    elements.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        const x = rect.left - containerRect.left;
                        const y = rect.top - containerRect.top;
                        const width = rect.width;
                        const height = rect.height;
                        
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x + width);
                        maxY = Math.max(maxY, y + height);
                    });
                    
                    // Calculate center point of all elements
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    
                    // Calculate scroll position to center the elements
                    const viewportWidth = canvasArea.clientWidth;
                    const viewportHeight = canvasArea.clientHeight;
                    
                    const scrollX = centerX - (viewportWidth / 2);
                    const scrollY = centerY - (viewportHeight / 2);
                    
                    // Smooth scroll to center
                    canvasArea.scrollTo({
                        left: Math.max(0, scrollX),
                        top: Math.max(0, scrollY),
                        behavior: 'smooth'
                    });
                });
            }
            // For stacked mode, no special centering needed - it's already centered
        }
        
        function addLayerToPanel(layer) {
            const layersList = document.getElementById('layersList');
            const layerItem = document.createElement('div');
            layerItem.className = 'layer-item';
            layerItem.dataset.layerId = layer.id;
            layerItem.draggable = true;
            layerItem.innerHTML = `
                <div class="layer-icon">IMG</div>
                <div class="layer-info">
                    <div class="layer-name">${layer.name}</div>
                    <div class="layer-type">${layer.type}</div>
            </div>
            `;
            
            // Select layer
            layerItem.addEventListener('click', (e) => {
                selectLayer(layer.id);
            });
            
            // Drag and drop for reordering
            layerItem.addEventListener('dragstart', (e) => {
                draggedLayerItem = layerItem;
                draggedLayerId = layer.id;
                window.draggedLayerId = layer.id; // Store globally for folder drop handler
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('layerId', layer.id);
                e.dataTransfer.setData('type', 'layer');
                layerItem.classList.add('dragging');
            });
            
            layerItem.addEventListener('dragend', (e) => {
                layerItem.classList.remove('dragging');
                document.querySelectorAll('.layer-item').forEach(item => {
                    item.classList.remove('drag-over');
                });
            });
            
            layerItem.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (draggedLayerItem && layerItem !== draggedLayerItem) {
                    layerItem.classList.add('drag-over');
                }
            });
            
            layerItem.addEventListener('dragleave', (e) => {
                layerItem.classList.remove('drag-over');
            });
            
            layerItem.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                layerItem.classList.remove('drag-over');
                
                const draggedId = e.dataTransfer.getData('layerId') || draggedLayerId || window.draggedLayerId;
                const draggedType = e.dataTransfer.getData('type') || 'layer';
                
                if (draggedType === 'layer' && draggedId && draggedId !== layer.id) {
                    const draggedLayer = layers.find(l => l.id === draggedId);
                    const targetLayer = layer;
                    
                    // If dragged layer is nested and target is NOT, move it out of folder first
                    if (draggedLayer && draggedLayer.groupId && !targetLayer.groupId) {
                        console.log('ðŸ”“ Moving nested layer OUT of folder before reordering:', draggedId);
                        
                        // Remove from folder
                        const folder = layerGroups[draggedLayer.groupId];
                        if (folder) {
                            folder.layers = folder.layers.filter(id => id !== draggedId);
                        }
                        
                        // Make standalone
                        draggedLayer.groupId = null;
                    }
                    
                    // Now reorder
                    reorderLayer(draggedId, layer.id);
                    saveState();
                }
            });
            
            layersList.appendChild(layerItem);
        }
        
        // New folder-based panel rendering
        function updatePanelVisibility() {
            const hasLayers = layers.length > 0;
            const settingsPanel = document.querySelector('.settings-panel');
            const layersPanel = document.querySelector('.layers-panel');
            const layerPropertiesPanel = document.getElementById('layerPropertiesPanel');
            
            if (settingsPanel) {
                if (hasLayers) {
                    settingsPanel.classList.remove('hidden');
                } else {
                    settingsPanel.classList.add('hidden');
                }
            }
            
            if (layersPanel) {
                if (hasLayers) {
                    layersPanel.classList.remove('hidden');
                } else {
                    layersPanel.classList.add('hidden');
                }
            }
            
            if (layerPropertiesPanel) {
                if (hasLayers) {
                    layerPropertiesPanel.classList.remove('hidden');
                } else {
                    layerPropertiesPanel.classList.add('hidden');
                }
            }
        }
        
        function renderLayersPanel() {
            const layersList = document.getElementById('layersList');
            const uploadZone = document.getElementById('uploadZone');
            layersList.innerHTML = '';
            
            // Update panel visibility based on whether there are layers
            updatePanelVisibility();
            
            // Show/hide upload zone based on whether there are layers
            if (layers.length === 0) {
                uploadZone.style.display = 'none';
            } else {
                uploadZone.style.display = 'block';
                // Re-setup handlers when upload zone becomes visible
                setTimeout(() => setupDropzoneHandlers(), 0);
            }
            
            // Add drop zone at top for removing layers from folders
            const topDropZone = document.createElement('div');
            topDropZone.className = 'top-drop-zone';
            topDropZone.innerHTML = '<span>Drop here to remove from folder</span>';
            topDropZone.style.cssText = `
                padding: 12px;
                margin: 8px;
                border: 2px dashed rgba(0,0,0,0.2);
                border-radius: 4px;
                text-align: center;
                color: rgba(0,0,0,0.4);
                font-size: 11px;
                display: none;
                background: rgba(0,0,0,0.02);
            `;
            
            // Show drop zone when dragging a nested layer
            topDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                topDropZone.style.borderColor = 'var(--primary-purple)';
                topDropZone.style.background = 'rgba(108, 43, 217, 0.05)';
            });
            
            topDropZone.addEventListener('dragleave', () => {
                topDropZone.style.borderColor = 'rgba(0,0,0,0.2)';
                topDropZone.style.background = 'rgba(0,0,0,0.02)';
            });
            
            topDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                const draggedId = e.dataTransfer.getData('layerId') || draggedLayerId || window.draggedLayerId;
                
                if (draggedId) {
                    const draggedLayer = layers.find(l => l.id === draggedId);
                    
                    if (draggedLayer && draggedLayer.groupId) {
                        // Remove from folder
                        const folder = layerGroups[draggedLayer.groupId];
                        if (folder) {
                            folder.layers = folder.layers.filter(id => id !== draggedId);
                        }
                        
                        draggedLayer.groupId = null;
                        
                        rebuildLayersArray();
                        updateLayerZIndexes();
                        renderLayersPanel();
                        updateTimeline();
                        saveState();
                    }
                }
            });
            
            layersList.insertBefore(topDropZone, layersList.firstChild);
            
            // Show/hide drop zone based on what's being dragged (only add listeners once)
            if (!window.topDropZoneListenersAdded) {
                document.addEventListener('dragstart', (e) => {
                    const topDropZoneEl = document.querySelector('.top-drop-zone');
                    if (topDropZoneEl && e.target.closest('.layer-item')) {
                        const layerItem = e.target.closest('.layer-item');
                        // Try multiple ways to get layerId
                        const layerId = layerItem.dataset.layerId || layerItem.getAttribute('data-layer-id') || window.draggedLayerId;
                        if (layerId) {
                            const layer = layers.find(l => l.id === layerId);
                            if (layer && layer.groupId) {
                                topDropZoneEl.style.display = 'block';
                            }
                        }
                    }
                });
                
                document.addEventListener('dragend', () => {
                    const topDropZoneEl = document.querySelector('.top-drop-zone');
                    if (topDropZoneEl) {
                        topDropZoneEl.style.display = 'none';
                        topDropZoneEl.style.borderColor = 'rgba(0,0,0,0.2)';
                        topDropZoneEl.style.background = 'rgba(0,0,0,0.02)';
                    }
                });
                
                window.topDropZoneListenersAdded = true;
            }
            
            // Render folders first (newest first since we rebuild with new folder first), then standalone layers
            const folderIds = Object.keys(layerGroups); // Newest folder is first due to rebuild order
            folderIds.forEach(folderId => {
                const group = layerGroups[folderId];
                const groupLayers = layers.filter(l => group.layers.includes(l.id));
                // Allow empty folders to be rendered (don't skip them)
                
                // Use folderId (the key) if group.id doesn't exist (for backwards compatibility)
                const groupId = group.id || folderId;
                const isCollapsed = collapsedFolders.has(groupId);
                
                // Create folder
                const folder = document.createElement('div');
                folder.className = 'layer-folder';
                folder.dataset.groupId = groupId;
                folder.draggable = true;
                
                // Folder header
                const header = document.createElement('div');
                header.className = 'folder-header';
                header.innerHTML = `
                    <span class="visibility-toggle ${group.visible ? '' : 'hidden'}" data-action="visibility">
                        ${group.visible ? 
                            '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 12.0088C18.2007 12.0088 20.0013 13.8093 20.0013 16.01C20.0013 18.2107 18.2007 20.0113 16 20.0113C13.7993 20.0113 11.9987 18.2107 11.9987 16.01C11.9987 13.8093 13.7993 12.0088 16 12.0088ZM16 10.0081C12.679 10.0081 9.99812 12.689 9.99812 16.01C9.99812 19.331 12.679 22.0119 16 22.0119C19.321 22.0119 22.0019 19.331 22.0019 16.01C22.0019 12.689 19.321 10.0081 16 10.0081Z" fill="#050505"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.01563 16.01C6.43701 2.50579 25.543 2.50579 29.9644 16.01C25.543 29.5142 6.43701 29.5142 2.01563 16.01ZM31.925 16.5102C26.9634 32.015 5.03657 32.015 0.0750234 16.5102C-0.0250078 16.1701 -0.0250078 15.83 0.0750234 15.4898C5.03657 -0.0149975 26.9634 -0.0149975 31.925 15.4898C32.025 15.83 32.025 16.1701 31.925 16.5102Z" fill="#050505"/></svg>' :
                            '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.7818 14.45L19.9812 16.25C19.8612 18.27 18.2607 19.87 16.2401 19.99L14.4595 21.79C14.9397 21.93 15.4598 22.01 16 22.01C19.321 22.01 22.0019 19.33 22.0019 16.01C22.0019 15.47 21.9219 14.95 21.7818 14.45ZM16 10.01C12.679 10.01 9.99812 12.69 9.99812 16.01C9.99812 16.55 10.0781 17.07 10.2182 17.55L12.0188 15.75C12.1388 13.75 13.7393 12.15 15.7399 12.03L17.5405 10.21C17.0603 10.09 16.5402 10.01 16 10.01Z" fill="#050505"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0.0750234 15.51C-0.0250078 15.83 -0.0250078 16.19 0.0750234 16.51C0.995311 19.35 2.47577 21.67 4.31635 23.47L5.71679 22.05C4.11629 20.49 2.81588 18.47 2.01563 16.01C4.85652 7.31 13.8193 4.21 21.0016 6.75L22.5621 5.19C14.2194 1.73 3.37605 5.17 0.0750234 15.51ZM31.925 15.51C31.0047 12.67 29.5242 10.35 27.6837 8.55L26.2632 9.95C27.8637 11.51 29.1641 13.53 29.9844 16.01C27.1235 24.71 18.1607 27.81 10.9784 25.27L9.43795 26.83C17.7806 30.29 28.6239 26.85 31.925 16.51C32.025 16.19 32.025 15.83 31.925 15.51Z" fill="#050505"/><path d="M29.6843 3.71L26.1632 7.25L24.7227 8.67L20.8815 12.53L19.4411 13.97L13.9794 19.45L9.01782 24.41L7.53736 25.91L3.73617 29.71C3.5361 29.91 3.27602 30.01 3.03595 30.01C2.77587 30.01 2.51579 29.91 2.31572 29.71C1.9156 29.33 1.9156 28.69 2.31572 28.29L5.83682 24.77L7.25727 23.33L12.5589 18.03L18.0206 12.55L19.4611 11.11L22.9622 7.59L24.4626 6.11L28.2638 2.29C28.4639 2.09 28.724 1.99 28.964 1.99C29.2241 1.99 29.4842 2.09 29.6843 2.29C30.0844 2.67 30.0844 3.31 29.6843 3.71Z" fill="#050505"/></svg>'
                        }
                    </span>
                    <span class="folder-icon ${!isCollapsed ? 'open' : ''}" data-action="toggle" title="Click to ${isCollapsed ? 'expand' : 'collapse'}">
                        <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.08008 4H10.9199C11.2046 4 11.4473 4.10157 11.6328 4.28711L14.4805 7.13379C14.8555 7.50885 15.3641 7.71973 15.8945 7.71973H30C30.5476 7.71973 30.9998 8.17213 31 8.71973V26.9199C31 27.5076 30.5076 28 29.9199 28H2.08008C1.49236 28 1 27.5076 1 26.9199V5.08008C1 4.49236 1.49236 4 2.08008 4Z" stroke="#050505" stroke-width="2"/></svg>
                    </span>
                    <span class="folder-name" data-action="name" title="Double click to rename">${group.name}</span>
                    <span class="folder-count">${groupLayers.length}</span>
                `;
                
                // Event delegation for folder header actions
                header.addEventListener('click', (e) => {
                    // Check if click is on an action button (including SVG elements inside)
                    let target = e.target;
                    // If clicking on SVG or path, find the parent with data-action
                    while (target && target !== header && !target.dataset.action) {
                        target = target.parentElement;
                    }
                    
                    if (target && target.dataset.action) {
                        const action = target.dataset.action;
                        e.stopPropagation();
                        
                        if (action === 'toggle') {
                            e.preventDefault();
                            toggleFolder(groupId);
                            updateActionButtons();
                            return;
                        } else if (action === 'visibility') {
                            e.preventDefault();
                            toggleFolderVisibility(groupId);
                            // Also select folder when clicking visibility
                            if (!selectedFolderIds.has(groupId)) {
                                selectedFolderIds.clear();
                                selectedLayerIds.clear();
                                selectedFolderIds.add(groupId);
                                selectedFolderId = groupId;
                                selectFolder(groupId);
                            }
                            updateActionButtons();
                            return;
                        } else if (action === 'name') {
                            // Single click on name - let it bubble to select folder
                            // Double-click will be handled by folderNameEl's dblclick handler
                            // Don't prevent default or stop propagation here
                            return; // Let the default click behavior happen (folder selection)
                        }
                    }
                    
                    // Click on folder header (not on action buttons) - support multi-select with Command/Ctrl+click
                    const isCmdClick = e.metaKey || e.ctrlKey;
                    
                    if (isCmdClick) {
                        // Command+click: toggle multi-select
                        if (selectedFolderIds.has(groupId)) {
                            selectedFolderIds.delete(groupId);
                            folder.classList.remove('selected');
                            if (selectedFolderId === groupId) {
                                selectedFolderId = selectedFolderIds.size > 0 ? Array.from(selectedFolderIds)[0] : null;
                            }
                        } else {
                            selectedFolderIds.add(groupId);
                            folder.classList.add('selected');
                            selectedFolderId = groupId;
                        }
                        
                        // Deselect layers if any are selected
                        if (selectedLayerId) {
                            selectedLayerId = null;
                            selectedLayerIds.clear();
                            document.querySelectorAll('.layer-item').forEach(item => {
                                item.classList.remove('selected');
                            });
                        }
                    } else {
                        // Regular click: single select
                        selectedFolderIds.clear();
                        selectedLayerIds.clear();
                        selectedFolderIds.add(groupId);
                        selectedFolderId = groupId;
                        
                        // Deselect layers if any are selected
                        if (selectedLayerId) {
                            selectedLayerId = null;
                            selectedLayerIds.clear();
                            document.querySelectorAll('.layer-item').forEach(item => {
                                item.classList.remove('selected');
                            });
                        }
                        selectFolder(groupId);
                    }
                    
                    updateActionButtons();
                });
                
                // Double-click folder name to rename
                const folderNameEl = header.querySelector('.folder-name');
                if (folderNameEl) {
                    // Prevent single click from interfering with double-click
                    let clickTimer = null;
                    let isDoubleClick = false;
                    
                    folderNameEl.addEventListener('click', (e) => {
                        // Check if this is part of a double-click
                        if (isDoubleClick) {
                            isDoubleClick = false;
                            return;
                        }
                        
                        // Allow single click to select folder (handled by header click)
                        // But prevent it from firing immediately on double-click
                        clickTimer = setTimeout(() => {
                            clickTimer = null;
                            // Single click handling is done by header click handler
                        }, 300);
                    });
                    
                    folderNameEl.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        isDoubleClick = true;
                        
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                        
                        // Select folder first
                        selectedFolderIds.clear();
                        selectedLayerIds.clear();
                        selectedFolderIds.add(groupId);
                        selectedFolderId = groupId;
                        selectFolder(groupId);
                        
                        renameFolderInline(groupId, folderNameEl);
                    });
                }
                
                
                
                // Drag and drop for folder reordering
                folder.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('groupId', groupId);
                    e.dataTransfer.setData('type', 'folder');
                    folder.classList.add('dragging');
                });
                
                folder.addEventListener('dragend', (e) => {
                    folder.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                });
                
                folder.addEventListener('dragover', (e) => {
                    // Don't interfere with nested layer item drag/drop
                    // If dragging over a nested layer item, let it handle its own dragover
                    const isOnNestedLayer = e.target.closest('.layer-item');
                    const isOnHeader = e.target.closest('.folder-header');
                    
                    if (isOnNestedLayer && !isOnHeader) {
                        // Dragging over a nested layer - don't handle it here, let the layer handle it
                        console.log('FOLDER DRAGOVER - Skipping nested layer, letting layer handle it');
                        return; // Let the layer item handle it - don't prevent default or stop propagation
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    const dragType = e.dataTransfer.types.includes('text/plain') ? 
                        (e.dataTransfer.types.includes('groupid') ? 'folder' : 'layer') : null;
                    e.dataTransfer.dropEffect = 'move';
                    // Only show drag-over on header, not on content
                    if (isOnHeader) {
                        folder.classList.add('drag-over');
                    }
                });
                
                folder.addEventListener('dragleave', (e) => {
                    if (e.target === folder || e.target === header) {
                        folder.classList.remove('drag-over');
                    }
                });
                
                folder.addEventListener('drop', (e) => {
                    const isOnHeader = e.target.closest('.folder-header');
                    const isOnNestedLayer = e.target.closest('.layer-item');
                    
                    console.log('FOLDER DROP - isOnNestedLayer:', isOnNestedLayer, 'isOnHeader:', isOnHeader, 'target:', e.target.className);
                    
                    const draggedId = e.dataTransfer.getData('layerId') || draggedLayerId || window.draggedLayerId;
                    const draggedType = e.dataTransfer.getData('type');
                    
                    // Check if dropping on the folder itself (not header, not nested layer)
                    // This means dropping in the empty space/padding of the folder
                    // Handle moving layer OUT of folder first
                    if (!isOnHeader && !isOnNestedLayer && draggedType === 'layer' && draggedId) {
                        const draggedLayer = layers.find(l => l.id === draggedId);
                        
                        // If layer is FROM this folder, move it OUT
                        if (draggedLayer && draggedLayer.groupId === groupId) {
                            console.log('ðŸ”“ Moving layer OUT of folder (dropped on folder padding):', draggedId);
                            
                            e.preventDefault();
                            e.stopPropagation();
                            folder.classList.remove('drag-over');
                            
                            group.layers = group.layers.filter(id => id !== draggedId);
                            draggedLayer.groupId = null;
                            
                            rebuildLayersArray();
                            updateLayerZIndexes();
                            renderLayersPanel();
                            updateTimeline();
                            saveState();
                            
                            return;
                        }
                    }
                    
                    // Only handle drops that are actually ON the folder header or nested layers
                    // Let other drops pass through
                    if (!isOnHeader && !isOnNestedLayer) {
                        console.log('âš ï¸ Drop not on folder header or nested layer, ignoring');
                        return; // Don't prevent default, let it bubble to other handlers
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!isOnHeader && isOnNestedLayer) {
                        // Drop is on a nested layer - don't handle it here, let the layer handle it
                        console.log('FOLDER DROP - Skipping, letting layer handle it');
                        return;
                    }
                    
                    folder.classList.remove('drag-over');
                    
                    const draggedGroupId = e.dataTransfer.getData('groupId');
                    const draggedLayerId = e.dataTransfer.getData('layerId') || window.draggedLayerId;
                    
                    // Handle folder-to-folder reordering
                    if (draggedType === 'folder' && draggedGroupId && draggedGroupId !== groupId) {
                        reorderFolder(draggedGroupId, groupId);
                    }
                    // Handle layer drop on folder header (move layer into folder)
                    else if (draggedType === 'layer' && draggedLayerId) {
                        const draggedLayer = layers.find(l => l.id === draggedLayerId);
                        if (draggedLayer && draggedLayer.groupId !== groupId) {
                            // Remove from old folder if it was in one
                            if (draggedLayer.groupId && layerGroups[draggedLayer.groupId]) {
                                const oldGroup = layerGroups[draggedLayer.groupId];
                                const index = oldGroup.layers.indexOf(draggedLayerId);
                                if (index > -1) {
                                    oldGroup.layers.splice(index, 1);
                                }
                            }
                            // Add to this folder
                            draggedLayer.groupId = groupId;
                            if (!group.layers.includes(draggedLayerId)) {
                                group.layers.push(draggedLayerId);
                            }
                            rebuildLayersArray();
                            updateLayerZIndexes();
                            renderLayersPanel();
                            updateTimeline();
                            saveState();
                        }
                    }
                });
                
                // Folder content
                const content = document.createElement('div');
                content.className = `folder-content ${isCollapsed ? 'collapsed' : ''}`;
                // Calculate height based on number of layers (minimum 0 for empty folders)
                const contentHeight = Math.max(0, groupLayers.length * 60);
                content.style.maxHeight = isCollapsed ? '0px' : `${contentHeight}px`;
                
                // Allow drops on folder content for reordering layers within folder
                // Don't stop propagation - let nested layer items handle their own drops
                content.addEventListener('dragover', (e) => {
                    // Always prevent default to allow drop, but don't stop propagation
                    // This allows nested layer items to also handle dragover
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    // Don't call stopPropagation - let it bubble to nested layer items
                });
                
                // Add layers to folder
                groupLayers.forEach(layer => {
                    const layerItem = createLayerItem(layer, true);
                    content.appendChild(layerItem);
                });
                
                folder.appendChild(header);
                folder.appendChild(content);
                layersList.appendChild(folder);
            });
            
            // Then render standalone layers (not in any folder)
            const standaloneLayers = layers.filter(l => l.groupId === null);
            standaloneLayers.forEach(layer => {
                const layerItem = createLayerItem(layer, false);
                layersList.appendChild(layerItem);
            });
            
            // Make the entire layers list a drop target for moving layers out of folders
            layersList.addEventListener('dragover', (e) => {
                // Only handle if not over a folder or layer item
                const isOverFolder = e.target.closest('.layer-folder');
                const isOverLayer = e.target.closest('.layer-item');
                
                if (!isOverFolder && !isOverLayer) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    console.log('ðŸ“ Drag over empty space in layers list');
                }
            });
            
            layersList.addEventListener('drop', (e) => {
                // Only handle if not over a folder or layer item
                const isOverFolder = e.target.closest('.layer-folder');
                const isOverLayer = e.target.closest('.layer-item');
                
                if (!isOverFolder && !isOverLayer) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const draggedId = e.dataTransfer.getData('layerId') || draggedLayerId || window.draggedLayerId;
                    const draggedType = e.dataTransfer.getData('type');
                    
                    console.log('ðŸŽ¯ DROP on empty space - draggedId:', draggedId);
                    
                    if (draggedType === 'layer' && draggedId) {
                        const draggedLayer = layers.find(l => l.id === draggedId);
                        
                        if (draggedLayer && draggedLayer.groupId) {
                            console.log('ðŸ”“ Moving layer OUT of folder to root:', draggedId);
                            
                            // Remove from folder
                            const folder = layerGroups[draggedLayer.groupId];
                            if (folder) {
                                folder.layers = folder.layers.filter(id => id !== draggedId);
                            }
                            
                            // Make standalone
                            draggedLayer.groupId = null;
                            
                            rebuildLayersArray();
                            updateLayerZIndexes();
                            renderLayersPanel();
                            updateTimeline();
                            saveState();
                        }
                    }
                }
            });
            
            // Add a drop zone at the bottom for moving folders to the end (invisible, no dashed lines)
            const bottomDropZone = document.createElement('div');
            bottomDropZone.className = 'bottom-drop-zone';
            bottomDropZone.style.cssText = 'height: 40px; width: 100%; transition: all 0.2s;';
            
            bottomDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                bottomDropZone.style.background = 'rgba(198, 230, 251, 0.05)';
            });
            
            bottomDropZone.addEventListener('dragleave', () => {
                bottomDropZone.style.background = 'transparent';
            });
            
            bottomDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                bottomDropZone.style.background = 'transparent';
                
                const draggedGroupId = e.dataTransfer.getData('groupId');
                const draggedId = e.dataTransfer.getData('layerId') || draggedLayerId || window.draggedLayerId;
                const draggedType = e.dataTransfer.getData('type');
                
                console.log('ðŸŽ¯ BOTTOM DROP ZONE - draggedId:', draggedId, 'type:', draggedType);
                
                if (draggedType === 'folder' && draggedGroupId) {
                    // Move folder to the very end
                    const groupIds = Object.keys(layerGroups);
                    const draggedIndex = groupIds.indexOf(draggedGroupId);
                    
                    if (draggedIndex !== -1) {
                        // Remove from current position
                        groupIds.splice(draggedIndex, 1);
                        // Add to end
                        groupIds.push(draggedGroupId);
                        
                        // Rebuild layerGroups in new order
                        const newLayerGroups = {};
                        groupIds.forEach(id => {
                            newLayerGroups[id] = layerGroups[id];
                        });
                        layerGroups = newLayerGroups;
                        
                        rebuildLayersArray();
                        updateLayerZIndexes();
                        renderLayersPanel();
                        updateTimeline();
                    }
                } else if (draggedType === 'layer' && draggedId) {
                    // Move layer to the very end (can be from folder or standalone)
                    const draggedLayer = layers.find(l => l.id === draggedId);
                    console.log('ðŸŽ¯ Moving layer to root:', draggedLayer);
                    if (draggedLayer) {
                        // Remove from old folder if it was in one
                        if (draggedLayer.groupId && layerGroups[draggedLayer.groupId]) {
                            const oldGroup = layerGroups[draggedLayer.groupId];
                            const index = oldGroup.layers.indexOf(draggedId);
                            if (index > -1) {
                                oldGroup.layers.splice(index, 1);
                            }
                            // Delete empty groups
                            if (oldGroup.layers.length === 0) {
                                delete layerGroups[draggedLayer.groupId];
                                collapsedFolders.delete(draggedLayer.groupId);
                            }
                        }
                        // Remove from layers array
                        const draggedIndex = layers.indexOf(draggedLayer);
                        if (draggedIndex !== -1) {
                            layers.splice(draggedIndex, 1);
                        }
                        // Set groupId to null (make it standalone)
                        draggedLayer.groupId = null;
                        // Add to end
                        layers.push(draggedLayer);
                        
                        rebuildLayersArray();
                        updateLayerZIndexes();
                        renderLayersPanel();
                        updateTimeline();
                        saveState();
                    }
                }
            });
            
            layersList.appendChild(bottomDropZone);
            
            // Add drop zone handlers to layersList container itself
            // This allows dropping layers on empty space to move them to root level
            layersList.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            
            layersList.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const draggedId = e.dataTransfer.getData('layerId') || draggedLayerId || window.draggedLayerId;
                const draggedType = e.dataTransfer.getData('type');
                
                if (draggedType === 'layer' && draggedId) {
                    // Move layer to root level (remove from any folder)
                    const layer = layers.find(l => l.id === draggedId);
                    if (layer && layer.groupId) {
                        // Remove from folder
                        const folder = layerGroups[layer.groupId];
                        if (folder) {
                            folder.layers = folder.layers.filter(id => id !== draggedId);
                        }
                        layer.groupId = null;
                        
                        console.log(`âœ… Moved layer ${draggedId} to root level`);
                        rebuildLayersArray();
                        updateLayerZIndexes();
                        renderLayersPanel();
                        updateTimeline();
                        saveState();
                    }
                }
            });
            
            // Update selection - nested layers should NOT show selected when folder is selected
            // First, remove selected class from all items
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelectorAll('.layer-folder').forEach(folder => {
                folder.classList.remove('selected');
            });
            
            // Then, add selected class only to actually selected items
            document.querySelectorAll('.layer-item').forEach(item => {
                const layerId = item.dataset.layerId;
                // Only show selected if the layer itself is selected, NOT if its folder is selected
                const isSelected = (selectedLayerId === layerId || selectedLayerIds.has(layerId)) && !selectedFolderId;
                if (isSelected) {
                    item.classList.add('selected');
                }
            });
            
            // Update folder selection
            document.querySelectorAll('.layer-folder').forEach(folder => {
                const groupId = folder.dataset.groupId;
                const isSelected = groupId === selectedFolderId || selectedFolderIds.has(groupId);
                if (isSelected) {
                    folder.classList.add('selected');
                }
            });
            
            // Update action buttons
            updateActionButtons();
        }
        
        function createLayerItem(layer, isNested = false) {
            const layerItem = document.createElement('div');
            // Don't add 'selected' class here - it will be set by renderLayersPanel based on actual selection state
            layerItem.className = `layer-item ${isNested ? 'nested' : ''}`;
            layerItem.dataset.layerId = layer.id;
            // Allow dragging for all layers (including nested ones) regardless of selection state
            layerItem.draggable = true;
            // Check if SVG can be split
            // Disable split in side-by-side mode
            const canSplit = previewMode !== 'side-by-side' && layer.type === 'SVG' && layer.svgContent && (() => {
                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(layer.svgContent, 'image/svg+xml');
                    const svgElement = svgDoc.documentElement;
                    const directGroups = Array.from(svgElement.children).filter(child => child.tagName === 'g');
                    const directElements = Array.from(svgElement.children).filter(child => 
                        ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'text', 'image'].includes(child.tagName)
                    );
                    return [...directGroups, ...directElements].length > 1;
                } catch (e) {
                    return false;
                }
            })();
            
            layerItem.innerHTML = `
                <span class="visibility-toggle ${layer.visible ? '' : 'hidden'}" data-action="visibility" title="${layer.visible ? 'Hide layer' : 'Show layer'}">
                    ${layer.visible ? 
                        '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 12.0088C18.2007 12.0088 20.0013 13.8093 20.0013 16.01C20.0013 18.2107 18.2007 20.0113 16 20.0113C13.7993 20.0113 11.9987 18.2107 11.9987 16.01C11.9987 13.8093 13.7993 12.0088 16 12.0088ZM16 10.0081C12.679 10.0081 9.99812 12.689 9.99812 16.01C9.99812 19.331 12.679 22.0119 16 22.0119C19.321 22.0119 22.0019 19.331 22.0019 16.01C22.0019 12.689 19.321 10.0081 16 10.0081Z" fill="#050505"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.01563 16.01C6.43701 2.50579 25.543 2.50579 29.9644 16.01C25.543 29.5142 6.43701 29.5142 2.01563 16.01ZM31.925 16.5102C26.9634 32.015 5.03657 32.015 0.0750234 16.5102C-0.0250078 16.1701 -0.0250078 15.83 0.0750234 15.4898C5.03657 -0.0149975 26.9634 -0.0149975 31.925 15.4898C32.025 15.83 32.025 16.1701 31.925 16.5102Z" fill="#050505"/></svg>' :
                        '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.7818 14.45L19.9812 16.25C19.8612 18.27 18.2607 19.87 16.2401 19.99L14.4595 21.79C14.9397 21.93 15.4598 22.01 16 22.01C19.321 22.01 22.0019 19.33 22.0019 16.01C22.0019 15.47 21.9219 14.95 21.7818 14.45ZM16 10.01C12.679 10.01 9.99812 12.69 9.99812 16.01C9.99812 16.55 10.0781 17.07 10.2182 17.55L12.0188 15.75C12.1388 13.75 13.7393 12.15 15.7399 12.03L17.5405 10.21C17.0603 10.09 16.5402 10.01 16 10.01Z" fill="#050505"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0.0750234 15.51C-0.0250078 15.83 -0.0250078 16.19 0.0750234 16.51C0.995311 19.35 2.47577 21.67 4.31635 23.47L5.71679 22.05C4.11629 20.49 2.81588 18.47 2.01563 16.01C4.85652 7.31 13.8193 4.21 21.0016 6.75L22.5621 5.19C14.2194 1.73 3.37605 5.17 0.0750234 15.51ZM31.925 15.51C31.0047 12.67 29.5242 10.35 27.6837 8.55L26.2632 9.95C27.8637 11.51 29.1641 13.53 29.9844 16.01C27.1235 24.71 18.1607 27.81 10.9784 25.27L9.43795 26.83C17.7806 30.29 28.6239 26.85 31.925 16.51C32.025 16.19 32.025 15.83 31.925 15.51Z" fill="#050505"/><path d="M29.6843 3.71L26.1632 7.25L24.7227 8.67L20.8815 12.53L19.4411 13.97L13.9794 19.45L9.01782 24.41L7.53736 25.91L3.73617 29.71C3.5361 29.91 3.27602 30.01 3.03595 30.01C2.77587 30.01 2.51579 29.91 2.31572 29.71C1.9156 29.33 1.9156 28.69 2.31572 28.29L5.83682 24.77L7.25727 23.33L12.5589 18.03L18.0206 12.55L19.4611 11.11L22.9622 7.59L24.4626 6.11L28.2638 2.29C28.4639 2.09 28.724 1.99 28.964 1.99C29.2241 1.99 29.4842 2.09 29.6843 2.29C30.0844 2.67 30.0844 3.31 29.6843 3.71Z" fill="#050505"/></svg>'
                    }
                </span>
                <div class="layer-icon">IMG</div>
                <div class="layer-info">
                    <div class="layer-name" data-action="name" title="Double click to rename">${layer.name}</div>
                    <div class="layer-type">${layer.type}</div>
                    </div>
            `;
            
            // Visibility toggle - delegate to handle SVG clicks
            const visibilityToggle = layerItem.querySelector('.visibility-toggle');
            visibilityToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleLayerVisibility(layer.id);
            });
            
            // Double-click layer name to rename
            const layerName = layerItem.querySelector('[data-action="name"]');
            layerName.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                renameLayerInline(layer.id, layerName);
            });
            
            // Select layer (support multi-select with Command/Ctrl+click)
            layerItem.addEventListener('click', (e) => {
                const actionElement = e.target.closest('[data-action]');
                const action = actionElement ? actionElement.dataset.action : null;
                
                // Only handle name action (for renaming), ignore others
                if (action === 'name') {
                    // Name double-click handled separately
                    return;
                }
                
                // Regular click handling
                if (!action || action === 'visibility') {
                    const isCmdClick = e.metaKey || e.ctrlKey;
                    
                    if (isCmdClick) {
                        // Command+click: toggle multi-select
                        if (selectedLayerIds.has(layer.id)) {
                            selectedLayerIds.delete(layer.id);
                            layerItem.classList.remove('selected');
                            if (selectedLayerId === layer.id) {
                                selectedLayerId = selectedLayerIds.size > 0 ? Array.from(selectedLayerIds)[0] : null;
                            }
                        } else {
                            selectedLayerIds.add(layer.id);
                            layerItem.classList.add('selected');
                            selectedLayerId = layer.id;
                        }
                        
                        // Update canvas elements based on multi-select
                        document.querySelectorAll('.preview-element').forEach(el => {
                            const isSelected = selectedLayerIds.has(el.id);
                            el.classList.toggle('selected', isSelected);
                            // Apply shadow if layer has one set (regardless of selection)
                            const layer = layers.find(l => l.id === el.id);
                            if (layer && layer.shadow !== undefined && layer.shadow > 0) {
                                applyLayerShadow(layer.id, layer.shadow);
                            } else {
                                el.style.filter = 'none';
                            }
                        });
                        
                        // Deselect folder if one is selected
                        if (selectedFolderId) {
                            selectedFolderId = null;
                            selectedFolderIds.clear();
                            document.querySelectorAll('.layer-folder').forEach(folder => {
                                folder.classList.remove('selected');
                            });
                        }
                    } else {
                        // Regular click: single select ONLY this layer
                        selectedLayerIds.clear();
                        selectedFolderIds.clear();
                        selectedLayerId = layer.id;
                        
                        // Deselect folder if one is selected
                        if (selectedFolderId) {
                            selectedFolderId = null;
                            document.querySelectorAll('.layer-folder').forEach(folder => {
                                folder.classList.remove('selected');
                            });
                            document.getElementById('propertiesContent').innerHTML = '';
                        }
                        selectLayer(layer.id);
                    }
                    
                    updateActionButtons();
                }
            });
            
            // Drag and drop for reordering
            layerItem.addEventListener('dragstart', (e) => {
                console.log('DRAG START - Layer:', layer.id, 'isNested:', isNested, 'groupId:', layer.groupId);
                e.stopPropagation(); // Prevent folder dragstart from firing
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('layerId', layer.id);
                e.dataTransfer.setData('type', 'layer');
                window.draggedLayerId = layer.id; // Store globally for folder drop handler
                window.draggedLayerType = 'layer'; // Store type globally
                layerItem.classList.add('dragging');
            });
            
            layerItem.addEventListener('dragend', (e) => {
                layerItem.classList.remove('dragging');
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            });
            
            layerItem.addEventListener('dragover', (e) => {
                if (isNested) {
                    console.log('DRAG OVER nested layer:', layer.id);
                }
                e.preventDefault();
                e.stopPropagation(); // Prevent folder header from handling this
                e.dataTransfer.dropEffect = 'move';
                layerItem.classList.add('drag-over');
            });
            
            layerItem.addEventListener('dragleave', (e) => {
                layerItem.classList.remove('drag-over');
            });
            
            layerItem.addEventListener('drop', (e) => {
                console.log('Layer drop handler called for:', layer.id, 'isNested:', isNested);
                e.preventDefault();
                e.stopPropagation();
                layerItem.classList.remove('drag-over');
                
                const draggedId = e.dataTransfer.getData('layerId') || window.draggedLayerId;
                // Check both dataTransfer and global variable (dataTransfer can be overwritten by folder dragstart)
                let draggedType = e.dataTransfer.getData('type') || window.draggedLayerType || 'layer';
                
                // If we have a draggedId but type is 'folder', it's likely a nested layer being dragged
                // Check if the draggedId exists in layers array to confirm it's a layer
                if (draggedType === 'folder' && draggedId) {
                    const draggedLayer = layers.find(l => l.id === draggedId);
                    if (draggedLayer) {
                        draggedType = 'layer'; // It's actually a layer, not a folder
                    }
                }
                
                console.log('Dragged ID:', draggedId, 'Type:', draggedType, 'Target layer:', layer.id);
                
                if (draggedType === 'layer' && draggedId && draggedId !== layer.id) {
                    const draggedLayer = layers.find(l => l.id === draggedId);
                    const targetLayer = layer;
                    
                    console.log('Dragged layer:', draggedLayer?.groupId, 'Target layer:', targetLayer?.groupId);
                    
                    if (!draggedLayer || !targetLayer) {
                        console.log('Missing layer data');
                        return;
                    }
                    
                    // If dragged layer is in a folder and target is standalone, move out of folder
                    if (draggedLayer.groupId && !targetLayer.groupId) {
                        // Remove from folder
                        const oldGroup = layerGroups[draggedLayer.groupId];
                        if (oldGroup) {
                            const index = oldGroup.layers.indexOf(draggedId);
                            if (index > -1) {
                                oldGroup.layers.splice(index, 1);
                            }
                            // Delete empty groups
                            if (oldGroup.layers.length === 0) {
                                delete layerGroups[draggedLayer.groupId];
                                collapsedFolders.delete(draggedLayer.groupId);
                            }
                        }
                        // Make standalone
                        draggedLayer.groupId = null;
                        rebuildLayersArray();
                        updateLayerZIndexes();
                        renderLayersPanel();
                        updateTimeline();
                        saveState();
                    } else if (draggedLayer.groupId && targetLayer.groupId && draggedLayer.groupId === targetLayer.groupId) {
                        // Both are in the same folder - reorder within folder
                        console.log('Reordering within same folder:', draggedLayer.groupId);
                        const group = layerGroups[draggedLayer.groupId];
                        if (!group) {
                            console.error('Group not found:', draggedLayer.groupId);
                            return;
                        }
                        
                        const draggedIndex = group.layers.indexOf(draggedId);
                        const targetIndex = group.layers.indexOf(targetLayer.id);
                        
                        console.log('Dragged index:', draggedIndex, 'Target index:', targetIndex);
                        
                        if (draggedIndex > -1 && targetIndex > -1 && draggedIndex !== targetIndex) {
                            // Remove from current position
                            group.layers.splice(draggedIndex, 1);
                            // Calculate new target index (adjust if we removed before target)
                            const newTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;
                            // Insert at target position
                            group.layers.splice(newTargetIndex, 0, draggedId);
                            
                            console.log('New order:', group.layers);
                            
                            rebuildLayersArray();
                            updateLayerZIndexes();
                            renderLayersPanel();
                            updateTimeline();
                            saveState();
                        } else {
                            console.log('Skipping reorder - invalid indices or same position');
                        }
                    } else {
                        // Regular reordering (handles between folders, standalone to folder, etc.)
                        reorderLayer(draggedId, layer.id);
                        saveState();
                    }
                }
            });
            
            return layerItem;
        }
        
        function toggleFolder(groupId) {
            if (collapsedFolders.has(groupId)) {
                collapsedFolders.delete(groupId);
            } else {
                collapsedFolders.add(groupId);
            }
            renderLayersPanel();
        }
        
        function toggleLayerVisibility(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (!layer) {
                console.warn('âš ï¸ toggleLayerVisibility: Layer not found:', layerId);
                return;
            }
            
            // Toggle visibility state
            layer.visible = !layer.visible;
            
            // Check if layer is in a folder
            const groupId = layer.groupId;
            const group = groupId ? layerGroups[groupId] : null;
            
            // Update canvas element visibility
            // Layer is visible only if it's visible AND (not in a folder OR folder is visible)
            const element = document.getElementById(layerId);
            if (element) {
                const shouldBeVisible = layer.visible && (!group || group.visible);
                
                if (shouldBeVisible) {
                    // Show layer - restore to visible
                    element.style.display = 'block';
                    element.style.visibility = 'visible';
                    element.style.opacity = '1';
                    console.log('ðŸ‘ï¸ Showing layer:', layerId);
                } else {
                    // Hide layer
                    element.style.display = 'none';
                    console.log('ðŸ™ˆ Hiding layer:', layerId);
                }
            } else {
                console.warn('âš ï¸ toggleLayerVisibility: Element not found:', layerId);
            }
            
            // Update UI
            renderLayersPanel();
            updateTimeline();
            
            // Re-position layers in side-by-side mode when visibility changes
            if (previewMode === 'side-by-side') {
                setTimeout(() => {
                    renderComposition();
                    setTimeout(() => {
                        const visibleLayers = layers.filter(l => {
                            const layerGroup = l.groupId ? layerGroups[l.groupId] : null;
                            return l.visible !== false && (!layerGroup || layerGroup.visible);
                        });
                        const layerCount = Math.min(visibleLayers.length, 6);
                        positionLayersInSquares(visibleLayers.slice(0, layerCount));
                    }, 50);
                }, 50);
            }
        }
        
        function toggleFolderVisibility(groupId) {
            const group = layerGroups[groupId];
            if (group) {
                group.visible = !group.visible;
                
                // Update all layers in this folder
                group.layers.forEach(layerId => {
                    const layer = layers.find(l => l.id === layerId);
                    if (layer) {
                        // If folder is hidden, hide all layers
                        // If folder is visible, layers keep their own visibility state
                        // (layers that were explicitly hidden stay hidden)
                        
                        // Update canvas element visibility
                        // Layer is visible only if both folder and layer are visible
                        const element = document.querySelector(`[data-layer-id="${layerId}"]`);
                        if (element) {
                            element.style.display = (group.visible && layer.visible) ? 'block' : 'none';
                        }
                    }
                });
                
                renderLayersPanel();
                updateTimeline();
            }
        }
        
        function renameLayerInline(layerId, nameElement) {
            const layer = layers.find(l => l.id === layerId);
            if (!layer) return;
            
            const currentName = layer.name;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'layer-name-input';
            
            nameElement.replaceWith(input);
            input.focus();
            input.select();
            
            const finishRename = () => {
                const newName = input.value.trim() || currentName;
                layer.name = newName;
                renderLayersPanel();
                updateTimeline();
            };
            
            input.addEventListener('blur', finishRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finishRename();
                if (e.key === 'Escape') {
                    layer.name = currentName;
                    renderLayersPanel();
                }
            });
        }
        
        function renameFolderInline(groupId, nameElement) {
            const group = layerGroups[groupId];
            if (!group) return;
            
            const currentName = group.name;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'folder-name-input';
            
            nameElement.replaceWith(input);
            input.focus();
            input.select();
            
            const finishRename = () => {
                const newName = input.value.trim() || currentName;
                group.name = newName;
                renderLayersPanel();
                updateTimeline();
            };
            
            input.addEventListener('blur', finishRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finishRename();
                if (e.key === 'Escape') {
                    group.name = currentName;
                    renderLayersPanel();
                }
            });
        }
        
        function reorderLayer(draggedLayerId, targetLayerId) {
            const draggedLayer = layers.find(l => l.id === draggedLayerId);
            const targetLayer = layers.find(l => l.id === targetLayerId);
            
            if (!draggedLayer || !targetLayer) return;
            
            // Both are standalone layers (not in folders)
            if (draggedLayer.groupId === null && targetLayer.groupId === null) {
                const draggedIndex = layers.indexOf(draggedLayer);
                const targetIndex = layers.indexOf(targetLayer);
                
                // Remove dragged layer
                layers.splice(draggedIndex, 1);
                
                // Insert at target position
                const newTargetIndex = layers.indexOf(targetLayer);
                layers.splice(newTargetIndex, 0, draggedLayer);
            }
            // Same folder reordering
            else if (draggedLayer.groupId === targetLayer.groupId && draggedLayer.groupId !== null) {
                const group = layerGroups[draggedLayer.groupId];
                const draggedIndex = group.layers.indexOf(draggedLayerId);
                const targetIndex = group.layers.indexOf(targetLayerId);
                
                if (draggedIndex > -1) {
                    group.layers.splice(draggedIndex, 1);
                }
                
                const newTargetIndex = group.layers.indexOf(targetLayerId);
                group.layers.splice(newTargetIndex, 0, draggedLayerId);
            }
            // Move between different folders or from standalone to folder
            else {
                // Moving from standalone to folder
                if (draggedLayer.groupId === null && targetLayer.groupId !== null) {
                    const targetGroup = layerGroups[targetLayer.groupId];
                    const targetIndex = targetGroup.layers.indexOf(targetLayerId);
                    if (targetIndex > -1) {
                        draggedLayer.groupId = targetLayer.groupId;
                        if (!targetGroup.layers.includes(draggedLayerId)) {
                            targetGroup.layers.splice(targetIndex, 0, draggedLayerId);
                        }
                    }
                }
                // Moving from folder to standalone
                else if (draggedLayer.groupId !== null && targetLayer.groupId === null) {
                    const oldGroup = layerGroups[draggedLayer.groupId];
                    if (oldGroup) {
                        const index = oldGroup.layers.indexOf(draggedLayerId);
                        if (index > -1) {
                            oldGroup.layers.splice(index, 1);
                        }
                    }
                    draggedLayer.groupId = null;
                    // Reorder in main layers array
                    const draggedIndex = layers.indexOf(draggedLayer);
                    const targetIndex = layers.indexOf(targetLayer);
                    if (draggedIndex > -1 && targetIndex > -1) {
                        layers.splice(draggedIndex, 1);
                        const newTargetIndex = layers.indexOf(targetLayer);
                        layers.splice(newTargetIndex, 0, draggedLayer);
                    }
                }
                // Moving between different folders
                else if (draggedLayer.groupId !== null && targetLayer.groupId !== null && draggedLayer.groupId !== targetLayer.groupId) {
                    const oldGroup = layerGroups[draggedLayer.groupId];
                    const targetGroup = layerGroups[targetLayer.groupId];
                    if (oldGroup && targetGroup) {
                        // Remove from old folder
                        const oldIndex = oldGroup.layers.indexOf(draggedLayerId);
                        if (oldIndex > -1) {
                            oldGroup.layers.splice(oldIndex, 1);
                        }
                        // Add to new folder
                        draggedLayer.groupId = targetLayer.groupId;
                        const targetIndex = targetGroup.layers.indexOf(targetLayerId);
                        if (targetIndex > -1 && !targetGroup.layers.includes(draggedLayerId)) {
                            targetGroup.layers.splice(targetIndex, 0, draggedLayerId);
                        }
                    }
                }
            }
            
            // Rebuild main layers array in correct order (based on folder order and layer order within folders)
            rebuildLayersArray();
            
            // Update z-indexes to match new order
            updateLayerZIndexes();
            
            renderLayersPanel();
            updateTimeline();
        }
        
        function reorderFolder(draggedGroupId, targetGroupId) {
            // Get all group IDs in current order
            const groupIds = Object.keys(layerGroups);
            const draggedIndex = groupIds.indexOf(draggedGroupId);
            const targetIndex = groupIds.indexOf(targetGroupId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // Remove dragged group
            groupIds.splice(draggedIndex, 1);
            
            // Insert at new position
            const newTargetIndex = groupIds.indexOf(targetGroupId);
            groupIds.splice(newTargetIndex, 0, draggedGroupId);
            
            // Rebuild layerGroups in new order
            const newLayerGroups = {};
            groupIds.forEach(id => {
                newLayerGroups[id] = layerGroups[id];
            });
            layerGroups = newLayerGroups;
            
            // Rebuild main layers array and update z-indexes
            rebuildLayersArray();
            updateLayerZIndexes();
            
            renderLayersPanel();
            updateTimeline();
        }
        
        function deleteFolder(groupId) {
            const group = layerGroups[groupId];
            if (!group) return;
            
            // Confirmation dialog
            if (!confirm(`Are you sure you want to delete folder "${group.name}" and all its contents (${group.layers.length} layer${group.layers.length > 1 ? 's' : ''})?`)) {
                return;
            }
            
            // Delete all layers in the folder from canvas
            const layerIds = [...group.layers];
            layerIds.forEach(layerId => {
                const layer = layers.find(l => l.id === layerId);
                if (layer) {
                    // Remove from canvas
                    const element = document.querySelector(`[data-layer-id="${layerId}"]`);
                    if (element) {
                        element.remove();
                    }
                    
                    // Remove from layers array
                    const index = layers.indexOf(layer);
                    if (index > -1) {
                        layers.splice(index, 1);
                    }
                }
            });
            
            // Delete the folder itself
            delete layerGroups[groupId];
            collapsedFolders.delete(groupId);
            
            // Deselect if needed
            if (selectedLayerId && layerIds.includes(selectedLayerId)) {
                selectedLayerId = null;
                document.getElementById('propertiesContent').innerHTML = '';
            }
            
            renderLayersPanel();
            updateTimeline();
            
            // Check if canvas is empty and show empty state
            if (layers.length === 0) {
                const container = document.getElementById('canvasContainer');
                container.innerHTML = '<div class="empty-state"><div class="empty-state-greeting"><span>Hello Qontoer</span><span class="empty-state-emoji">ðŸ‘‹ðŸ¼</span></div><div class="empty-state-dropzone" id="emptyStateDropzone" onclick="document.getElementById(\'fileInput\').click();"><div class="dropzone-text">Add your images or svg</div><div class="dropzone-subtext">Drag and drop here, or click to browse</div></div></div>';
                setupDropzoneHandlers();
            }
        }
        
        function createNewFolder() {
            try {
                if (typeof saveState === 'function') {
                    saveState(); // Save state before change
                }
                
                // Generate unique folder ID
                const folderId = 'folder-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                
                // Collect selected items (layers and folders)
                const selectedLayers = Array.from(selectedLayerIds || []).map(id => layers.find(l => l.id === id)).filter(Boolean);
                const selectedFolders = Array.from(selectedFolderIds || []).map(id => layerGroups[id]).filter(Boolean);
                
                // Count total selected: if single selection exists, don't count it unless it's also in multi-select
                let totalSelected = selectedLayers.length + selectedFolders.length;
                
                // If 2+ items selected, move them into the folder; otherwise create empty folder
                const layersToMove = totalSelected >= 2 ? [...selectedLayers] : [];
                
                // Store existing layerGroups before modification
                const existingGroups = { ...layerGroups };
                
                // Create new folder
                layerGroups[folderId] = {
                    id: folderId, // Add id property for consistency with split folders
                    name: 'New Folder',
                    layers: layersToMove.map(l => l.id),
                    visible: true,
                    category: '',
                    pattern: '',
                    duration: 300,
                    easing: 'ease-in-out',
                    delay: 0
                };
                
                // Move selected layers into the folder
                layersToMove.forEach(layer => {
                    layer.groupId = folderId;
                });
                
                // Move selected folders' layers into the new folder
                selectedFolders.forEach(folder => {
                    folder.layers.forEach(layerId => {
                        const layer = layers.find(l => l.id === layerId);
                        if (layer) {
                            layer.groupId = folderId;
                            if (!layerGroups[folderId].layers.includes(layerId)) {
                                layerGroups[folderId].layers.push(layerId);
                            }
                        }
                    });
                    // Delete the old folder
                    delete layerGroups[folder.id];
                    if (collapsedFolders) {
                        collapsedFolders.delete(folder.id);
                    }
                });
                
                // Rebuild layerGroups with new folder first (so it appears at top)
                const newLayerGroups = {};
                newLayerGroups[folderId] = layerGroups[folderId]; // Add new folder first
                Object.keys(existingGroups).forEach(id => {
                    if (id !== folderId && layerGroups[id]) {
                        newLayerGroups[id] = layerGroups[id];
                    }
                });
                layerGroups = newLayerGroups;
                
                // Clear selection
                if (selectedLayerIds) selectedLayerIds.clear();
                if (selectedFolderIds) selectedFolderIds.clear();
                selectedLayerId = null;
                selectedFolderId = null;
                
                rebuildLayersArray();
                updateLayerZIndexes();
                renderLayersPanel();
                updateTimeline();
                
                // Select the new folder
                if (typeof selectFolder === 'function') {
                    selectFolder(folderId);
                }
                
                // Focus on folder name for renaming
                setTimeout(() => {
                    const folderNameEl = document.querySelector(`[data-group-id="${folderId}"] .folder-name`);
                    if (folderNameEl) {
                        folderNameEl.dispatchEvent(new MouseEvent('dblclick', { bubbles: true }));
                    }
                }, 100);
                
                if (typeof saveState === 'function') {
                    saveState(); // Save state after change
                }
            } catch (error) {
                console.error('Error creating new folder:', error);
                alert('Error creating folder: ' + error.message);
            }
        }
        
        function toggleSplitLayer() {
            // Handle split folder unsplit
            if (selectedFolderId && splitStates[selectedFolderId]) {
                unsplitLayers(selectedFolderId);
                updateActionButtons();
                return;
            }
            
            // Handle layer split/unsplit
            // Get the selected layer - check both selectedLayerId and selectedLayerIds
            let layerId = selectedLayerId;
            if (!layerId && selectedLayerIds.size === 1) {
                layerId = Array.from(selectedLayerIds)[0];
            }
            
            if (!layerId) return;
            
            const layer = layers.find(l => l.id === layerId);
            if (!layer || layer.type !== 'SVG' || !layer.svgContent) return;
            
            // Check if this layer is already split
            const existingSplit = Object.values(splitStates).find(state => 
                state.originalLayer.id === layer.id
            );
            
            if (existingSplit) {
                // Unsplit: find the folder ID and unsplit
                const folderId = Object.keys(splitStates).find(k => splitStates[k] === existingSplit);
                if (folderId) {
                    unsplitLayers(folderId);
                    updateActionButtons();
                }
            } else {
                // Split: check if SVG can be split
                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(layer.svgContent, 'image/svg+xml');
                    const svgElement = svgDoc.documentElement;
                    const directGroups = Array.from(svgElement.children).filter(child => child.tagName === 'g');
                    const directElements = Array.from(svgElement.children).filter(child => 
                        ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'text', 'image'].includes(child.tagName)
                    );
                    const splittableElements = [...directGroups, ...directElements];
                    if (splittableElements.length > 1) {
                        splitExistingLayer(layer, svgElement, splittableElements);
                        updateActionButtons();
                    }
                } catch (e) {
                    console.error('Error splitting SVG:', e);
                }
            }
        }
        
        function updateActionButtons() {
            const splitBtn = document.getElementById('splitLayerBtn');
            const deleteBtn = document.getElementById('deleteLayerBtn');
            
            if (!splitBtn || !deleteBtn) return;
            
            // Get the selected layer - check both selectedLayerId and selectedLayerIds
            let actualSelectedLayer = selectedLayerId ? layers.find(l => l.id === selectedLayerId) : null;
            if (!actualSelectedLayer && selectedLayerIds.size === 1) {
                const layerId = Array.from(selectedLayerIds)[0];
                actualSelectedLayer = layers.find(l => l.id === layerId);
            }
            
            const hasSelectedFolder = selectedFolderId !== null;
            const hasSelectedLayer = actualSelectedLayer !== null;
            const hasMultiSelect = selectedLayerIds.size > 0 || selectedFolderIds.size > 0;
            
            // Delete button: enabled if layer or folder is selected
            if (hasSelectedLayer || hasSelectedFolder || hasMultiSelect) {
                deleteBtn.classList.add('enabled');
                deleteBtn.disabled = false;
            } else {
                deleteBtn.classList.remove('enabled');
                deleteBtn.disabled = true;
            }
            
            // Split button: enabled if a single layer is selected (can split) OR if a split folder is selected (can unsplit)
            const isSplitFolder = hasSelectedFolder && splitStates[selectedFolderId];
            
            // Check if exactly one layer is selected (either via selectedLayerId or selectedLayerIds with size 1)
            const isSingleLayerSelected = hasSelectedLayer && !hasSelectedFolder && 
                (selectedLayerIds.size === 0 || (selectedLayerIds.size === 1 && (!selectedLayerId || selectedLayerIds.has(selectedLayerId)))) && 
                selectedFolderIds.size === 0 && 
                previewMode !== 'side-by-side';
            
            if (isSingleLayerSelected && actualSelectedLayer) {
                // Check if layer can be split (SVG with multiple elements)
                const canSplit = actualSelectedLayer.type === 'SVG' && actualSelectedLayer.svgContent && (() => {
                    try {
                        const parser = new DOMParser();
                        const svgDoc = parser.parseFromString(actualSelectedLayer.svgContent, 'image/svg+xml');
                        const svgElement = svgDoc.documentElement;
                        const directGroups = Array.from(svgElement.children).filter(child => child.tagName === 'g');
                        const directElements = Array.from(svgElement.children).filter(child => 
                            ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'text', 'image'].includes(child.tagName)
                        );
                        return [...directGroups, ...directElements].length > 1;
                    } catch (e) {
                        return false;
                    }
                })();
                
                // Check if already split
                const existingSplit = Object.values(splitStates).find(state => 
                    state.originalLayer.id === actualSelectedLayer.id
                );
                
                if (canSplit || existingSplit) {
                    splitBtn.classList.add('enabled');
                    splitBtn.disabled = false;
                    // Show selected state if split
                    if (existingSplit) {
                        splitBtn.classList.add('selected');
                        splitBtn.title = 'Unsplit: Merge layers back into one';
                    } else {
                        splitBtn.classList.remove('selected');
                        splitBtn.title = 'Split: Split SVG into separate layers';
                    }
                } else {
                    splitBtn.classList.remove('enabled', 'selected');
                    splitBtn.disabled = true;
                    splitBtn.title = 'Split layer (only available for SVG layers with multiple elements)';
                }
            } else if (isSplitFolder && previewMode !== 'side-by-side') {
                // Split folder selected - enable unsplit
                splitBtn.classList.add('enabled', 'selected');
                splitBtn.disabled = false;
                splitBtn.title = 'Unsplit: Merge layers back into one';
            } else if (previewMode === 'side-by-side') {
                splitBtn.classList.remove('enabled', 'selected');
                splitBtn.disabled = true;
                splitBtn.title = 'You can\'t split a layer when you\'re on side-by-side mode';
            } else {
                splitBtn.classList.remove('enabled', 'selected');
                splitBtn.disabled = true;
                splitBtn.title = 'Split layer (select a layer first)';
            }
        }
        
        function selectLayer(layerId) {
            const selectedLayer = layers.find(l => l.id === layerId);
            if (!selectedLayer) {
                console.warn('âš ï¸ selectLayer: Layer not found:', layerId);
                return;
            }
            
            // Log position before selection to detect unwanted changes
            const element = document.getElementById(layerId);
            let beforePos = null;
            if (element) {
                beforePos = {
                    left: element.style.left,
                    top: element.style.top,
                    transform: element.style.transform,
                    storedPos: { ...selectedLayer.position },
                    isCompRelative: selectedLayer.positionRelativeToComposition
                };
                console.log('ðŸ“ selectLayer BEFORE:', layerId, beforePos);
            }
            
            // Don't re-render or reposition when selecting
            if (!element) {
                console.warn('âš ï¸ selectLayer: Element not found, skipping selection');
                return;
            }
            
            selectedLayerId = layerId;
            
            // Update panel
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.layerId === layerId);
            });
            
            // Update canvas - DON'T move or center the layer, just update selection
            document.querySelectorAll('.preview-element').forEach(el => {
                const isSelected = el.id === layerId;
                
                // Preserve scale and transform before toggling selection
                const currentWidth = el.style.width;
                const currentHeight = el.style.height;
                const currentTransform = el.style.transform;
                const currentScale = selectedLayer.scale || 100;
                
                el.classList.toggle('selected', isSelected);
                
                // Restore scale and transform after selection (in case CSS or other code modified it)
                if (isSelected) {
                    // Ensure selected element is visible (for debugging)
                    if (el.style.display === 'none') {
                        console.warn('Selected element was hidden, making visible:', el.id);
                        selectedLayer.visible = true;
                        el.style.display = 'block';
                    }
                    
                    // In side-by-side mode, preserve dimensions set by positionLayersInSquares()
                    // Don't call applyLayerScale() as it will recalculate and potentially resize
                    if (previewMode === 'side-by-side') {
                        // Just restore the dimensions that were already set
                        if (currentWidth && currentHeight) {
                            el.style.width = currentWidth;
                            el.style.height = currentHeight;
                        }
                        if (currentTransform) {
                            el.style.transform = currentTransform;
                        }
                        console.log('âœ… Side-by-side mode: Preserved dimensions without recalculating scale');
                    } else {
                        // In stacked mode, preserve and reapply scale normally
                        if (currentWidth && currentHeight) {
                            el.style.width = currentWidth;
                            el.style.height = currentHeight;
                        }
                        if (currentTransform) {
                            el.style.transform = currentTransform;
                        }
                        
                        // Ensure scale is applied (only in stacked mode)
                        if (currentScale !== 100) {
                            applyLayerScale(layerId, currentScale);
                        }
                    }
                }
                // DO NOT move or center the element - keep it in its current position
            });
            
            // Log position after selection to detect unwanted changes
            if (element && beforePos) {
                const afterPos = {
                    left: element.style.left,
                    top: element.style.top,
                    transform: element.style.transform
                };
                if (beforePos.left !== afterPos.left || beforePos.top !== afterPos.top) {
                    console.error('âŒ selectLayer MOVED LAYER!', layerId, { before: beforePos, after: afterPos });
                } else {
                    console.log('âœ… selectLayer: Position unchanged');
                }
            }
            
            // Update timeline
            document.querySelectorAll('.animation-bar').forEach(bar => {
                bar.classList.toggle('selected', bar.dataset.layerId === layerId);
            });
            
            // Update timeline label highlight
            document.querySelectorAll('.timeline-track-label').forEach(l => {
                l.classList.toggle('selected', l.dataset.layerId === layerId);
            });
            
            // Show/hide AI suggestion button based on selected layer
            const suggestionBtn = document.getElementById('aiSuggestionBtn');
            if (suggestionBtn) {
                if (selectedLayer && selectedLayer.aiSuggestion) {
                    suggestionBtn.style.display = 'flex';
                    const patternSpan = suggestionBtn.querySelector('.ai-suggestion-pattern');
                    if (patternSpan) {
                        patternSpan.textContent = selectedLayer.aiSuggestion.pattern;
                    }
                } else {
                    suggestionBtn.style.display = 'none';
                }
            }
            
            // Show layer properties panel
            const layerPropsPanel = document.getElementById('layerPropertiesPanel');
            if (layerPropsPanel) {
                if (selectedLayer) {
                    layerPropsPanel.style.display = 'block';
                    // Update all scale inputs (there might be multiple - one in properties panel, one in canvas popup)
                    const scaleInputs = document.querySelectorAll('#layerScaleInput');
                    scaleInputs.forEach(scaleInput => {
                        scaleInput.value = selectedLayer.scale || 100;
                        // Update scale input handler
                        scaleInput.onchange = (e) => {
                            const scaleValue = Math.max(10, Math.min(500, parseInt(e.target.value) || 100));
                            selectedLayer.scale = scaleValue;
                            // Update all inputs to keep them in sync
                            const allScaleInputs = document.querySelectorAll('#layerScaleInput');
                            allScaleInputs.forEach(input => {
                                input.value = scaleValue;
                            });
                            applyLayerScale(selectedLayer.id, scaleValue);
                        };
                    });
                    const opacityInput = document.getElementById('layerOpacityInput');
                    if (opacityInput) {
                        opacityInput.value = selectedLayer.opacity !== undefined ? selectedLayer.opacity : 100;
                        // Update opacity input handler
                        opacityInput.onchange = (e) => {
                            const opacityValue = Math.max(0, Math.min(100, parseInt(e.target.value) || 100));
                            selectedLayer.opacity = opacityValue;
                            applyLayerOpacity(selectedLayer.id, opacityValue);
                        };
                    }
                }
            }
            
            // Render properties
            renderPropertiesPanel();
            
            // Apply shadows to all layers that have shadow set (regardless of selection)
            applyAllLayerShadows();
            
            // Update action buttons
            updateActionButtons();
        }
        
        function selectFolder(folderId, skipAnimationStates = false) {
            selectedFolderId = folderId;
            selectedLayerId = null;
            
            const group = layerGroups[folderId];
            if (!group) return;
            
            // Update folder selection
            document.querySelectorAll('.layer-folder').forEach(folder => {
                folder.classList.toggle('selected', folder.dataset.groupId === folderId);
            });
            
            // Select all layers in the folder visually
            group.layers.forEach(layerId => {
                const layerItem = document.querySelector(`[data-layer-id="${layerId}"]`);
                if (layerItem) {
                    layerItem.classList.add('selected');
                }
                const canvasEl = document.getElementById(layerId);
                if (canvasEl) {
                    canvasEl.classList.add('selected');
                }
            });
            
            // Remove selection from layers not in this folder
            document.querySelectorAll('.layer-item').forEach(item => {
                if (!group.layers.includes(item.dataset.layerId)) {
                    item.classList.remove('selected');
                }
            });
            
            document.querySelectorAll('.preview-element').forEach(el => {
                if (!group.layers.includes(el.id)) {
                    el.classList.remove('selected');
                }
            });
            
            // Update timeline bars
            document.querySelectorAll('.animation-bar').forEach(bar => {
                bar.classList.remove('selected');
            });
            
            // Show layer properties panel
            const layerPropsPanel = document.getElementById('layerPropertiesPanel');
            if (layerPropsPanel) {
                const group = layerGroups[folderId];
                if (group && group.layers.length > 0) {
                    layerPropsPanel.style.display = 'block';
                    const scaleInput = document.getElementById('layerScaleInput');
                    if (scaleInput) {
                        scaleInput.value = group.scale || 100;
                        // Update scale input handler for folder
                        scaleInput.onchange = (e) => {
                            const scaleValue = Math.max(10, Math.min(500, parseInt(e.target.value) || 100));
                            group.scale = scaleValue;
                            // Apply scale to all layers in folder
                            group.layers.forEach(layerId => {
                                const layer = layers.find(l => l.id === layerId);
                                if (layer) {
                                    layer.scale = scaleValue;
                                    applyLayerScale(layer.id, scaleValue);
                                }
                            });
                        };
                    }
                }
            }
            
            // Render folder properties (skip animation states if flag is set)
            if (!skipAnimationStates) {
                renderFolderProperties(folderId);
            } else {
                // Just show empty properties panel
                document.getElementById('propertiesContent').innerHTML = '';
            }
            
            // Apply shadows to all layers that have shadow set (regardless of selection)
            applyAllLayerShadows();
            
            // Update action buttons
            updateActionButtons();
        }
        
        function deselectAll() {
            selectedLayerId = null;
            selectedFolderId = null;
            selectedLayerIds.clear();
            selectedFolderIds.clear();
            
            // Remove selection from all layers
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Remove selection from canvas elements
            document.querySelectorAll('.preview-element').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Remove selection from timeline bars
            document.querySelectorAll('.animation-bar').forEach(bar => {
                bar.classList.remove('selected');
            });
            
            // Clear properties panel (but keep panel visible)
            document.getElementById('propertiesContent').innerHTML = '';
            document.getElementById('suggestionBanner').innerHTML = '';
            
            // Shadows persist regardless of selection - no need to remove them
            
            // Update action buttons
            updateActionButtons();
        }
        
        function deleteLayer(layerId) {
            // Find the layer's group
            const layer = layers.find(l => l.id === layerId);
            const groupId = layer ? layer.groupId : null;
            
            // Remove from layers array
            layers = layers.filter(l => l.id !== layerId);
            
            // Remove from group
            if (groupId && layerGroups[groupId]) {
                layerGroups[groupId].layers = layerGroups[groupId].layers.filter(id => id !== layerId);
                
                // Delete empty groups
                if (layerGroups[groupId].layers.length === 0) {
                    delete layerGroups[groupId];
                    // Also remove from collapsedFolders if it was there
                    collapsedFolders.delete(groupId);
                    // Clear selection if this folder was selected
                    if (selectedFolderId === groupId) {
                        selectedFolderId = null;
                        selectedFolderIds.delete(groupId);
                    }
                }
            }
            
            // Remove from canvas
            const canvasElement = document.getElementById(layerId);
            if (canvasElement) {
                canvasElement.remove();
            }
            
            // If in side-by-side mode, update composition grid
            if (previewMode === 'side-by-side' && layers.length > 0) {
                console.log('ðŸ—‘ï¸ Layer deleted in side-by-side mode, updating grid');
                
                // Re-render composition with updated layer count
                renderComposition();
                
                // Reposition remaining layers in their squares
                setTimeout(() => {
                    const visibleLayers = layers.filter(l => l.visible !== false);
                    const layerCount = Math.min(visibleLayers.length, 4);
                    positionLayersInSquares(visibleLayers.slice(0, layerCount));
                    zoomToFit();
                }, 100);
            }
            
            // Handle empty state or reselection
            if (layers.length === 0) {
                const container = document.getElementById('canvasContainer');
                container.innerHTML = '<div class="empty-state"><div class="empty-state-greeting"><span>Hello Qontoer</span><span class="empty-state-emoji">ðŸ‘‹ðŸ¼</span></div><div class="empty-state-dropzone" id="emptyStateDropzone" onclick="document.getElementById(\'fileInput\').click();"><div class="dropzone-text">Add your images or svg</div><div class="dropzone-subtext">Drag and drop here, or click to browse</div></div></div>';
                setupDropzoneHandlers();
                document.getElementById('propertiesContent').innerHTML = '';
                selectedLayerId = null;
                layerGroups = {};
                collapsedFolders.clear();
            } else if (selectedLayerId === layerId) {
                // Select the next available layer
                selectLayer(layers[0].id);
            }
            
            // Clear from multi-select if present
            selectedLayerIds.delete(layerId);
            
            // Re-render panel
            renderLayersPanel();
            updateTimeline();
            saveState();
        }
        
        function reorderLayers(draggedId, targetId) {
            const draggedIndex = layers.findIndex(l => l.id === draggedId);
            const targetIndex = layers.findIndex(l => l.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // Remove dragged layer
            const [draggedLayer] = layers.splice(draggedIndex, 1);
            
            // Insert at target position
            layers.splice(targetIndex, 0, draggedLayer);
            
            // Rebuild layers panel
            const layersList = document.getElementById('layersList');
            layersList.innerHTML = '';
            layers.forEach(layer => {
                addLayerToPanel(layer);
            });
            
            // Rebuild canvas to match layer order
            const container = document.getElementById('canvasContainer');
            const existingElements = Array.from(container.querySelectorAll('.preview-element'));
            existingElements.forEach(el => el.remove());
            
            layers.forEach(layer => {
                addLayerToCanvas(layer);
            });
            
            // Maintain selection
            if (selectedLayerId) {
                selectLayer(selectedLayerId);
            }
            
            updateTimeline();
        }
        
        function renderFolderProperties(folderId) {
            const group = layerGroups[folderId];
            if (!group) {
                document.getElementById('propertiesContent').innerHTML = '';
                return;
            }
            
            const content = document.getElementById('propertiesContent');
            content.innerHTML = `
                <div class="panel-section">
                    <div class="section-title">Animation State</div>
                    <div class="state-tabs">
                        <button class="state-tab active" data-state="in">Animation In</button>
                    </div>
            </div>
                
                <div class="panel-section">
                    <div class="property-group">
                        <label class="property-label">Common</label>
                        <select class="property-input" id="folderCategorySelect">
                            <option value="">Select common</option>
                        </select>
                    </div>
                    
                    <div class="property-group">
                        <label class="property-label">Token</label>
                        <select class="property-input" id="folderTokenSelect" disabled>
                            <option value="">Select token</option>
                        </select>
                    </div>
                    
                    <div class="property-group">
                        <label class="property-label">Duration</label>
                        <select class="property-input" id="folderDurationInput">
                            <option value="150" ${group.duration === 150 ? 'selected' : ''}>motion-duration-150 (150ms)</option>
                            <option value="200" ${group.duration === 200 ? 'selected' : ''}>motion-duration-200 (200ms)</option>
                            <option value="250" ${group.duration === 250 ? 'selected' : ''}>motion-duration-250 (250ms)</option>
                            <option value="300" ${group.duration === 300 ? 'selected' : ''}>motion-duration-300 (300ms)</option>
                            <option value="400" ${group.duration === 400 ? 'selected' : ''}>motion-duration-400 (400ms)</option>
                            <option value="500" ${group.duration === 500 ? 'selected' : ''}>motion-duration-500 (500ms)</option>
                        </select>
                    </div>
                    
                    <div class="property-group">
                        <label class="property-label">Easing</label>
                        <select class="property-input" id="folderEasingSelect">
                            <option value="" ${group.easing === '' ? 'selected' : ''}>Select easing</option>
                            <option value="cubic-bezier(0, 0, 0.2, 1)" ${group.easing === 'cubic-bezier(0, 0, 0.2, 1)' ? 'selected' : ''}>motion-easing-decelerate</option>
                            <option value="cubic-bezier(0.4, 0, 1, 1)" ${group.easing === 'cubic-bezier(0.4, 0, 1, 1)' ? 'selected' : ''}>motion-easing-accelerate</option>
                            <option value="cubic-bezier(0.4, 0, 0.6, 1)" ${group.easing === 'cubic-bezier(0.4, 0, 0.6, 1)' ? 'selected' : ''}>motion-easing-smooth</option>
                            <option value="linear" ${group.easing === 'linear' ? 'selected' : ''}>motion-easing-linear</option>
                        </select>
            </div>
                    
                    <div class="property-group">
                        <label class="property-label">Delay</label>
                        <select class="property-input" id="folderDelayInput">
                            <option value="0" ${group.delay === 0 ? 'selected' : ''}>motion-delay-0 (0ms)</option>
                            <option value="50" ${group.delay === 50 ? 'selected' : ''}>motion-delay-50 (50ms)</option>
                            <option value="100" ${group.delay === 100 ? 'selected' : ''}>motion-delay-100 (100ms)</option>
                            <option value="150" ${group.delay === 150 ? 'selected' : ''}>motion-delay-150 (150ms)</option>
                            <option value="200" ${group.delay === 200 ? 'selected' : ''}>motion-delay-200 (200ms)</option>
                            <option value="250" ${group.delay === 250 ? 'selected' : ''}>motion-delay-250 (250ms)</option>
                            <option value="300" ${group.delay === 300 ? 'selected' : ''}>motion-delay-300 (300ms)</option>
                            <option value="400" ${group.delay === 400 ? 'selected' : ''}>motion-delay-400 (400ms)</option>
                            <option value="500" ${group.delay === 500 ? 'selected' : ''}>motion-delay-500 (500ms)</option>
                        </select>
            </div>
                    </div>
            `;
            
            // Update category and token options
            updateFolderCategoryOptions(group);
            updateFolderTokenOptions(group);
            
            // Add event listeners
            const durationInput = document.getElementById('folderDurationInput');
            if (durationInput) {
                durationInput.addEventListener('change', (e) => {
                    group.duration = parseInt(e.target.value) || 300;
                    updateTimeline();
                });
            }
            
            const easingSelect = document.getElementById('folderEasingSelect');
            if (easingSelect) {
                easingSelect.addEventListener('change', (e) => {
                    group.easing = e.target.value;
                    updateTimeline();
                });
            }
            
            const delayInput = document.getElementById('folderDelayInput');
            if (delayInput) {
                delayInput.addEventListener('change', (e) => {
                    group.delay = parseInt(e.target.value) || 0;
                    updateTimeline();
                });
            }
            
            const categorySelect = document.getElementById('folderCategorySelect');
            if (categorySelect) {
                categorySelect.addEventListener('change', (e) => {
                    group.category = e.target.value;
                    // Clear pattern when category changes
                    group.pattern = '';
                    updateFolderTokenOptions(group);
                    updateTimeline();
                });
            }
            
            const tokenSelect = document.getElementById('folderTokenSelect');
            if (tokenSelect) {
                tokenSelect.addEventListener('change', (e) => {
                    group.pattern = e.target.value;
                    updateTimeline();
                });
            }
        }
        
        function updateFolderCategoryOptions(group) {
            const categorySelect = document.getElementById('folderCategorySelect');
            if (!categorySelect) return;
            
            categorySelect.innerHTML = '<option value="">Select common</option>';
            
            // Populate categories
            Object.keys(patternCategories).forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category.charAt(0).toUpperCase() + category.slice(1).replace('-', ' ');
                if (group.category === category) {
                    option.selected = true;
                }
                categorySelect.appendChild(option);
            });
        }
        
        function updateFolderTokenOptions(group) {
            const categorySelect = document.getElementById('folderCategorySelect');
            const tokenSelect = document.getElementById('folderTokenSelect');
            if (!categorySelect || !tokenSelect) return;
            
            // Use categorySelect value if set, otherwise use group.category (for initialization)
            const selectedCategory = categorySelect.value || group.category;
            
            tokenSelect.innerHTML = '<option value="">Select token</option>';
            
            if (selectedCategory && patternCategories[selectedCategory]) {
                // Enable token select and populate tokens from selected category
                tokenSelect.disabled = false;
                Object.keys(patternCategories[selectedCategory]).forEach(pattern => {
                    const option = document.createElement('option');
                    option.value = pattern;
                    option.textContent = pattern;
                    if (group.pattern === pattern) {
                        option.selected = true;
                    }
                    tokenSelect.appendChild(option);
                });
            } else {
                // Disable token select if no category selected
                tokenSelect.disabled = true;
            }
        }
        
        function renderPropertiesPanel() {
            // Check if folder is selected
            if (selectedFolderId) {
                renderFolderProperties(selectedFolderId);
                return;
            }
            
            const layer = layers.find(l => l.id === selectedLayerId);
            const content = document.getElementById('propertiesContent');
            
            if (!layer) {
                // Show Animation State section even when no layer is selected
                content.innerHTML = `
                    <div class="panel-section">
                        <div class="section-title">Animation State</div>
                        <div class="state-tabs">
                            <button class="state-tab active" data-state="in">Animation In</button>
                    </div>
            </div>
                `;
                return;
            }
            
            // Ensure position exists
            if (!layer.position) {
                layer.position = { x: 0, y: 0 };
            }
            
            // Always use 'in' state now
            layer.state = 'in';
            
            content.innerHTML = `
                <div class="panel-section">
                    <div class="section-title">Animation State</div>
                    <div class="state-tabs">
                        <button class="state-tab active" data-state="in">Animation In</button>
                    </div>
            
                    <div class="property-group">
                        <label class="property-label">Common</label>
                        <select class="property-input" id="categorySelect">
                            <option value="">Select common</option>
                        </select>
                    </div>
                    
                    <div class="property-group">
                        <label class="property-label">Token</label>
                        <select class="property-input" id="tokenSelect" disabled>
                            <option value="">Select token</option>
                        </select>
                    </div>
            </div>
                
                <div class="panel-section">
                    <div class="section-title-wrapper">
                        <div class="section-title">Override (Optional)</div>
                        <div class="override-toggle-header" id="overrideToggleHeader" onclick="toggleOverridePanel()">
                            <svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M24.6367 2.02L29.9955 7.38L9.9402 27.42L2.02206 30L4.58146 22.08L24.6367 2.02ZM24.6367 0C24.1169 0 23.597 0.2 23.2171 0.58L3.18179 20.62C3.18179 20.62 3.02182 20.76 2.96184 20.86C2.84187 21.02 2.7219 21.22 2.66191 21.44L0.102512 29.38C-0.337384 30.72 0.702371 32 2.00206 32C2.20202 32 2.42197 31.96 2.62192 31.9L10.5601 29.34C10.88 29.24 11.1599 29.06 11.3799 28.82L31.4151 8.8C32.195 8 32.195 6.74 31.4151 5.94L26.0564 0.58C25.6565 0.18 25.1566 0 24.6367 0Z" fill="currentColor"/>
                            </svg>
                    </div>
                    </div>
                    
                    <div id="overridePanel">
                        <div class="property-group property-group-with-override">
                            <label class="property-label">Duration</label>
                            <select class="property-input override-disabled" id="durationInput" disabled>
                                <option value="" ${layer.durationOverride === undefined ? 'selected' : ''}>Use pattern default</option>
                                <option value="100" ${layer.durationOverride === 100 ? 'selected' : ''}>motion-duration-100 (100ms)</option>
                                <option value="150" ${layer.durationOverride === 150 ? 'selected' : ''}>motion-duration-150 (150ms)</option>
                                <option value="200" ${layer.durationOverride === 200 ? 'selected' : ''}>motion-duration-200 (200ms)</option>
                                <option value="250" ${layer.durationOverride === 250 ? 'selected' : ''}>motion-duration-250 (250ms)</option>
                                <option value="300" ${layer.durationOverride === 300 ? 'selected' : ''}>motion-duration-300 (300ms)</option>
                                <option value="350" ${layer.durationOverride === 350 ? 'selected' : ''}>motion-duration-350 (350ms)</option>
                                <option value="400" ${layer.durationOverride === 400 ? 'selected' : ''}>motion-duration-400 (400ms)</option>
                                <option value="450" ${layer.durationOverride === 450 ? 'selected' : ''}>motion-duration-450 (450ms)</option>
                                <option value="500" ${layer.durationOverride === 500 ? 'selected' : ''}>motion-duration-500 (500ms)</option>
                                <option value="600" ${layer.durationOverride === 600 ? 'selected' : ''}>motion-duration-600 (600ms)</option>
                                <option value="700" ${layer.durationOverride === 700 ? 'selected' : ''}>motion-duration-700 (700ms)</option>
                                <option value="800" ${layer.durationOverride === 800 ? 'selected' : ''}>motion-duration-800 (800ms)</option>
                            </select>
                    </div>
                        
                        <div class="property-group property-group-with-override">
                            <label class="property-label">Easing</label>
                            <select class="property-input override-disabled" id="easingSelect" disabled>
                                <option value="" ${layer.easingOverride === undefined ? 'selected' : ''}>Use pattern default</option>
                                <option value="cubic-bezier(0.4, 0, 0.2, 1)" ${layer.easingOverride === 'cubic-bezier(0.4, 0, 0.2, 1)' ? 'selected' : ''}>motion-easing-default</option>
                                <option value="cubic-bezier(0, 0, 0.2, 1)" ${layer.easingOverride === 'cubic-bezier(0, 0, 0.2, 1)' ? 'selected' : ''}>motion-easing-decelerate</option>
                                <option value="cubic-bezier(0.4, 0, 1, 1)" ${layer.easingOverride === 'cubic-bezier(0.4, 0, 1, 1)' ? 'selected' : ''}>motion-easing-accelerate</option>
                                <option value="cubic-bezier(0.4, 0, 0.6, 1)" ${layer.easingOverride === 'cubic-bezier(0.4, 0, 0.6, 1)' ? 'selected' : ''}>motion-easing-smooth</option>
                                <option value="linear" ${layer.easingOverride === 'linear' ? 'selected' : ''}>motion-easing-linear</option>
                            </select>
                    </div>
                        
                        <div class="property-group property-group-with-override">
                            <label class="property-label">Delay</label>
                            <select class="property-input override-disabled" id="delayInput" disabled>
                                <option value="" ${layer.delayOverride === undefined ? 'selected' : ''}>Use pattern default</option>
                                <option value="0" ${layer.delayOverride === 0 ? 'selected' : ''}>motion-delay-0 (0ms)</option>
                                <option value="50" ${layer.delayOverride === 50 ? 'selected' : ''}>motion-delay-50 (50ms)</option>
                                <option value="100" ${layer.delayOverride === 100 ? 'selected' : ''}>motion-delay-100 (100ms)</option>
                                <option value="150" ${layer.delayOverride === 150 ? 'selected' : ''}>motion-delay-150 (150ms)</option>
                                <option value="200" ${layer.delayOverride === 200 ? 'selected' : ''}>motion-delay-200 (200ms)</option>
                                <option value="250" ${layer.delayOverride === 250 ? 'selected' : ''}>motion-delay-250 (250ms)</option>
                                <option value="300" ${layer.delayOverride === 300 ? 'selected' : ''}>motion-delay-300 (300ms)</option>
                                <option value="400" ${layer.delayOverride === 400 ? 'selected' : ''}>motion-delay-400 (400ms)</option>
                                <option value="500" ${layer.delayOverride === 500 ? 'selected' : ''}>motion-delay-500 (500ms)</option>
                            </select>
                    </div>
                    </div>
                    
                    <div class="effects-section">
                        <div class="effects-title">Effects</div>
                        <div id="effectsList"></div>
                        <button class="add-effect-btn" id="addEffectBtn">+ Add Effect</button>
                    </div>
            </div>
            `;
            
            // Render effects
            renderEffects(layer);
            
            // Check for existing overrides and enable panel if any exist
            // Also check if pattern is selected - override should only be editable if pattern exists
            if ((layer.durationOverride !== undefined || layer.easingOverride !== undefined || layer.delayOverride !== undefined) && layer.pattern) {
                const header = document.getElementById('overrideToggleHeader');
                if (header) {
                    header.classList.add('active');
                    const panel = document.getElementById('overridePanel');
                    if (panel) {
                        panel.classList.remove('override-disabled');
                        const inputs = panel.querySelectorAll('.property-input');
                        inputs.forEach(input => {
                            input.disabled = false;
                            input.classList.remove('override-disabled');
                        });
                    }
                }
            }
            
            // Disable override panel if no pattern is selected
            if (!layer.pattern) {
                const header = document.getElementById('overrideToggleHeader');
                if (header) {
                    header.classList.remove('active');
                    const panel = document.getElementById('overridePanel');
                    if (panel) {
                        panel.classList.add('override-disabled');
                        const inputs = panel.querySelectorAll('.property-input');
                        inputs.forEach(input => {
                            input.disabled = true;
                            input.classList.add('override-disabled');
                        });
                    }
                }
            }
            
            // State is always 'in' - no event listeners needed
            
            // Only add these event listeners if the elements exist (not in hover state)
            const durationInput = document.getElementById('durationInput');
            if (durationInput) {
                durationInput.addEventListener('change', (e) => {
                    saveState(); // Save state before change
                    const value = e.target.value;
                    
                    // Apply to all selected layers
                    const layersToUpdate = selectedLayerIds.size > 1 
                        ? Array.from(selectedLayerIds).map(id => layers.find(l => l.id === id))
                        : [layer];
                    
                    layersToUpdate.forEach(l => {
                        if (!l) return;
                        
                        if (value === '') {
                            l.durationOverride = undefined;
                            if (l.pattern && l.category && patternCategories[l.category]?.[l.pattern]) {
                                l.duration = patternCategories[l.category][l.pattern].duration;
                            }
                        } else {
                            l.durationOverride = parseInt(value);
                            l.duration = l.durationOverride;
                        }
                    });
                    
                    checkForSuggestions();
                    updateTimeline();
                    saveState(); // Save state after change
                });
            }
            
            const easingSelect = document.getElementById('easingSelect');
            if (easingSelect) {
                easingSelect.addEventListener('change', (e) => {
                    saveState(); // Save state before change
                    const value = e.target.value;
                    
                    // Apply to all selected layers
                    const layersToUpdate = selectedLayerIds.size > 1 
                        ? Array.from(selectedLayerIds).map(id => layers.find(l => l.id === id))
                        : [layer];
                    
                    layersToUpdate.forEach(l => {
                        if (!l) return;
                        
                        if (value === '') {
                            l.easingOverride = undefined;
                            if (l.pattern && l.category && patternCategories[l.category]?.[l.pattern]) {
                                l.easing = patternCategories[l.category][l.pattern].easing;
                            }
                        } else {
                            l.easingOverride = value;
                            l.easing = l.easingOverride;
                        }
                    });
                    
                    checkForSuggestions();
                    updateTimeline();
                    saveState(); // Save state after change
                });
            }
            
            const delayInput = document.getElementById('delayInput');
            if (delayInput) {
                delayInput.addEventListener('change', (e) => {
                    saveState(); // Save state before change
                    const value = e.target.value;
                    
                    // Apply to all selected layers
                    const layersToUpdate = selectedLayerIds.size > 1 
                        ? Array.from(selectedLayerIds).map(id => layers.find(l => l.id === id))
                        : [layer];
                    
                    layersToUpdate.forEach(l => {
                        if (!l) return;
                        
                        if (value === '') {
                            l.delayOverride = undefined;
                            l.delay = 0;
                        } else {
                            l.delayOverride = parseInt(value);
                            l.delay = l.delayOverride;
                        }
                    });
                    
                    updateTimeline();
                    saveState(); // Save state after change
                });
            }
            
            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) {
                categorySelect.addEventListener('change', (e) => {
                    saveState(); // Save state before change
                    layer.category = e.target.value;
                    // Clear pattern when category changes
                    layer.pattern = '';
                    updateTokenOptions();
                    updateTimeline();
                    saveState(); // Save state after change
                });
            }
            
            const tokenSelect = document.getElementById('tokenSelect');
            if (tokenSelect) {
                tokenSelect.addEventListener('change', (e) => {
                    saveState(); // Save state before change
                    layer.pattern = e.target.value;
                    
                    // Enable override panel if token is selected
                    if (layer.pattern) {
                        // Override panel can now be enabled via toggle
                    } else {
                        // Disable override panel if no token
                        const header = document.getElementById('overrideToggleHeader');
                        if (header) {
                            header.classList.remove('active');
                            const panel = document.getElementById('overridePanel');
                            if (panel) {
                                panel.classList.add('override-disabled');
                                const inputs = panel.querySelectorAll('.property-input');
                                inputs.forEach(input => {
                                    input.disabled = true;
                                    input.classList.add('override-disabled');
                                });
                            }
                        }
                    }
                    
                    // Update duration from pattern if not custom
                    if (layer.pattern && layer.category && patternCategories[layer.category] && patternCategories[layer.category][layer.pattern]) {
                        const patternData = patternCategories[layer.category][layer.pattern];
                        if (layer.durationOverride === undefined) {
                            layer.duration = patternData.duration;
                            const durationInput = document.getElementById('durationInput');
                            if (durationInput) {
                                durationInput.value = '';
                            }
                        }
                    }
                    
                    checkForSuggestions();
                    updateTimeline();
                    saveState(); // Save state after change
                });
            }
            
            // Scale input event listener (in layers panel)
            // Update all scale inputs (there might be multiple - one in properties panel, one in canvas popup)
            const layerScaleInputs = document.querySelectorAll('#layerScaleInput');
            layerScaleInputs.forEach(layerScaleInput => {
                layerScaleInput.value = layer.scale || 100;
                
                const handleScaleChange = (value) => {
                    const scaleValue = Math.max(10, Math.min(500, parseInt(value) || 100));
                    
                    // Apply to all selected layers
                    const layersToUpdate = selectedLayerIds.size > 1 
                        ? Array.from(selectedLayerIds).map(id => layers.find(l => l.id === id))
                        : [layer];
                    
                    layersToUpdate.forEach(l => {
                        if (l) {
                            l.scale = scaleValue;
                            applyLayerScale(l.id, scaleValue);
                        }
                    });
                    
                    // Update all inputs
                    const allScaleInputs = document.querySelectorAll('#layerScaleInput');
                    allScaleInputs.forEach(input => {
                        input.value = scaleValue;
                    });
                };
                
                layerScaleInput.addEventListener('change', (e) => {
                    handleScaleChange(e.target.value);
                });
                
                layerScaleInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleScaleChange(layerScaleInput.value);
                        layerScaleInput.blur();
                    }
                });
            });
            
            // Opacity input event listener
            const layerOpacityInput = document.getElementById('layerOpacityInput');
            if (layerOpacityInput) {
                layerOpacityInput.value = layer.opacity !== undefined ? layer.opacity : 100;
                layerOpacityInput.addEventListener('change', (e) => {
                    const opacityValue = Math.max(0, Math.min(100, parseInt(e.target.value) || 100));
                    layer.opacity = opacityValue;
                    layerOpacityInput.value = opacityValue;
                    applyLayerOpacity(layer.id, opacityValue);
                });
                layerOpacityInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const opacityValue = Math.max(0, Math.min(100, parseInt(layerOpacityInput.value) || 100));
                        layer.opacity = opacityValue;
                        layerOpacityInput.value = opacityValue;
                        applyLayerOpacity(layer.id, opacityValue);
                        layerOpacityInput.blur();
                    }
                });
            }
            
            // Shadow input event listener
            const layerShadowInput = document.getElementById('layerShadowInput');
            const layerShadowValue = document.getElementById('layerShadowValue');
            if (layerShadowInput && layerShadowValue) {
                layerShadowInput.value = layer.shadow !== undefined ? layer.shadow : 0;
                layerShadowValue.textContent = `${layer.shadow || 0}px`;
                layerShadowInput.addEventListener('input', (e) => {
                    const shadowValue = parseInt(e.target.value) || 0;
                    
                    // Apply to all selected layers
                    const layersToUpdate = selectedLayerIds.size > 1 
                        ? Array.from(selectedLayerIds).map(id => layers.find(l => l.id === id))
                        : [layer];
                    
                    layersToUpdate.forEach(l => {
                        if (l) {
                            l.shadow = shadowValue;
                            applyLayerShadow(l.id, shadowValue);
                        }
                    });
                    
                    layerShadowValue.textContent = `${shadowValue}px`;
                });
            }
            
            // Add effect button event listener
            const addEffectBtn = document.getElementById('addEffectBtn');
            if (addEffectBtn) {
                addEffectBtn.addEventListener('click', () => {
                    addEffectToLayer(layer);
                });
            }
            
            // Populate categories and tokens
            updateCategoryOptions();
            updateTokenOptions();
        }
        
        function renderEffects(layer) {
            // Add null/undefined check
            if (!layer || !layer.effectsIn) {
                console.log('âš ï¸ renderEffects: No effects to render');
                const effectsList = document.getElementById('effectsList');
                const addEffectBtn = document.getElementById('addEffectBtn');
                if (effectsList) effectsList.innerHTML = '';
                if (addEffectBtn) addEffectBtn.style.display = 'flex';
                return;
            }
            
            // Check if effectsIn is an array
            if (!Array.isArray(layer.effectsIn)) {
                console.warn('âš ï¸ renderEffects: effectsIn is not an array:', layer.effectsIn);
                const effectsList = document.getElementById('effectsList');
                const addEffectBtn = document.getElementById('addEffectBtn');
                if (effectsList) effectsList.innerHTML = '';
                if (addEffectBtn) addEffectBtn.style.display = 'flex';
                return;
            }
            
            const effectsList = document.getElementById('effectsList');
            const addEffectBtn = document.getElementById('addEffectBtn');
            
            // Always use 'in' state effects
            if (!layer.effectsIn) {
                layer.effectsIn = [];
            }
            const stateEffects = layer.effectsIn;
            
            // Get available effects (always 'in' state)
            const availableEffectTypes = getAvailableEffects('in');
            
            // Render effect cards
            effectsList.innerHTML = stateEffects.map((effect, index) => {
                // Check if effectValues[effect.type] exists before calling Object.keys()
                if (!effect || !effect.type || !effectValues[effect.type]) {
                    console.warn('âš ï¸ renderEffects: Invalid effect or missing effectValues for type:', effect?.type);
                    return '';
                }
                
                const effectOptions = Object.keys(effectValues[effect.type]).map(token => {
                    return `<option value="${token}"${effect.from === token ? ' selected' : ''}>${token}</option>`;
                }).join('');
                
                // Spring only needs a single value (it's a timing function, not a transforming property)
                if (effect.type === 'spring') {
                    return `
                        <div class="effect-card single-value-effect" data-effect-index="${index}">
                            <div class="effect-card-header">
                                <span class="effect-card-title">${effect.type}</span>
                                <button class="remove-effect-btn" onclick="removeEffectFromLayer(${index})"><svg width="14" height="14" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_86_588)"><path d="M16 0C7.16 0 0 7.16 0 16C0 24.84 7.16 32 16 32C24.84 32 32 24.84 32 16C32 7.16 24.84 0 16 0ZM16 30C8.28 30 2 23.72 2 16C2 8.28 8.28 2 16 2C23.72 2 30 8.28 30 16C30 23.72 23.72 30 16 30Z" fill="currentColor"/><path d="M21.76 20.28C22.16 20.68 22.16 21.34 21.76 21.74C21.56 21.94 21.3 22.04 21.04 22.04C20.78 22.04 20.52 21.94 20.32 21.74L16.02 17.44L11.7 21.74C11.5 21.94 11.24 22.04 10.98 22.04C10.72 22.04 10.46 21.94 10.26 21.74C9.86 21.34 9.86 20.68 10.26 20.28L14.56 16L10.26 11.72C9.86 11.34 9.86 10.68 10.26 10.28C10.66 9.88 11.3 9.88 11.7 10.28L16.02 14.56L20.32 10.28C20.72 9.88 21.36 9.88 21.76 10.28C22.16 10.68 22.16 11.34 21.76 11.72L17.46 16L21.76 20.28Z" fill="currentColor"/></g><defs><clipPath id="clip0_86_588"><rect width="32" height="32" fill="white"/></clipPath></defs></svg></button>
    </div>
                            <div class="property-group">
                                <label class="from-to-label">Spring Type</label>
                                <select class="property-input" onchange="updateEffectValue(${index}, 'from', this.value)">
                                    ${effectOptions}
                                </select>
            </div>
    </div>
                    `;
                }
                
                // Other effects use from/to
                const effectOptionsTo = Object.keys(effectValues[effect.type]).map(token => {
                    return `<option value="${token}"${effect.to === token ? ' selected' : ''}>${token}</option>`;
                }).join('');
                
                return `
                    <div class="effect-card" data-effect-index="${index}">
                        <div class="effect-card-header">
                            <span class="effect-card-title">${effect.type}</span>
                            <button class="remove-effect-btn" onclick="removeEffectFromLayer(${index})">Ã—</button>
                    </div>
                        <div class="from-to-grid">
                            <div class="from-to-group">
                                <label class="from-to-label">From</label>
                                <select class="property-input" onchange="updateEffectValue(${index}, 'from', this.value)">
                                    ${effectOptions}
                                </select>
            </div>
                            <div class="from-to-group">
                                <label class="from-to-label">To</label>
                                <select class="property-input" onchange="updateEffectValue(${index}, 'to', this.value)">
                                    ${effectOptionsTo}
                                </select>
    </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Hide add button if all effect types are used
            const usedTypes = stateEffects.map(e => e.type);
            const availableTypes = Object.keys(availableEffectTypes).filter(t => !usedTypes.includes(t));
            addEffectBtn.style.display = availableTypes.length > 0 ? 'flex' : 'none';
        }
        
        function addEffectToLayer(layer) {
            const availableEffectTypes = getAvailableEffects('in');
            
            // Always use 'in' state effects
            if (!layer.effectsIn) {
                layer.effectsIn = [];
            }
            const stateEffects = layer.effectsIn;
            
            const usedTypes = stateEffects.map(e => e.type);
            const availableTypes = Object.keys(availableEffectTypes).filter(t => !usedTypes.includes(t));
            
            if (availableTypes.length === 0) {
                alert('All effect types are already in use!');
                return;
            }
            
            // Show selector for effect type
            const effectsList = document.getElementById('effectsList');
            const selectorHTML = `
                <div class="effect-card new-effect-selector">
                    <div class="property-group">
                        <label class="property-label">Choose Effect Type</label>
                        <select class="property-input" id="newEffectTypeSelect">
                            <option value="">Select effect...</option>
                            ${availableTypes.map(type => `<option value="${type}">${type.charAt(0).toUpperCase() + type.slice(1)}</option>`).join('')}
                        </select>
                    </div>
            </div>
            `;
            effectsList.insertAdjacentHTML('beforeend', selectorHTML);
            
            document.getElementById('newEffectTypeSelect').addEventListener('change', (e) => {
                const effectType = e.target.value;
                if (!effectType) return;
                
                const firstToken = Object.keys(effectValues[effectType])[0];
                stateEffects.push({
                    type: effectType,
                    from: firstToken,
                    to: firstToken
                });
                
                renderEffects(layer);
                updateTimeline();
            });
            
            // Hide add button temporarily
            document.getElementById('addEffectBtn').style.display = 'none';
        }
        
        function removeEffectFromLayer(index) {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) return;
            
            // Always use 'in' state effects
            if (!layer.effectsIn) return;
            
            layer.effectsIn.splice(index, 1);
            renderEffects(layer);
            updateTimeline();
        }
        
        function updateEffectValue(index, prop, value) {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) return;
            
            // Always use 'in' state effects
            if (!layer.effectsIn || !layer.effectsIn[index]) return;
            
            layer.effectsIn[index][prop] = value;
            updateTimeline();
        }
        
        function toggleOverridePanel() {
            const header = document.getElementById('overrideToggleHeader');
            const panel = document.getElementById('overridePanel');
            if (!header || !panel) return;
            
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer || !layer.pattern) {
                // Can't enable override without a pattern selected
                return;
            }
            
            const isActive = header.classList.contains('active');
            const durationInput = document.getElementById('durationInput');
            const easingInput = document.getElementById('easingSelect');
            const delayInput = document.getElementById('delayInput');
            
            if (isActive) {
                // Disable override mode - reset all to "Use pattern default"
                saveState(); // Save state before change
                header.classList.remove('active');
                panel.classList.add('override-disabled');
                
                // Get all override inputs (duration, easing, delay)
                const allOverrideInputs = [durationInput, easingInput, delayInput].filter(Boolean);
                allOverrideInputs.forEach(input => {
                    input.disabled = true;
                    input.classList.add('override-disabled');
                    // Reset to "Use pattern default"
                    input.value = '';
                });
                
                // Clear override flags
                if (layer) {
                    layer.durationOverride = undefined;
                    layer.easingOverride = undefined;
                    layer.delayOverride = undefined;
                    
                    // Restore pattern defaults if pattern exists
                    if (layer.pattern && layer.category && patternCategories[layer.category] && patternCategories[layer.category][layer.pattern]) {
                        const patternData = patternCategories[layer.category][layer.pattern];
                        layer.duration = patternData.duration;
                        layer.easing = patternData.easing;
                        layer.delay = 0;
                    }
                    updateTimeline();
                    saveState(); // Save state after change
                }
            } else {
                // Enable override mode
                saveState(); // Save state before change
                header.classList.add('active');
                panel.classList.remove('override-disabled');
                
                // Get all override inputs
                const allOverrideInputs = [durationInput, easingInput, delayInput].filter(Boolean);
                allOverrideInputs.forEach(input => {
                    input.disabled = false;
                    input.classList.remove('override-disabled');
                });
                
                // Set existing override values if they exist
                const layer = layers.find(l => l.id === selectedLayerId);
                if (layer) {
                    if (layer.durationOverride !== undefined && durationInput) {
                        durationInput.value = layer.durationOverride;
                    }
                    if (layer.easingOverride !== undefined && easingInput) {
                        easingInput.value = layer.easingOverride;
                    }
                    if (layer.delayOverride !== undefined && delayInput) {
                        delayInput.value = layer.delayOverride;
                    }
                }
                saveState(); // Save state after change
            }
        }
        
        function toggleOverride(type, forceEnable = false) {
            // This function is kept for backward compatibility but now uses panel-level toggle
            const header = document.getElementById('overrideToggleHeader');
            if (header && !header.classList.contains('active')) {
                toggleOverridePanel();
            }
        }
        
        // Helper function to find category for a pattern
        function findCategoryForPattern(pattern) {
            if (!pattern) return null;
            for (const category in patternCategories) {
                if (patternCategories[category][pattern]) {
                    return category;
                }
            }
            return null;
        }
        
        function updateCategoryOptions() {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) return;
            
            const categorySelect = document.getElementById('categorySelect');
            if (!categorySelect) return;
            
            categorySelect.innerHTML = '<option value="">Select common</option>';
            
            // Populate categories
            Object.keys(patternCategories).forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category.charAt(0).toUpperCase() + category.slice(1).replace('-', ' ');
                if (layer.category === category) {
                    option.selected = true;
                }
                categorySelect.appendChild(option);
            });
        }
        
        function updateTokenOptions() {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) return;
            
            const categorySelect = document.getElementById('categorySelect');
            const tokenSelect = document.getElementById('tokenSelect');
            if (!categorySelect || !tokenSelect) return;
            
            // Use categorySelect value if set, otherwise use layer.category (for initialization)
            const selectedCategory = categorySelect.value || layer.category;
            
            tokenSelect.innerHTML = '<option value="">Select token</option>';
            
            if (selectedCategory && patternCategories[selectedCategory]) {
                // Enable token select and populate tokens from selected category
                tokenSelect.disabled = false;
                Object.keys(patternCategories[selectedCategory]).forEach(tokenName => {
                    const option = document.createElement('option');
                    option.value = tokenName;
                    option.textContent = tokenName;
                    if (layer.pattern === tokenName) {
                        option.selected = true;
                    }
                    tokenSelect.appendChild(option);
                });
            } else {
                // Disable token select if no category selected
                tokenSelect.disabled = true;
            }
        }
        
        function checkForSuggestions() {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer || !layer.pattern) {
                document.getElementById('suggestionBanner').innerHTML = '';
                return;
            }
            
            const patternData = patternCategories[layer.category][layer.pattern];
            if (!patternData) return;
            
            const hasOverride = (layer.duration && parseInt(layer.duration) !== patternData.duration) || 
                                 (layer.easing && layer.easing !== patternData.easing);
            
            if (hasOverride) {
                document.getElementById('suggestionBanner').innerHTML = `
                    <div class="suggestion-banner">
                        <strong>Exploring New Patterns</strong><br>
                        You're customizing <strong>${layer.pattern}</strong> with values different from the standard pattern. Please consult with the Design System team to evaluate whether this new pattern variation is important enough to be added to our system.
    </div>
                `;
            } else {
                document.getElementById('suggestionBanner').innerHTML = '';
            }
        }
        
        // Rebuild layers array based on folder and layer order
        function rebuildLayersArray() {
            const newLayersArray = [];
            
            // First add standalone layers (not in folders)
            const standaloneLayers = layers.filter(l => l.groupId === null);
            newLayersArray.push(...standaloneLayers);
            
            // Then iterate through folders in order
            Object.keys(layerGroups).forEach(groupId => {
                const group = layerGroups[groupId];
                // Add layers from this folder in order
                group.layers.forEach(layerId => {
                    const layer = layers.find(l => l.id === layerId);
                    if (layer) {
                        newLayersArray.push(layer);
                    }
                });
            });
            
            layers = newLayersArray;
        }
        
        // Update z-index of all layers based on their order in the layers array
        function updateLayerZIndexes() {
            // Get all layer IDs in visual order (top to bottom in panel)
            // Must match renderLayersPanel order: folders first, then standalone layers
            const visualOrder = [];
            
            // First add layers from folders (in the same order as rendered)
            const folderIds = Object.keys(layerGroups); // Same order as renderLayersPanel
            folderIds.forEach(folderId => {
                const group = layerGroups[folderId];
                group.layers.forEach(layerId => {
                    visualOrder.push(layerId);
                });
            });
            
            // Then add standalone layers
            const standaloneLayers = layers.filter(l => l.groupId === null);
            standaloneLayers.forEach(layer => {
                visualOrder.push(layer.id);
            });
            
            // Assign z-index: first in visual order (top of panel) = highest z-index
            visualOrder.forEach((layerId, visualIndex) => {
                const el = document.getElementById(layerId);
                if (el && previewMode === 'stacked') {
                    // Top of panel (visualIndex 0) should have highest z-index
                    // Bottom of panel (last visualIndex) should have lowest z-index
                    // Use higher base z-index to ensure layers are above canvas background
                    el.style.zIndex = 10 + (visualOrder.length - 1 - visualIndex);
                }
            });
        }
        
        // Check SVG layers and offer splitting when switching to stacked mode
        function checkAndOfferSVGSplitting() {
            // Find all SVG layers that haven't been checked for splitting
            const svgLayers = layers.filter(l => l.type === 'SVG' && l.svgContent);
            
            if (svgLayers.length === 0) return;
            
            // Check each SVG for splittable elements
            const splittableSVGs = [];
            
            svgLayers.forEach(layer => {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(layer.svgContent, 'image/svg+xml');
                const svgElement = svgDoc.documentElement;
                
                // Look for direct children groups
                const directGroups = Array.from(svgElement.children).filter(child => child.tagName === 'g');
                
                // Look for direct visual elements
                const directElements = Array.from(svgElement.children).filter(child => 
                    ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'text', 'image'].includes(child.tagName)
                );
                
                const splittableElements = [...directGroups, ...directElements];
                
                if (splittableElements.length > 1) {
                    splittableSVGs.push({
                        layer,
                        svgElement,
                        elements: splittableElements,
                        count: splittableElements.length
                    });
                }
            });
            
            if (splittableSVGs.length === 0) return;
            
            // Ask user if they want to split
            const totalLayers = splittableSVGs.reduce((sum, svg) => sum + svg.count, 0);
            const message = splittableSVGs.length === 1 
                ? `One SVG contains ${splittableSVGs[0].count} elements that can be split into separate layers for stacked animation.\n\nWould you like to split it?`
                : `${splittableSVGs.length} SVGs contain multiple elements (${totalLayers} total layers).\n\nWould you like to split them into separate layers for stacked animation?`;
            
            const shouldSplit = confirm(message);
            
            if (shouldSplit) {
                splittableSVGs.forEach(svg => {
                    splitExistingLayer(svg.layer, svg.svgElement, svg.elements);
                });
            }
        }
        
        function splitExistingLayer(originalLayer, svgElement, elements) {
            console.warn('ðŸ”µðŸ”µðŸ”µ SPLIT FUNCTION CALLED ðŸ”µðŸ”µðŸ”µ', originalLayer.id);
            console.warn('Original layer position:', originalLayer.position);
            
            // Wrap entire split operation to allow position changes
            unlockPositions(() => {
                // Check if already split - if so, unsplit first
                const existingSplitState = Object.values(splitStates).find(state => 
                    state.originalLayer.id === originalLayer.id
                );
                if (existingSplitState) {
                    unsplitLayers(existingSplitState.groupId);
                    return;
                }
            
            // Create a new folder for the split layers
            const folderId = 'group-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            layerGroups[folderId] = {
                id: folderId,
                name: originalLayer.name,
                layers: [],
                visible: true,
                state: 'in',
                category: '',
                pattern: '',
                duration: 300,
                easing: '',
                delay: 0,
                effectsIn: [],
                effectsOut: [],
                effectsHover: [],
                scale: 100
            };
            
            // Store split state for unsplit functionality, including original position
            const layerIndex = layers.findIndex(l => l.id === originalLayer.id);
            
            // Get the original layer's position BEFORE removing it
            // Position relative to COMPOSITION AREA, not container, so it stays fixed when timeline opens/closes
            const canvasEl = document.getElementById(originalLayer.id);
            let actualPosition = { x: 0, y: 0 };
            let originalHasTransform = false;
            
            console.log('SPLIT: Original layer position from data:', originalLayer.position);
            
            // Get the actual rendered position relative to COMPOSITION AREA
            if (canvasEl && previewMode === 'stacked') {
                // Check if original has transform BEFORE we remove it
                originalHasTransform = canvasEl.style.transform && canvasEl.style.transform.includes('translate');
                
                const container = document.getElementById('canvasContainer');
                const composition = container ? container.querySelector('.composition-area') : null;
                
                if (composition) {
                    // Element is inside composition-area, get its position relative to composition
                    const elementRect = canvasEl.getBoundingClientRect();
                    const compRect = composition.getBoundingClientRect();
                    
                    if (originalHasTransform) {
                        // Element is centered - style.left/top is the center point relative to composition
                        const styleLeft = parseFloat(canvasEl.style.left) || 0;
                        const styleTop = parseFloat(canvasEl.style.top) || 0;
                        
                        if (styleLeft !== 0 || styleTop !== 0) {
                            // Use style values directly - they're already relative to composition-area (which is position: relative)
                            // style.left/top for a centered element represents the center point relative to composition-area
                            actualPosition = { x: styleLeft, y: styleTop };
                            console.log('SPLIT: Centered element, using style center position:', actualPosition, {
                                styleLeft: styleLeft,
                                styleTop: styleTop
                            });
                        } else {
                            // Calculate center from bounding rect - but account for composition-area's border if any
                            // Composition-area has border: 1px solid, so we need to account for that
                            const compBorderLeft = parseFloat(getComputedStyle(composition).borderLeftWidth) || 0;
                            const compBorderTop = parseFloat(getComputedStyle(composition).borderTopWidth) || 0;
                            const elementCenterX = (elementRect.left - compRect.left - compBorderLeft) + (elementRect.width / 2);
                            const elementCenterY = (elementRect.top - compRect.top - compBorderTop) + (elementRect.height / 2);
                            actualPosition = { x: elementCenterX, y: elementCenterY };
                            console.log('SPLIT: Centered element, calculated center position:', actualPosition, {
                                elementCenterX: elementCenterX,
                                elementCenterY: elementCenterY,
                                compBorderLeft: compBorderLeft,
                                compBorderTop: compBorderTop,
                                elementRect: { left: elementRect.left, top: elementRect.top, width: elementRect.width, height: elementRect.height },
                                compRect: { left: compRect.left, top: compRect.top }
                            });
                        }
                    } else {
                        // Element uses top-left positioning
                        const styleLeft = parseFloat(canvasEl.style.left) || 0;
                        const styleTop = parseFloat(canvasEl.style.top) || 0;
                        
                        if (styleLeft !== 0 || styleTop !== 0) {
                            // Use style values directly (top-left relative to composition)
                            actualPosition = { x: styleLeft, y: styleTop };
                            console.log('SPLIT: Top-left element, using style position:', actualPosition);
                        } else {
                            // Calculate top-left from bounding rect
                            const elementLeft = elementRect.left - compRect.left;
                            const elementTop = elementRect.top - compRect.top;
                            actualPosition = { x: elementLeft, y: elementTop };
                            console.log('SPLIT: Top-left element, calculated position:', actualPosition);
                        }
                    }
                } else if (originalLayer.position && originalLayer.positionRelativeToComposition) {
                    // Fall back to layer.position if composition not found but position is composition-relative
                    actualPosition = { x: originalLayer.position.x, y: originalLayer.position.y };
                    console.log('SPLIT: Using layer.position (composition-relative):', actualPosition);
                } else if (originalLayer.position && (originalLayer.position.x !== 0 || originalLayer.position.y !== 0)) {
                    // Legacy: layer.position might be container-relative, use as fallback
                    actualPosition = { x: originalLayer.position.x, y: originalLayer.position.y };
                    console.log('SPLIT: Using layer.position fallback:', actualPosition);
                }
            }
            
            console.log('SPLIT: Final position relative to composition:', actualPosition, 'hasTransform:', originalHasTransform);
            
            splitStates[folderId] = {
                originalLayer: JSON.parse(JSON.stringify(originalLayer)), // Deep copy
                originalSvgContent: originalLayer.svgContent,
                originalElements: elements.map(el => el.cloneNode(true)),
                originalSvgElement: svgElement.cloneNode(false),
                originalIndex: layerIndex, // Store original position
                originalPosition: actualPosition // Store the actual position
            };
            
            // Remove original layer from canvas
            if (canvasEl) canvasEl.remove();
            
            // Remove from layers array
            if (layerIndex > -1) {
                layers.splice(layerIndex, 1);
            }
            
            // Remove from old group if it exists
            const oldGroupId = originalLayer.groupId;
            if (oldGroupId && layerGroups[oldGroupId]) {
                const oldGroup = layerGroups[oldGroupId];
                const groupLayerIndex = oldGroup.layers.indexOf(originalLayer.id);
                if (groupLayerIndex > -1) {
                    oldGroup.layers.splice(groupLayerIndex, 1);
                }
            }
            
            // Create new layers from elements - ALL at the SAME position as original
            const baseDelay = 0;
            const delayIncrement = 100;
            const newLayers = [];
            
            elements.forEach((element, index) => {
                // Create a new SVG with just this element
                const newSvg = svgElement.cloneNode(false);
                newSvg.appendChild(element.cloneNode(true));
                const svgString = new XMLSerializer().serializeToString(newSvg);
                
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                const layerId = 'layer-' + Date.now() + '-' + index + '-' + Math.random().toString(36).substr(2, 9);
                const layerName = element.id || element.getAttribute('inkscape:label') || element.getAttribute('data-name') || `${originalLayer.name} - Layer ${index + 1}`;
                
                const layer = {
                    id: layerId,
                    name: layerName,
                    type: 'SVG',
                    src: url,
                    svgContent: svgString,
                    state: 'in',
                    category: '',
                    pattern: '',
                    duration: 300,
                    easing: '',
                    visible: true,
                    delay: baseDelay + (index * delayIncrement),
                    effectsIn: [],
                    effectsOut: [],
                    effectsHover: [],
                    position: { x: actualPosition.x, y: actualPosition.y }, // Use original layer's position
                    positionRelativeToComposition: true, // Mark as composition-relative
                    scale: 100, // Always start at 100% scale - don't copy from original
                    opacity: 100, // Always start at 100% opacity
                    groupId: folderId
                };
                
                console.log(`SPLIT: Created layer ${index} with position:`, layer.position);
                
                newLayers.push(layer);
                layers.push(layer);
                layerGroups[folderId].layers.push(layerId);
            });
            
            // Add layers to canvas with composition-relative positioning
            const container = document.getElementById('canvasContainer');
            if (!container) {
                console.error('SPLIT: No canvas container found');
                return;
            }
            
            // Ensure composition exists (create it if needed)
            let composition = container.querySelector('.composition-area');
            if (!composition && previewMode === 'stacked') {
                console.warn('SPLIT: No composition found, creating it');
                renderComposition();
                composition = container.querySelector('.composition-area');
            }
            
            if (!composition && previewMode === 'stacked') {
                console.error('SPLIT: Could not create composition area');
                return;
            }
            
            newLayers.forEach((layer, index) => {
                const wrapper = document.createElement('div');
                wrapper.id = layer.id;
                wrapper.className = 'preview-element';
                wrapper.dataset.layerId = layer.id;
                wrapper.style.display = 'block';
                wrapper.style.position = 'absolute';
                wrapper.style.zIndex = '10';
                
                // Position relative to composition-area (which is the parent)
                // Position is already relative to composition-area, so use it directly
                wrapper.style.left = `${layer.position.x}px`;
                wrapper.style.top = `${layer.position.y}px`;
                wrapper.style.transform = originalHasTransform ? 'translate(-50%, -50%)' : '';
                
                console.log(`SPLIT: Layer ${index} (${layer.name}) positioned at:`, {
                    left: wrapper.style.left,
                    top: wrapper.style.top,
                    transform: wrapper.style.transform,
                    positionData: { x: layer.position.x, y: layer.position.y },
                    hasTransform: originalHasTransform,
                    elementId: wrapper.id
                });
                
                // Store initial position to detect changes
                const initialLeft = wrapper.style.left;
                const initialTop = wrapper.style.top;
                
                const img = document.createElement('img');
                img.src = layer.src;
                img.style.display = 'block';
                img.style.pointerEvents = 'none';
                img.style.maxWidth = '100%';
                img.style.maxHeight = '100%';
                img.className = 'preview-element-img';
                
                wrapper.appendChild(img);
                
                // Lock dimensions after image loads to prevent scaling
                img.addEventListener('load', () => {
                    const width = img.naturalWidth * (layer.scale / 100);
                    const height = img.naturalHeight * (layer.scale / 100);
                    wrapper.style.width = `${width}px`;
                    wrapper.style.height = `${height}px`;
                    wrapper.style.minWidth = `${width}px`;
                    wrapper.style.minHeight = `${height}px`;
                });
                
                // In stacked mode, append to composition-area so assets move naturally with it
                if (previewMode === 'stacked' && composition) {
                    composition.appendChild(wrapper);
                    
                    // Verify position after appending and check if it changed
                    requestAnimationFrame(() => {
                        const finalLeft = wrapper.style.left;
                        const finalTop = wrapper.style.top;
                        const finalTransform = wrapper.style.transform;
                        
                        // Check if style values changed
                        if (finalLeft !== initialLeft || finalTop !== initialTop) {
                            console.error(`âŒ SPLIT: Layer ${index} style changed! Before: (${initialLeft}, ${initialTop}), After: (${finalLeft}, ${finalTop})`);
                        }
                        
                        // Verify position by reading style values (they're already relative to composition-area)
                        // Don't use getBoundingClientRect() - it's in viewport coordinates and causes confusion
                        const styleX = parseFloat(finalLeft) || 0;
                        const styleY = parseFloat(finalTop) || 0;
                        const relativeX = styleX;
                        const relativeY = styleY;
                        
                        const matchX = Math.abs(relativeX - layer.position.x) < 1;
                        const matchY = Math.abs(relativeY - layer.position.y) < 1;
                        
                        console.log(`SPLIT: Layer ${index} (${layer.name}) AFTER append:`, {
                            initialStyle: { left: initialLeft, top: initialTop },
                            finalStyle: { left: finalLeft, top: finalTop },
                            styleChanged: finalLeft !== initialLeft || finalTop !== initialTop,
                            transform: finalTransform,
                            expectedX: layer.position.x,
                            expectedY: layer.position.y,
                            actualStyleX: relativeX.toFixed(1),
                            actualStyleY: relativeY.toFixed(1),
                            deltaX: (relativeX - layer.position.x).toFixed(1),
                            deltaY: (relativeY - layer.position.y).toFixed(1),
                            match: matchX && matchY
                        });
                        
                        if (!matchX || !matchY) {
                            console.error(`âŒ SPLIT: Layer ${index} position mismatch! Expected (${layer.position.x}, ${layer.position.y}), got (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)}), delta: (${(relativeX - layer.position.x).toFixed(1)}, ${(relativeY - layer.position.y).toFixed(1)})`);
                        }
                        
                        // Check again after a delay to see if something moves it later
                        setTimeout(() => {
                            const laterLeft = wrapper.style.left;
                            const laterTop = wrapper.style.top;
                            const laterX = parseFloat(laterLeft) || 0;
                            const laterY = parseFloat(laterTop) || 0;
                            
                            if (laterLeft !== finalLeft || laterTop !== finalTop) {
                                console.error(`âŒ SPLIT: Layer ${index} moved LATER! Final: (${finalLeft}, ${finalTop}), Later: (${laterLeft}, ${laterTop})`);
                                console.error(`   This means something called updateAllLayerPositions() or similar!`);
                            }
                            if (Math.abs(laterX - layer.position.x) > 1 || Math.abs(laterY - layer.position.y) > 1) {
                                console.error(`âŒ SPLIT: Layer ${index} position changed LATER! Expected (${layer.position.x}, ${layer.position.y}), got (${laterX.toFixed(1)}, ${laterY.toFixed(1)})`);
                            }
                        }, 100);
                    });
                } else {
                    // Fallback: append to container
                    container.appendChild(wrapper);
                }
                
                // Add event listeners (same as addLayerToCanvas)
                wrapper.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!isDraggingLayer) {
                        selectLayer(layer.id);
                    }
                });
                
                wrapper.addEventListener('mousedown', (e) => {
                    if (!isPlaying) {
                        e.preventDefault();
                        startLayerDrag(e, layer);
                    }
                });
                
                // DON'T apply scale/opacity immediately - layers should start at default scale
                // Scale/opacity will be applied when needed (e.g., when user changes it)
                // This prevents layers from scaling unexpectedly after split
                // if (layer.scale && layer.scale !== 100) {
                //     applyLayerScale(layer.id, layer.scale);
                // }
                // if (layer.opacity !== undefined && layer.opacity !== 100) {
                //     applyLayerOpacity(layer.id, layer.opacity);
                // }
            });
            
            // Insert folder at original layer position instead of rebuilding
            // Store folder order to maintain position
            const folderOrder = Object.keys(layerGroups);
            const originalIndex = splitStates[folderId].originalIndex;
            
            // Remove folder from end if it exists
            const folderIndex = folderOrder.indexOf(folderId);
            if (folderIndex > -1) {
                folderOrder.splice(folderIndex, 1);
            }
            
            // Insert at original position (or at end if position is invalid)
            const insertIndex = originalIndex >= 0 && originalIndex < folderOrder.length ? originalIndex : folderOrder.length;
            folderOrder.splice(insertIndex, 0, folderId);
            
            // Rebuild layerGroups in new order
            const newLayerGroups = {};
            folderOrder.forEach(id => {
                if (layerGroups[id]) {
                    newLayerGroups[id] = layerGroups[id];
                }
            });
            layerGroups = newLayerGroups;
            
            rebuildLayersArray();
            updateLayerZIndexes();
            renderLayersPanel();
            updateTimeline();
            
            // Don't auto-select the folder or layers after splitting
            // Clear any selection
            selectedFolderId = null;
            selectedLayerId = null;
            selectedFolderIds.clear();
            selectedLayerIds.clear();
            renderLayersPanel(); // Re-render to clear selection styling
            
            // Save state for undo/redo
            saveState();
            }); // End of unlockPositions
        }
        
        function unsplitLayers(folderId) {
            saveState(); // Save state before change
            
            const splitState = splitStates[folderId];
            if (!splitState) return;
            
            const group = layerGroups[folderId];
            if (!group) return;
            
            // Store original layer info
            const originalLayer = splitState.originalLayer;
            const originalSvgContent = splitState.originalSvgContent;
            const originalLayerId = originalLayer.id;
            const originalPosition = splitState.originalPosition || originalLayer.position || { x: 0, y: 0 };
            console.log('ðŸ”„ UNSPLIT: Using position:', originalPosition, 'from splitState:', !!splitState.originalPosition);
            const originalScale = originalLayer.scale || 100;
            const originalOpacity = originalLayer.opacity !== undefined ? originalLayer.opacity : 100;
            const originalGroupId = originalLayer.groupId;
            
            // Remove all split layers from canvas
            group.layers.forEach(layerId => {
                const canvasEl = document.getElementById(layerId);
                if (canvasEl) canvasEl.remove();
            });
            
            // Remove from layers array
            group.layers.forEach(layerId => {
                const layerIndex = layers.findIndex(l => l.id === layerId);
                if (layerIndex > -1) {
                    layers.splice(layerIndex, 1);
                }
            });
            
            // Create blob URL for original SVG
            const blob = new Blob([originalSvgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            // Restore original layer with original ID and properties
            const restoredLayer = {
                ...originalLayer,
                id: originalLayerId, // Use original ID, not a new one
                src: url,
                svgContent: originalSvgContent,
                groupId: originalGroupId, // Restore original group if it had one
                position: originalPosition,
                positionRelativeToComposition: true, // Ensure position is composition-relative
                scale: originalScale,
                opacity: originalOpacity,
                visible: originalLayer.visible !== undefined ? originalLayer.visible : true
            };
            
            // Find the position where the folder was in the layers array
            // We'll insert the restored layer at the beginning (top) since folders appear first
            layers.unshift(restoredLayer);
            
            // Add back to original group if it existed
            if (originalGroupId && layerGroups[originalGroupId]) {
                if (!layerGroups[originalGroupId].layers.includes(originalLayerId)) {
                    layerGroups[originalGroupId].layers.unshift(originalLayerId);
                }
            }
            
            // Remove the split folder
            delete layerGroups[folderId];
            delete splitStates[folderId];
            
            // Add restored layer to canvas with position lock bypass
            unlockPositions(() => {
                addLayerToCanvas(restoredLayer);
            });
            
            rebuildLayersArray();
            updateLayerZIndexes();
            renderLayersPanel();
            updateTimeline();
            
            // Select restored layer
            selectLayer(originalLayerId);
            
            // Save state for undo/redo
            saveState();
        }
        
        // Preview mode
        function setPreviewMode(mode) {
            console.log('ðŸ”„ setPreviewMode called:', mode);
            console.log('ðŸ“Š Current layers:', layers.length);
            console.log('ðŸ“Š Visible layers:', layers.filter(l => l.visible !== false).length);
            
            // Skip if already in this mode
            if (previewMode === mode) {
                console.log('âš ï¸ Already in', mode, 'mode, skipping');
                return;
            }
            
            // Check layer count for side-by-side mode
            if (mode === 'side-by-side') {
                const visibleLayers = layers.filter(l => l.visible !== false);
                console.log('ðŸ“ Entering side-by-side mode');
                console.log('ðŸ“ Will position layers in squares');
                console.log('ðŸ“ Visible layers count:', visibleLayers.length);
                if (visibleLayers.length > 6) {
                    alert(`Side-by-side mode supports up to 6 layers.\n\nYou currently have ${visibleLayers.length} layers.\n\nPlease delete ${visibleLayers.length - 6} layer(s) or hide them before switching to side-by-side mode.`);
                    return; // Don't switch modes
                }
            }
            
            console.log('ðŸ”„ MODE SWITCH:', previewMode, 'â†’', mode);
            
            // If switching to side-by-side, auto-unsplit all folders
            if (mode === 'side-by-side') {
                const foldersToUnsplit = Object.keys(layerGroups).filter(groupId => {
                    const group = layerGroups[groupId];
                    return group && group.layers && group.layers.length > 0;
                });
                
                if (foldersToUnsplit.length > 0) {
                    console.log('ðŸ”“ Auto-unsplitting', foldersToUnsplit.length, 'folders for side-by-side mode');
                    
                    foldersToUnsplit.forEach(groupId => {
                        const splitState = Object.values(splitStates).find(state => 
                            state.folderId === groupId
                        );
                        
                        if (splitState) {
                            unsplitLayers(groupId);
                        }
                    });
                }
            }
            
            previewMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            
            const container = document.getElementById('canvasContainer');
            container.className = `canvas-container ${mode}`;
            
            // Re-render layers panel to update split button visibility
            renderLayersPanel();
            
            // Update element positioning based on mode
            const elements = container.querySelectorAll('.preview-element');
            elements.forEach(el => {
                const layer = layers.find(l => l.id === el.id);
                if (!layer) return;
                
                // Ensure z-index is set correctly
                el.style.zIndex = '10'; // Base z-index, will be updated by updateLayerZIndexes
                
                if (mode === 'stacked') {
                    // Reset scale and opacity to 100% in stacked mode (they only get adjusted in side-by-side)
                    layer.scale = 100;
                    layer.opacity = 100;
                    
                    // Remove width/height constraints that were set in side-by-side mode
                    el.style.width = '';
                    el.style.height = '';
                    el.style.maxWidth = '';
                    el.style.maxHeight = '';
                    
                    // Apply 100% scale and opacity
                    applyLayerScale(layer.id, 100);
                    applyLayerOpacity(layer.id, 100);
                    
                    // Update scale and opacity inputs if this layer is selected
                    if (selectedLayerId === layer.id) {
                        const scaleInputs = document.querySelectorAll('#layerScaleInput');
                        scaleInputs.forEach(input => {
                            input.value = 100;
                        });
                        const opacityInput = document.getElementById('layerOpacityInput');
                        if (opacityInput) {
                            opacityInput.value = 100;
                        }
                    }
                    
                    // Apply absolute positioning for stacked mode
                    el.style.position = 'absolute';
                    
                    // Wait for composition to be rendered, then position layer within it
                    setTimeout(() => {
                        const composition = container.querySelector('.composition-area');
                        if (composition) {
                            const compRect = composition.getBoundingClientRect();
                            const containerRect = container.getBoundingClientRect();
                            const compLeft = (compRect.left - containerRect.left);
                            const compTop = (compRect.top - containerRect.top);
                            const compWidth = compRect.width;
                            const compHeight = compRect.height;
                            
                            const elementRect = el.getBoundingClientRect();
                            const elementWidth = elementRect.width || 100;
                            const elementHeight = elementRect.height || 100;
                            
                            let x = layer.position.x;
                            let y = layer.position.y;
                            
                            // Only center if position is exactly (0,0) - don't move layers that have been positioned
                            // Don't check if outside composition - layers can be positioned anywhere
                            if (x === 0 && y === 0) {
                                // Only center brand new layers that haven't been positioned yet
                                x = compLeft + (compWidth / 2);
                                y = compTop + (compHeight / 2);
                                el.style.left = `${x}px`;
                                el.style.top = `${y}px`;
                                el.style.transform = 'translate(-50%, -50%)';
                                layer.position.x = x;
                                layer.position.y = y;
                            } else {
                                // Keep existing position - calculate relative to composition if needed
                                if (layer.positionRelativeToComposition) {
                                    // Position is relative to composition, recalculate absolute position
                                    el.style.left = `${compLeft + x}px`;
                                    el.style.top = `${compTop + y}px`;
                                } else {
                                    // Legacy: position relative to container
                                    el.style.left = `${x}px`;
                                    el.style.top = `${y}px`;
                                }
                                el.style.transform = '';
                                // Don't update layer.position - keep it as is
                            }
                            
                            // Apply shadow if layer has one set
                            if (layer.shadow !== undefined && layer.shadow > 0) {
                                applyLayerShadow(layer.id, layer.shadow);
                            } else {
                                // Remove shadow if shadow is 0 or undefined
                                const el = document.getElementById(layer.id);
                                if (el) el.style.filter = 'none';
                            }
                        }
                    }, 100);
                } else {
                    // Side-by-side mode: layers will be positioned by positionLayersInSquares
                    // after composition squares are rendered (which will auto-scale them)
                }
            });
            
            // Before calling renderComposition(), preserve all layer elements
            console.log('ðŸ”„ MODE SWITCH:', previewMode, 'â†’', mode, '| Switch count:', (window.modeSwitchCount || 0) + 1);
            window.modeSwitchCount = (window.modeSwitchCount || 0) + 1;
            
            const preservedLayers = [];
            layers.forEach(layer => {
                const element = document.getElementById(layer.id);
                if (element) {
                    preservedLayers.push({
                        id: layer.id,
                        element: element,
                        parent: element.parentElement?.className,
                        display: element.style.display,
                        position: element.style.position
                    });
                    console.log('ðŸ’¾ Preserved:', layer.id, {
                        parent: element.parentElement?.className,
                        display: element.style.display,
                        inDOM: document.body.contains(element)
                    });
                } else {
                    console.error('âŒ Layer element NOT FOUND:', layer.id);
                }
            });
            
            console.log('ðŸ“Š Total layers in data:', layers.length, '| Preserved elements:', preservedLayers.length);
            
            // Call renderComposition
            renderComposition();
            
            // After renderComposition, ensure all layers are in the correct place
            setTimeout(() => {
                const container = document.getElementById('canvasContainer');
                const composition = container?.querySelector('.composition-area');
                
                console.log('ðŸ”„ RESTORING after renderComposition');
                console.log('ðŸ“ Composition exists:', !!composition);
                console.log('ðŸ“ Preserved layers still in DOM:', preservedLayers.filter(p => document.body.contains(p.element)).length);
                
                preservedLayers.forEach(({id, element}) => {
                    if (!document.body.contains(element)) {
                        console.error('âŒ Layer element removed from DOM during renderComposition:', id);
                    }
                });
                
                console.log('ðŸ“ Target:', mode === 'stacked' ? 'composition' : 'composition squares');
                
                if (mode === 'stacked' && composition) {
                    // Stacked mode: move all layers into the single composition
                    preservedLayers.forEach(({id, element}) => {
                        if (element && element.parentElement !== composition) {
                            composition.appendChild(element);
                            console.log('âœ… Moved layer to stacked composition:', id);
                        }
                    });
                } else if (mode === 'side-by-side') {
                    // Side-by-side: layers will be positioned by positionLayersInSquares
                    console.log('âœ… Side-by-side mode: layers will be positioned in squares');
                }
            }, 100);
            
            // Position layers based on mode
            setTimeout(() => {
                if (mode === 'side-by-side') {
                    // Side-by-side: put each layer in its own square
                    const visibleLayers = layers.filter(l => l.visible !== false);
                    const layerCount = Math.min(visibleLayers.length, 6);
                    console.log('ðŸ“ Positioning', layerCount, 'layers in side-by-side squares');
                    positionLayersInSquares(visibleLayers.slice(0, layerCount));
                } else if (mode === 'stacked') {
                    // Stacked: center all layers in the composition
                    console.log('ðŸ“ Centering all layers in stacked mode');
                    const composition = document.querySelector('.composition-area');
                    if (composition) {
                        layers.forEach(layer => {
                            const element = document.getElementById(layer.id);
                            if (element && layer.visible !== false) {
                                // Center each layer
                                const compWidth = composition.offsetWidth;
                                const compHeight = composition.offsetHeight;
                                element.style.left = `${compWidth / 2}px`;
                                element.style.top = `${compHeight / 2}px`;
                                element.style.transform = 'translate(-50%, -50%)';
                                
                                // Update layer position data
                                layer.position.x = compWidth / 2;
                                layer.position.y = compHeight / 2;
                                layer.positionRelativeToComposition = true;
                            }
                        });
                    }
                }
                zoomToFit();
            }, 150);
            
            // Center view after composition is rendered
            setTimeout(() => {
                if (previewMode === 'stacked') {
                    zoomToFit();
                }
            }, 100);
            
            // Auto-fit zoom when switching modes
            setTimeout(() => {
                if (mode === 'stacked') {
                    // Update z-indexes based on layer order
                    updateLayerZIndexes();
                    
                    // Auto-fit zoom for stacked mode
                    zoomToFit();
                }
            }, 50);
            
            // Refresh properties panel to show/hide position section
            if (selectedLayerId) {
                renderPropertiesPanel();
            }
        }
        
        // Background color
        function setBackground(bg) {
            previewBg = bg;
            
            document.querySelectorAll('.bg-option').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.bg === bg);
            });
            
            const canvas = document.getElementById('canvasArea');
            canvas.className = `preview-canvas bg-${bg}`;
        }
        
        // Layer positioning in stacked mode
        function startLayerDrag(e, layer) {
            e.preventDefault();
            e.stopPropagation();
            
            draggedLayerElement = document.getElementById(layer.id);
            
            // Disable transitions for smooth dragging
            draggedLayerElement.classList.add('dragging');
            
            // Lock dimensions to prevent scaling during drag
            // Preserve EXACT current size without removing constraints
            const currentWidth = draggedLayerElement.offsetWidth;
            const currentHeight = draggedLayerElement.offsetHeight;
            
            // Store original constraints to restore later
            draggedLayerElement.dataset.originalMaxWidth = draggedLayerElement.style.maxWidth || '';
            draggedLayerElement.dataset.originalMaxHeight = draggedLayerElement.style.maxHeight || '';
            
            // Lock to current size (don't remove max constraints, just set explicit size)
            draggedLayerElement.style.width = `${currentWidth}px`;
            draggedLayerElement.style.height = `${currentHeight}px`;
            
            // Get current computed position
            const rect = draggedLayerElement.getBoundingClientRect();
            const container = document.getElementById('canvasContainer');
            const composition = container ? container.querySelector('.composition-area') : null;
            
            // Store mouse position in canvas space
            layerDragStartX = e.clientX;
            layerDragStartY = e.clientY;
            
            // Store initial element position relative to composition-area (which is the parent)
            const zoomFactor = zoomValue / 100;
            if (composition && previewMode === 'stacked') {
                // Element is inside composition-area, so get position relative to it
                const compRect = composition.getBoundingClientRect();
                const elementLeft = parseFloat(draggedLayerElement.style.left) || 0;
                const elementTop = parseFloat(draggedLayerElement.style.top) || 0;
                layerInitialX = elementLeft;
                layerInitialY = elementTop;
            } else {
                // Fallback for side-by-side mode
                const containerRect = container.getBoundingClientRect();
                layerInitialX = (rect.left - containerRect.left) / zoomFactor;
                layerInitialY = (rect.top - containerRect.top) / zoomFactor;
            }
            
            // Remove any transform (like translate(-50%, -50%)) and use explicit positioning
            // Also ensure no scale transform that could cause visual scaling
            draggedLayerElement.style.transform = 'none';
            draggedLayerElement.style.left = `${layerInitialX}px`;
            draggedLayerElement.style.top = `${layerInitialY}px`;
            
            draggedLayerElement.style.cursor = 'grabbing';
            
            document.addEventListener('mousemove', onLayerDrag);
            document.addEventListener('mouseup', stopLayerDrag);
            
            selectLayer(layer.id);
        }
        
        function onLayerDrag(e) {
            if (!draggedLayerElement) return;
            
            // Set dragging flag only after actual movement (prevents accidental clicks from triggering)
            if (!isDraggingLayer) {
                const deltaX = Math.abs(e.clientX - layerDragStartX);
                const deltaY = Math.abs(e.clientY - layerDragStartY);
                if (deltaX > 3 || deltaY > 3) {
                    isDraggingLayer = true;
                }
            }
            
            if (!isDraggingLayer) return;
            
            // Calculate mouse movement in screen space
            const deltaX = e.clientX - layerDragStartX;
            const deltaY = e.clientY - layerDragStartY;
            
            // Account for zoom - convert screen space movement to canvas space
            const zoomFactor = zoomValue / 100;
            const canvasDeltaX = deltaX / zoomFactor;
            const canvasDeltaY = deltaY / zoomFactor;
            
            // Calculate new position
            let newX = layerInitialX + canvasDeltaX;
            let newY = layerInitialY + canvasDeltaY;
            
            // In side-by-side mode, constrain to grid boundaries
            if (previewMode === 'side-by-side') {
                const container = document.getElementById('canvasContainer');
                const compositions = Array.from(container.querySelectorAll('.composition-area'))
                    .sort((a, b) => parseInt(a.dataset.squareIndex) - parseInt(b.dataset.squareIndex));
                
                let gridBounds = null;
                
                // Find which grid this layer belongs to
                const elementRect = draggedLayerElement.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const elementCenterX = elementRect.left + elementRect.width / 2;
                const elementCenterY = elementRect.top + elementRect.height / 2;
                
                compositions.forEach((comp) => {
                    const compRect = comp.getBoundingClientRect();
                    
                    // Check if layer center is in this composition
                    if (elementCenterX >= compRect.left && elementCenterX <= compRect.right &&
                        elementCenterY >= compRect.top && elementCenterY <= compRect.bottom) {
                        gridBounds = {
                            left: (compRect.left - containerRect.left) / zoomFactor,
                            top: (compRect.top - containerRect.top) / zoomFactor,
                            right: (compRect.right - containerRect.left) / zoomFactor,
                            bottom: (compRect.bottom - containerRect.top) / zoomFactor
                        };
                    }
                });
                
                // Constrain to grid if found
                if (gridBounds) {
                    const layerWidth = draggedLayerElement.offsetWidth / zoomFactor;
                    const layerHeight = draggedLayerElement.offsetHeight / zoomFactor;
                    const margin = 10; // Small margin from edges
                    
                    newX = Math.max(gridBounds.left + margin, Math.min(newX, gridBounds.right - layerWidth - margin));
                    newY = Math.max(gridBounds.top + margin, Math.min(newY, gridBounds.bottom - layerHeight - margin));
                }
            } else {
                // Stacked mode: Allow free movement - assets can extend beyond composition bounds and will be clipped by overflow: hidden
                // No constraints needed - user can position assets anywhere, even if parts are clipped
            }
            
            // Apply position with sub-pixel precision (Figma-style smooth movement)
            draggedLayerElement.style.left = `${newX}px`;
            draggedLayerElement.style.top = `${newY}px`;
            
            // Update layer position data (store as absolute for now, will convert to composition-relative on drag end)
            const layer = layers.find(l => l.id === draggedLayerElement.id);
            if (layer) {
                // Update position with lock bypass
                unlockPositions(() => {
                    layer.position.x = Math.round(newX);
                    layer.position.y = Math.round(newY);
                });
                
                // Update position inputs if they exist (show absolute position during drag)
                const posXInput = document.getElementById('positionX');
                const posYInput = document.getElementById('positionY');
                if (posXInput) posXInput.value = Math.round(newX);
                if (posYInput) posYInput.value = Math.round(newY);
            }
            
            // Reapply clipping after drag
            applyCompositionClipping();
        }
        
        function stopLayerDrag() {
            if (draggedLayerElement) {
                draggedLayerElement.style.cursor = 'pointer';
                
                // Re-enable transitions
                draggedLayerElement.classList.remove('dragging');
                
                // Restore original max constraints
                if (draggedLayerElement.dataset.originalMaxWidth !== undefined) {
                    draggedLayerElement.style.maxWidth = draggedLayerElement.dataset.originalMaxWidth;
                    draggedLayerElement.style.maxHeight = draggedLayerElement.dataset.originalMaxHeight;
                    delete draggedLayerElement.dataset.originalMaxWidth;
                    delete draggedLayerElement.dataset.originalMaxHeight;
                }
                
                // Keep dimensions locked after drag based on layer scale
                const layer = layers.find(l => l.id === draggedLayerElement.id);
                if (layer) {
                    const img = draggedLayerElement.querySelector('img');
                    if (img && img.naturalWidth) {
                        const width = img.naturalWidth * (layer.scale / 100);
                        const height = img.naturalHeight * (layer.scale / 100);
                        draggedLayerElement.style.width = `${width}px`;
                        draggedLayerElement.style.height = `${height}px`;
                    }
                    
                    // Update layer position data (already relative to composition-area)
                    if (previewMode === 'stacked') {
                        // Position is already relative to composition-area (the parent)
                        const finalLeft = parseFloat(draggedLayerElement.style.left) || 0;
                        const finalTop = parseFloat(draggedLayerElement.style.top) || 0;
                        
                        // Update position with lock bypass
                        unlockPositions(() => {
                            layer.position.x = finalLeft;
                            layer.position.y = finalTop;
                            layer.positionRelativeToComposition = true;
                        });
                        
                        // Update position inputs if they exist
                        const posXInput = document.getElementById('positionX');
                        const posYInput = document.getElementById('positionY');
                        if (posXInput) posXInput.value = Math.round(layer.position.x);
                        if (posYInput) posYInput.value = Math.round(layer.position.y);
                    } else {
                        // Non-stacked mode: just snap to whole pixels
                        draggedLayerElement.style.left = `${layer.position.x}px`;
                        draggedLayerElement.style.top = `${layer.position.y}px`;
                    }
                }
            }
            
            // Track when drag ended
            lastDragEndTime = Date.now();
            
            // Small delay to prevent click event after drag
            setTimeout(() => {
                isDraggingLayer = false;
            }, 10);
            
            draggedLayerElement = null;
            
            document.removeEventListener('mousemove', onLayerDrag);
            document.removeEventListener('mouseup', stopLayerDrag);
        }
        
        // Zoom
        function zoomIn() {
            zoomValue = Math.min(200, zoomValue + 25);
            updateZoom();
            const zoomDisplay = document.getElementById('zoomSelectDisplay');
            if (zoomDisplay) {
                zoomDisplay.textContent = zoomValue === 100 ? '100%' : `${zoomValue}%`;
            }
        }
        
        function zoomOut() {
            zoomValue = Math.max(25, zoomValue - 25);
            updateZoom();
            const zoomDisplay = document.getElementById('zoomSelectDisplay');
            if (zoomDisplay) {
                zoomDisplay.textContent = zoomValue === 100 ? '100%' : `${zoomValue}%`;
            }
        }
        
        function toggleZoomDropdown() {
            const dropdown = document.getElementById('zoomDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function setZoom(value) {
            const dropdown = document.getElementById('zoomDropdown');
            if (dropdown) dropdown.style.display = 'none';
            
            const zoomDisplay = document.getElementById('zoomSelectDisplay');
            
            if (value === 'fit') {
                zoomToFit();
                // Update display to show "Fit" - will be updated by zoomToFit if needed
                if (zoomDisplay) {
                    // The zoomToFit function will update this, but set it here as well for immediate feedback
                    setTimeout(() => {
                        if (zoomDisplay.textContent !== 'Fit') {
                            // Keep the percentage if fit results in a specific zoom level
                        }
                    }, 50);
                }
            } else {
                zoomValue = parseInt(value);
                updateZoom();
                if (zoomDisplay) {
                    zoomDisplay.textContent = zoomValue === 100 ? '100%' : `${zoomValue}%`;
                }
            }
        }
        
        function updateZoom() {
            const container = document.getElementById('canvasContainer');
            const canvasArea = document.querySelector('.preview-canvas');
            
            // Apply zoom transform with center origin
            container.style.transform = `scale(${zoomValue / 100})`;
            container.style.transformOrigin = 'center center';
            
            // Reapply clipping after zoom (clipping coordinates need to be recalculated)
            setTimeout(() => {
                applyCompositionClipping();
            }, 50);
            
            // Ensure container stays centered in viewport
            if (canvasArea) {
                // Scroll to center after zoom
                setTimeout(() => {
                    const containerRect = container.getBoundingClientRect();
                    const canvasRect = canvasArea.getBoundingClientRect();
                    
                    // Calculate center position
                    const centerX = (containerRect.left + containerRect.width / 2) - canvasRect.left;
                    const centerY = (containerRect.top + containerRect.height / 2) - canvasRect.top;
                    
                    // Scroll to center
                    canvasArea.scrollLeft = centerX - canvasArea.clientWidth / 2;
                    canvasArea.scrollTop = centerY - canvasArea.clientHeight / 2;
                }, 10);
            }
            
            // Update zoom display
            const zoomDisplay = document.getElementById('zoomSelectDisplay');
            if (zoomDisplay) {
                if (zoomValue === 25 || zoomValue === 50 || zoomValue === 75 || zoomValue === 100) {
                    zoomDisplay.textContent = `${zoomValue}%`;
                } else {
                    zoomDisplay.textContent = `${zoomValue}%`;
                }
            }
            
            // Add/remove scroll indicator class
            if (canvasArea) {
                setTimeout(() => {
                    const hasScroll = canvasArea.scrollHeight > canvasArea.clientHeight || 
                                     canvasArea.scrollWidth > canvasArea.clientWidth;
                    if (hasScroll || zoomValue > 100) {
                        canvasArea.classList.add('has-scroll');
                    } else {
                        canvasArea.classList.remove('has-scroll');
                    }
                }, 100);
            }
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('zoomDropdown');
            const wrapper = document.querySelector('.zoom-select-wrapper');
            if (dropdown && wrapper && !wrapper.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });
        
        function zoomToFit() {
            const canvasArea = document.querySelector('.preview-canvas');
            const container = document.getElementById('canvasContainer');
            const elements = Array.from(container.querySelectorAll('.preview-element')).filter(el => el.style.display !== 'none');
            
            // Use composition area if it exists, otherwise use elements
            let targetWidth, targetHeight;
            const composition = container.querySelector('.composition-area');
            
            if (composition) {
                // Use composition dimensions (no padding added to target)
                targetWidth = compositionWidth;
                targetHeight = compositionHeight;
            } else if (elements.length === 0) {
                zoomValue = 100;
                updateZoom();
                const zoomDisplay = document.getElementById('zoomSelectDisplay');
                if (zoomDisplay) zoomDisplay.textContent = '100%';
                return;
            } else if (previewMode === 'stacked') {
                // Reset zoom temporarily to get actual sizes
                const originalTransform = container.style.transform;
                container.style.transform = 'scale(1)';
                
                // Force reflow
                container.offsetHeight;
                
                requestAnimationFrame(() => {
                    // Calculate bounding box of all elements
                    let minX = Infinity, minY = Infinity;
                    let maxX = -Infinity, maxY = -Infinity;
                    
                    elements.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        // Get position relative to container
                        const x = rect.left - containerRect.left;
                        const y = rect.top - containerRect.top;
                        
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x + rect.width);
                        maxY = Math.max(maxY, y + rect.height);
                    });
                    
                    const contentWidth = maxX - minX;
                    const contentHeight = maxY - minY;
                    
                    // Get viewport dimensions (with padding)
                    const viewportWidth = canvasArea.clientWidth - 200;
                    const viewportHeight = canvasArea.clientHeight - 200;
                    
                    // Calculate zoom to fit
                    const zoomWidth = (viewportWidth / contentWidth) * 100;
                    const zoomHeight = (viewportHeight / contentHeight) * 100;
                    
                    // Use the smaller zoom to ensure everything fits - maximize zoom while fitting
                    const calculatedZoom = Math.min(zoomWidth, zoomHeight);
                    zoomValue = Math.max(10, Math.min(500, Math.round(calculatedZoom)));
                    
                    updateZoom();
                    
                    // Update display to show "Fit"
                    const zoomDisplay = document.getElementById('zoomSelectDisplay');
                    if (zoomDisplay) {
                        zoomDisplay.textContent = 'Fit';
                    }
                    
                    // Center view on content
                    setTimeout(() => centerViewOnAssets(), 100);
                });
            }
            // For side-by-side mode
            else if (previewMode === 'side-by-side') {
                // Reset zoom temporarily to get actual sizes
                const originalTransform = container.style.transform;
                container.style.transform = 'scale(1)';
                
                // Force reflow
                container.offsetHeight;
                
                // Wait for next frame to get accurate measurements
                requestAnimationFrame(() => {
                    // Get viewport dimensions with padding (40px on each side = 80px total)
                    const padding = 80;
                    const viewportWidth = canvasArea.clientWidth - padding;
                    const viewportHeight = canvasArea.clientHeight - padding;
                    
                    // Get container dimensions
                    const containerRect = container.getBoundingClientRect();
                    const contentWidth = containerRect.width;
                    const contentHeight = containerRect.height;
                    
                    // Calculate zoom to fit both dimensions - maximize zoom while fitting
                    const zoomWidth = (viewportWidth / contentWidth) * 100;
                    const zoomHeight = (viewportHeight / contentHeight) * 100;
                    
                    // Use the smaller zoom to ensure everything fits, maximize zoom (allow up to 500%)
                    const calculatedZoom = Math.min(zoomWidth, zoomHeight);
                    zoomValue = Math.max(10, Math.min(500, Math.round(calculatedZoom)));
                    
                    updateZoom();
                    
                    // Update display to show "Fit"
                    const zoomDisplay = document.getElementById('zoomSelectDisplay');
                    if (zoomDisplay) {
                        zoomDisplay.textContent = 'Fit';
                    }
                });
            } else {
                // For stacked mode with composition, calculate zoom to fit composition
                if (composition && previewMode === 'stacked' && canvasArea) {
                    // Get viewport dimensions with reasonable padding (40px on each side = 80px total)
                    const padding = 80;
                    const viewportWidth = canvasArea.clientWidth - padding;
                    const viewportHeight = canvasArea.clientHeight - padding;
                    
                    // Calculate zoom ratios - use the smaller one to ensure everything fits
                    const zoomWidth = (viewportWidth / targetWidth) * 100;
                    const zoomHeight = (viewportHeight / targetHeight) * 100;
                    
                    // Use the smaller zoom to ensure composition fits, maximize zoom (no upper limit, but cap at reasonable max)
                    const calculatedZoom = Math.min(zoomWidth, zoomHeight);
                    zoomValue = Math.max(10, Math.min(500, Math.round(calculatedZoom))); // Allow zoom up to 500% if needed
                    
                    updateZoom();
                    
                    // Update display - show "Fit" to indicate fit mode is active
                    const zoomDisplay = document.getElementById('zoomSelectDisplay');
                    if (zoomDisplay) {
                        // Show "Fit" to indicate this is the fit zoom level
                        zoomDisplay.textContent = 'Fit';
                    }
                    
                    // Center the view after zooming
                    setTimeout(() => {
                        centerViewOnAssets();
                    }, 100);
                } else {
                    // Keep 100% for few assets
                    zoomValue = 100;
                    updateZoom();
                }
            }
        }
        
        function zoomToFitStacked() {
            // For stacked mode with fixed canvas, just use 100% zoom
            zoomValue = 100;
            updateZoom();
        }
        
        // Play animations
        function playAllAnimations() {
            console.log('â–¶ï¸ Play button clicked');
            console.log('ðŸ“Š Layers:', layers.length);
            console.log('ðŸ“Š Layers data:', layers.map(l => ({
                id: l.id,
                name: l.name,
                category: l.category,
                pattern: l.pattern,
                duration: l.duration,
                delay: l.delay,
                effectsIn: l.effectsIn
            })));
            
            if (layers.length === 0) {
                alert('Please add layers first!');
                return;
            }
            
            const hasPatterns = layers.some(l => l.pattern);
            console.log('ðŸ“Š Has patterns:', hasPatterns);
            if (!hasPatterns) {
                alert('Please set animation patterns for your layers!');
                return;
            }
            
            // Toggle play/pause
            if (isPlaying) {
                // Pause
                isPlaying = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                const playBtn = document.getElementById('playBtn');
                if (playBtn) {
                    playBtn.innerHTML = '<svg width="12" height="16" viewBox="0 0 12 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.33334 9C2.59696 9 0.390525 8.55228 0.390525 8C0.390525 7.44771 -0.345854 7 0.390525 7L7.44772 7L0.390528 1.70711C-0.130172 1.31658 -0.130172 0.683418 0.390528 0.292893C0.911226 -0.0976313 1.75545 -0.0976314 2.27615 0.292893L11.6095 7.29289C12.1302 7.68342 12.1302 8.31658 11.6095 8.70711L2.27614 15.7071C1.75544 16.0976 0.911223 16.0976 0.390525 15.7071C-0.130175 15.3166 -0.130175 14.6834 0.390525 14.2929L7.44772 9L3.33334 9Z" fill="currentColor"/><path d="M-0.000104712 0.999998L8.9999 6.5V9L-0.000104712 15V0.999998Z" fill="currentColor"/></svg>';
                }
                // Stop all animations but keep current state
                layers.forEach(layer => {
                    const element = document.getElementById(layer.id);
                    if (element) {
                        element.style.animationPlayState = 'paused';
                    }
                });
            } else {
                // Play - start from current playhead position
                // Find max duration
                let maxDuration = 0;
                layers.forEach(layer => {
                    if (layer.pattern) {
                        const duration = layer.duration;
                        const delay = layer.delay;
                        maxDuration = Math.max(maxDuration, duration + delay);
                    }
                });
                
                // If we're at the end, reset to beginning
                if (currentPlayTime >= maxDuration) {
                    currentPlayTime = 0;
                }
                
                isPlaying = true;
                playStartTime = performance.now() - currentPlayTime;
                const playBtn = document.getElementById('playBtn');
                if (playBtn) {
                    playBtn.innerHTML = '<svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12C8.44 12 8 11.56 8 11V1C8 0.44 8.44 0 9 0C9.56 0 10 0.44 10 1V11C10 11.56 9.56 12 9 12Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M1 12C0.44 12 0 11.56 0 11V1C0 0.44 0.44 0 1 0C1.56 0 2 0.44 2 1V11C2 11.56 1.56 12 1 12Z" fill="currentColor"/></svg>';
                }
                
                // Restart animations from current position
                console.log('ðŸŽ¬ Starting animations for', layers.filter(l => l.pattern).length, 'layers');
                layers.forEach(layer => {
                    if (layer.pattern) {
                        const layerStartTime = layer.delay;
                        const layerEndTime = layer.delay + layer.duration;
                        
                        console.log(`ðŸŽ¬ Processing layer ${layer.id}:`, {
                            pattern: layer.pattern,
                            delay: layer.delay,
                            duration: layer.duration,
                            currentPlayTime: currentPlayTime,
                            layerStartTime: layerStartTime,
                            layerEndTime: layerEndTime
                        });
                        
                        if (currentPlayTime < layerStartTime) {
                            // Animation hasn't started yet
                            console.log(`â³ Layer ${layer.id} hasn't started yet, calling animateLayer`);
                            animateLayer(layer);
                        } else if (currentPlayTime >= layerEndTime) {
                            // Animation already finished - show final state
                            console.log(`âœ… Layer ${layer.id} already finished`);
                            const element = document.getElementById(layer.id);
                            if (element) {
                                element.style.animation = 'none';
                            }
                        } else {
                            // Animation is in progress - restart with adjusted delay
                            const progress = (currentPlayTime - layerStartTime) / layer.duration;
                            const adjustedDelay = -(layer.duration * progress);
                            console.log(`â–¶ï¸ Layer ${layer.id} in progress, restarting with adjusted delay:`, adjustedDelay);
                            animateLayer(layer, false, adjustedDelay);
                        }
                    } else {
                        console.log(`âš ï¸ Layer ${layer.id} has no pattern, skipping`);
                    }
                });
                
                // Start animation loop
                console.log('ðŸ”„ Starting animation loop');
                function updatePlayback() {
                    if (!isPlaying) {
                        console.log('â¸ï¸ Animation loop stopped (isPlaying = false)');
                        return;
                    }
                    
                    const now = performance.now();
                    currentPlayTime = now - playStartTime;
                    
                    // Update visual state during playback (live preview)
                    scrubToTime(currentPlayTime, true);
                    
                    // Check if we've reached the end
                    if (currentPlayTime >= maxDuration) {
                        console.log('ðŸ Animation finished, maxDuration:', maxDuration);
                        isPlaying = false;
                        currentPlayTime = maxDuration;
                        updatePlayheadPosition();
                        // Show final state
                        scrubToTime(maxDuration, true);
                        const playBtn = document.getElementById('playBtn');
                        if (playBtn) {
                            playBtn.innerHTML = '<svg width="12" height="16" viewBox="0 0 12 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.33334 9C2.59696 9 0.390525 8.55228 0.390525 8C0.390525 7.44771 -0.345854 7 0.390525 7L7.44772 7L0.390528 1.70711C-0.130172 1.31658 -0.130172 0.683418 0.390528 0.292893C0.911226 -0.0976313 1.75545 -0.0976314 2.27615 0.292893L11.6095 7.29289C12.1302 7.68342 12.1302 8.31658 11.6095 8.70711L2.27614 15.7071C1.75544 16.0976 0.911223 16.0976 0.390525 15.7071C-0.130175 15.3166 -0.130175 14.6834 0.390525 14.2929L7.44772 9L3.33334 9Z" fill="currentColor"/><path d="M-0.000104712 0.999998L8.9999 6.5V9L-0.000104712 15V0.999998Z" fill="currentColor"/></svg>';
                        }
                        return;
                    }
                    
                    animationFrameId = requestAnimationFrame(updatePlayback);
                    if (animationFrameId) {
                        console.log('ðŸ”„ Animation frame requested, ID:', animationFrameId);
                    }
                }
                
                console.log('ðŸš€ Starting initial animation frame');
                animationFrameId = requestAnimationFrame(updatePlayback);
                if (animationFrameId) {
                    console.log('âœ… Initial animation frame requested, ID:', animationFrameId);
                } else {
                    console.error('âŒ Failed to request initial animation frame');
                }
            }
        }
        
        function animateLayer(layer, applyFinalStateOnly = false, adjustedDelay = null) {
            console.log('ðŸŽ¬ animateLayer called:', {
                layerId: layer.id,
                name: layer.name,
                category: layer.category,
                pattern: layer.pattern,
                duration: layer.duration,
                delay: layer.delay,
                effectsIn: layer.effectsIn,
                applyFinalStateOnly: applyFinalStateOnly,
                adjustedDelay: adjustedDelay
            });
            
            const element = document.getElementById(layer.id);
            if (!element) {
                console.error('âŒ Element not found for layer:', layer.id);
                return;
            }
            
            let pattern = layer.pattern;
            
            if (!layer.category || !pattern || !patternCategories[layer.category] || !patternCategories[layer.category][pattern]) {
                console.error('âŒ Invalid pattern data:', {
                    category: layer.category,
                    pattern: pattern,
                    categoryExists: !!patternCategories[layer.category],
                    patternExists: !!(patternCategories[layer.category] && patternCategories[layer.category][pattern])
                });
                return;
            }
            
            const patternData = patternCategories[layer.category][pattern];
            console.log('âœ… Pattern data found:', patternData);
            const duration = layer.duration;
            const easing = layer.easing || patternData.easing;
            const delay = adjustedDelay !== null ? adjustedDelay : layer.delay;
            
            // Apply effects to determine "from" and "to" states
            let fromTransform = '';
            let toTransform = '';
            let fromOpacity = '1';
            let toOpacity = '1';
            let fromFilter = '';
            let toFilter = '';
            let fromRadius = '';
            let toRadius = '';
            let finalEasing = easing;
            
            // Process effects (always use 'in' state)
            if (layer.effectsIn && layer.effectsIn.length > 0) {
                layer.effectsIn.forEach(effect => {
                    // Validate effect structure before accessing nested properties
                    if (!effect || !effect.type || !effect.from || !effect.to) {
                        console.warn('âš ï¸ Invalid effect structure:', effect);
                        return;
                    }
                    
                    // Check if effectValues[effect.type] exists
                    if (!effectValues[effect.type]) {
                        console.warn('âš ï¸ Effect type not found in effectValues:', effect.type);
                        return;
                    }
                    
                    // Convert numeric values to strings for object key access
                    const fromKey = String(effect.from);
                    const toKey = String(effect.to);
                    
                    // Check if the specific values exist
                    if (!effectValues[effect.type][fromKey] || !effectValues[effect.type][toKey]) {
                        console.warn('âš ï¸ Effect values not found:', {
                            type: effect.type,
                            from: effect.from,
                            to: effect.to,
                            fromKey: fromKey,
                            toKey: toKey,
                            availableKeys: Object.keys(effectValues[effect.type] || {}),
                            fromExists: !!effectValues[effect.type]?.[fromKey],
                            toExists: !!effectValues[effect.type]?.[toKey]
                        });
                        return;
                    }
                    
                    const fromValue = effectValues[effect.type][fromKey];
                    const toValue = effectValues[effect.type][toKey];
                    
                    switch(effect.type) {
                        case 'scale':
                            fromTransform += ` scale(${fromValue})`;
                            toTransform += ` scale(${toValue})`;
                            break;
                        case 'scaleY':
                            fromTransform += ` scaleY(${fromValue})`;
                            toTransform += ` scaleY(${toValue})`;
                            break;
                        case 'rotation':
                            fromTransform += ` rotate(${fromValue})`;
                            toTransform += ` rotate(${toValue})`;
                            break;
                        case 'translateY':
                            fromTransform += ` translateY(${fromValue})`;
                            toTransform += ` translateY(${toValue})`;
                            break;
                        case 'translateX':
                            fromTransform += ` translateX(${fromValue})`;
                            toTransform += ` translateX(${toValue})`;
                            break;
                        case 'blur':
                            fromFilter += ` blur(${fromValue})`;
                            toFilter += ` blur(${toValue})`;
                            
                            // Add padding to prevent blur clipping (similar to shadow fix)
                            const blurValue = parseFloat(toValue) || parseFloat(fromValue) || 0;
                            if (blurValue > 0) {
                                // Calculate padding needed for blur (blur extends beyond edges)
                                const blurPadding = Math.max(blurValue * 2, 20); // At least 2x blur radius or 20px
                                
                                // Store original padding if not already stored
                                if (!element.dataset.blurPadding) {
                                    element.dataset.originalPadding = element.style.padding || '0';
                                    element.dataset.blurPadding = blurPadding;
                                }
                                
                                // Apply padding
                                element.style.padding = `${blurPadding}px`;
                                element.style.overflow = 'visible';
                                
                                // Ensure parent containers allow overflow
                                let parent = element.parentElement;
                                while (parent && parent !== document.body) {
                                    if (parent.classList.contains('composition-area') || parent.classList.contains('canvas-container')) {
                                        parent.style.overflow = 'visible';
                                    }
                                    parent = parent.parentElement;
                                }
                            }
                            break;
                        case 'alpha':
                        case 'opacity':
                            fromOpacity = fromValue;
                            toOpacity = toValue;
                            break;
                        case 'radius':
                            fromRadius = fromValue;
                            toRadius = toValue;
                            break;
                        case 'spring':
                            finalEasing = toValue;
                            
                            // Spring animations need longer duration to show bounce effect
                            // Minimum 400ms for gentle spring, 500ms+ for bouncy spring
                            const springDuration = layer.duration || 300;
                            const minSpringDuration = toValue.includes('1.56') ? 500 : 400; // Bouncy needs more time
                            
                            if (springDuration < minSpringDuration) {
                                console.log(`âš ï¸ Spring animation duration (${springDuration}ms) is too short for bounce effect. Minimum: ${minSpringDuration}ms`);
                                // Note: We can't change duration here as it's already set, but we log a warning
                                // The user should increase duration in the UI for best spring effect
                            }
                            
                            // Ensure spring is applied to transform properties (scale/translate) for best bounce effect
                            // If no transform effects exist, add a subtle scale for bounce visibility
                            if (!fromTransform && !toTransform) {
                                console.log('ðŸ’¡ Spring easing works best with scale or translate effects. Consider adding scale effect for visible bounce.');
                            }
                            break;
                        default:
                            console.warn('âš ï¸ Unknown effect type:', effect.type);
                            break;
                    }
                });
            }
            
            // Reset - always start from pattern initial state + effect "from" values
            element.style.transition = 'none';
            let initialTransform = patternData.transform || '';
            element.style.transform = initialTransform + fromTransform || 'none';
            element.style.opacity = patternData.opacity !== undefined ? patternData.opacity : fromOpacity;
            element.style.filter = fromFilter || 'none';
            element.style.borderRadius = fromRadius || '';
            
            if (patternData.transformOrigin) {
                element.style.transformOrigin = patternData.transformOrigin;
            }
            
            // Force reflow
            void element.offsetWidth;
            
            // Animate
            // For spring easing, ensure minimum duration for bounce visibility
            let animationDuration = duration;
            if (finalEasing && (finalEasing.includes('1.2') || finalEasing.includes('1.56'))) {
                // Spring easing detected - ensure minimum duration
                const minDuration = finalEasing.includes('1.56') ? 500 : 400; // Bouncy needs more time
                if (animationDuration < minDuration) {
                    console.log(`âš ï¸ Spring animation duration (${animationDuration}ms) increased to ${minDuration}ms for bounce visibility`);
                    animationDuration = minDuration;
                }
            }
            
            element.style.transition = `all ${animationDuration}ms ${finalEasing} ${delay}ms`;
            
            setTimeout(() => {
                // Always animate to normal state + effect "to" values
                element.style.transform = toTransform || 'none';
                element.style.opacity = toOpacity;
                element.style.filter = toFilter || 'none';
                element.style.borderRadius = toRadius || '';
                
                // Remove blur padding if blur is removed (toFilter is 'none' or empty)
                if ((!toFilter || toFilter === 'none') && element.dataset.blurPadding) {
                    element.style.padding = element.dataset.originalPadding || '0';
                    delete element.dataset.originalPadding;
                    delete element.dataset.blurPadding;
                }
            }, 50);

        }
        
        function resetAll() {
            if (confirm('This will remove all layers and start fresh. Continue?')) {
                // Clear all canvas elements
                const container = document.getElementById('canvasContainer');
                container.innerHTML = '<div class="empty-state"><div class="empty-state-greeting"><span>Hello Qontoer</span><span class="empty-state-emoji">ðŸ‘‹ðŸ¼</span></div><div class="empty-state-dropzone" id="emptyStateDropzone" onclick="document.getElementById(\'fileInput\').click();"><div class="dropzone-text">Add your images or svg</div><div class="dropzone-subtext">Drag and drop here, or click to browse</div></div></div>';
                setupDropzoneHandlers();
                
                // Clear all data
                layers = [];
                layerGroups = {};
                collapsedFolders = new Set();
                selectedLayerId = null;
                
                // Reset playhead
                currentPlayTime = 0;
                isPlaying = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                // Clear UI
                renderLayersPanel();
                document.getElementById('propertiesContent').innerHTML = '';
                document.getElementById('suggestionBanner').innerHTML = '';
                
                updateTimeline();
            }
        }
        
        function setupPlayheadDrag() {
            const playhead = document.getElementById('timelinePlayhead');
            const canvas = document.getElementById('timelineCanvas');
            if (!playhead || !canvas) return;
            
            let dragStartX = 0;
            let dragStartTime = 0;
            
            playhead.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDraggingPlayhead = true;
                dragStartX = e.clientX;
                dragStartTime = currentPlayTime;
                playhead.classList.add('dragging');
                
                // Pause playback if playing
                const wasPlaying = isPlaying;
                if (isPlaying) {
                    playAllAnimations(); // Toggle to pause
                }
                
                const handleMouseMove = (e) => {
                    if (!isDraggingPlayhead) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const newTime = Math.max(0, x / pixelsPerMs);
                    
                    scrubToTime(newTime, true); // Pass true to skip animation restart
                };
                
                const handleMouseUp = () => {
                    isDraggingPlayhead = false;
                    playhead.classList.remove('dragging');
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
        }
        
        function setupTimelineScrub() {
            const canvas = document.getElementById('timelineCanvas');
            if (!canvas) return;
            
            canvas.addEventListener('click', (e) => {
                // Don't scrub if clicking on playhead or animation bars
                if (e.target.closest('.timeline-playhead') || 
                    e.target.closest('.animation-bar') ||
                    e.target.closest('.resize-handle')) {
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const timeMs = x / pixelsPerMs;
                
                scrubToTime(timeMs);
            });
        }
        
        // Timeline
        // Function to update all layer positions relative to composition area
        // NOTE: Assets are now inside composition-area, so they move naturally with it.
        // This function is mainly for converting legacy positions and ensuring consistency.
        function updateAllLayerPositions() {
            if (previewMode !== 'stacked') return;
            
            const container = document.getElementById('canvasContainer');
            const composition = container ? container.querySelector('.composition-area') : null;
            if (!composition) {
                console.log('updateAllLayerPositions: No composition found');
                return;
            }
            
            const compWidth = composition.offsetWidth;
            const compHeight = composition.offsetHeight;
            
            console.log('ðŸ”„ updateAllLayerPositions: Composition size', { 
                compWidth: compWidth.toFixed(1), 
                compHeight: compHeight.toFixed(1) 
            }, 'updating', layers.length, 'layers');
            console.trace('ðŸ”„ updateAllLayerPositions called from:'); // Show who called this
            
            layers.forEach(layer => {
                const element = document.getElementById(layer.id);
                if (!element || !layer.position) return;
                
                // Ensure element is inside composition-area (should be, but check for legacy elements)
                if (element.parentElement !== composition) {
                    console.warn('âš ï¸ Layer element not inside composition-area, moving it:', layer.id);
                    composition.appendChild(element);
                }
                
                // Ensure layer has positionRelativeToComposition flag
                if (!layer.positionRelativeToComposition) {
                    console.warn('âš ï¸ Layer missing positionRelativeToComposition flag, converting:', layer.id);
                    // Position is already relative to composition-area, so just set the flag
                    layer.positionRelativeToComposition = true;
                }
                
                // Only update if position actually needs updating (don't move layers that are already correct)
                const currentLeft = parseFloat(element.style.left) || 0;
                const currentTop = parseFloat(element.style.top) || 0;
                const needsUpdate = Math.abs(currentLeft - layer.position.x) > 0.1 || Math.abs(currentTop - layer.position.y) > 0.1;
                
                if (needsUpdate) {
                    // Position relative to composition-area (which is position: relative)
                    // Check if this is a centered element (position is at composition center)
                    const hasTransform = element.style.transform && element.style.transform.includes('translate');
                    const isCentered = hasTransform || (Math.abs(layer.position.x - compWidth / 2) < 1 && Math.abs(layer.position.y - compHeight / 2) < 1);
                    
                    const beforeLeft = element.style.left;
                    const beforeTop = element.style.top;
                    
                    // Position is relative to composition-area, not container
                    element.style.left = `${layer.position.x}px`;
                    element.style.top = `${layer.position.y}px`;
                    element.style.transform = isCentered ? 'translate(-50%, -50%)' : '';
                    
                    console.log(`  ðŸ“ Updated ${layer.name}:`, {
                        relative: { x: layer.position.x.toFixed(1), y: layer.position.y.toFixed(1) },
                        before: { left: beforeLeft, top: beforeTop },
                        after: { left: element.style.left, top: element.style.top },
                        isCentered: isCentered
                    });
                }
            });
        }
        
        // Function to convert all existing layers to composition-relative positioning
        function convertAllLayersToCompositionRelative() {
            if (previewMode !== 'stacked') return;
            
            const container = document.getElementById('canvasContainer');
            const composition = container ? container.querySelector('.composition-area') : null;
            if (!composition) return;
            
            const containerRect = container.getBoundingClientRect();
            const compRect = composition.getBoundingClientRect();
            const compLeft = compRect.left - containerRect.left;
            const compTop = compRect.top - containerRect.top;
            
            layers.forEach(layer => {
                const element = document.getElementById(layer.id);
                if (!element || !layer.position) return;
                
                // Skip if already converted
                if (layer.positionRelativeToComposition) return;
                
                // Convert existing position to composition-relative
                // Read the actual rendered position from the element
                const elementRect = element.getBoundingClientRect();
                const hasTransform = element.style.transform && element.style.transform.includes('translate');
                
                if (hasTransform) {
                    // Element is centered - get center position relative to composition
                    const elementCenterX = elementRect.left - containerRect.left + (elementRect.width / 2);
                    const elementCenterY = elementRect.top - containerRect.top + (elementRect.height / 2);
                    layer.position.x = elementCenterX - compLeft;
                    layer.position.y = elementCenterY - compTop;
                } else {
                    // Top-left positioning - get top-left relative to composition
                    const elementLeft = elementRect.left - containerRect.left;
                    const elementTop = elementRect.top - containerRect.top;
                    layer.position.x = elementLeft - compLeft;
                    layer.position.y = elementTop - compTop;
                }
                
                layer.positionRelativeToComposition = true;
            });
        }
        
        function toggleTimeline() {
            // Prevent toggle during drag or within 100ms after drag
            if (isDraggingLayer || (Date.now() - lastDragEndTime < 100)) {
                console.log('ðŸš« toggleTimeline: Blocked during/after drag');
                return;
            }
            
            const wasOpen = timelineOpen;
            console.log('ðŸŽ¬ toggleTimeline:', wasOpen ? 'CLOSING' : 'OPENING');
            
            // Read composition position BEFORE transition starts (BEFORE we toggle timelineOpen)
            const canvasContainer = document.getElementById('canvasContainer');
            const composition = canvasContainer ? canvasContainer.querySelector('.composition-area') : null;
            let compTopBefore = null;
            if (composition && previewMode === 'stacked') {
                const containerRectBefore = canvasContainer.getBoundingClientRect();
                const compRectBefore = composition.getBoundingClientRect();
                compTopBefore = compRectBefore.top - containerRectBefore.top;
                console.log(`ðŸŽ¬ Composition position BEFORE transition: ${compTopBefore.toFixed(1)}px`);
            }
            
            timelineOpen = !timelineOpen;
            const container = document.getElementById('timelineContainer');
            const btn = document.getElementById('showTimelineBtn');
            const appContainer = document.querySelector('.app-container');
            
            if (timelineOpen) {
                container.classList.remove('hidden');
                btn.classList.add('hidden');
                appContainer.classList.add('timeline-open');
                updateTimeline();
            } else {
                container.classList.add('hidden');
                btn.classList.remove('hidden');
                appContainer.classList.remove('timeline-open');
            }
            
            // Assets are now inside composition-area, so they move naturally with it
            // No manual position updates needed - flexbox centering handles everything!
            // In side-by-side mode, DON'T reposition layers - they should stay in their grids
            if (previewMode === 'side-by-side') {
                // Don't call renderComposition() or positionLayersInSquares()
                // Layers are already positioned correctly in their grids
                console.log('ðŸŽ¬ Timeline toggled in side-by-side mode - layers stay in place');
            }
        }
        
        function updatePlayheadPosition() {
            const playhead = document.getElementById('timelinePlayhead');
            const tooltip = document.getElementById('playheadTooltip');
            if (!playhead || !timelineOpen) return;
            
            const position = currentPlayTime * pixelsPerMs;
            playhead.style.left = `${position}px`;
            
            // Update tooltip with current time
            if (tooltip) {
                tooltip.textContent = `${Math.round(currentPlayTime)}ms`;
            }
        }
        
        function scrubToTime(timeMs, skipAnimation = false) {
            currentPlayTime = Math.max(0, timeMs);
            updatePlayheadPosition();
            
            // Update animations to reflect the scrubbed position
            if (isPlaying && !skipAnimation) {
                // If playing, restart from this position
                playStartTime = performance.now() - currentPlayTime;
            } else {
                // If paused or scrubbing, show the state at this exact time
                layers.forEach(layer => {
                    const element = document.getElementById(layer.id);
                    if (!element || !layer.pattern) return;
                    
                    const layerStartTime = layer.delay;
                    const layerEndTime = layer.delay + layer.duration;
                    
                    // Stop current animation completely
                    element.style.animation = 'none';
                    element.style.animationPlayState = 'paused';
                    
                    if (currentPlayTime < layerStartTime) {
                        // Before animation starts - show initial state
                        // Reset to initial state based on pattern
                        resetLayerToInitialState(layer);
                    } else if (currentPlayTime >= layerEndTime) {
                        // After animation ends - show final state
                        resetLayerToFinalState(layer);
                    } else {
                        // During animation - calculate exact progress and show intermediate state
                        const progress = Math.min(1, Math.max(0, (currentPlayTime - layerStartTime) / layer.duration));
                        showLayerAtProgress(layer, progress);
                    }
                });
            }
        }
        
        function resetLayerToInitialState(layer) {
            const element = document.getElementById(layer.id);
            if (!element) return;
            
            // Reset based on pattern type
            let pattern = layer.pattern;
            const patternData = patternCategories[layer.category]?.[pattern];
            
            // Get current transform to preserve translate/position
            const currentTransform = element.style.transform || '';
            const translateMatch = currentTransform.match(/translate\([^)]*\)/);
            const translateValue = translateMatch ? translateMatch[0] : '';
            
            // Build transform, opacity, filter, and borderRadius from effects
            let transform = '';
            let opacity = '1';
            let filter = '';
            let borderRadius = '';
            
            // Start with pattern initial state
            if (patternData) {
                transform = patternData.transform || '';
                opacity = patternData.opacity !== undefined ? patternData.opacity : '1';
            }
            
            // Apply effect "from" values (always use 'in' state)
            if (layer.effectsIn && layer.effectsIn.length > 0) {
                layer.effectsIn.forEach(effect => {
                    const fromValue = effectValues[effect.type]?.[effect.from];
                    if (fromValue !== undefined) {
                        switch(effect.type) {
                            case 'alpha':
                                opacity = fromValue;
                                break;
                            case 'scale':
                                transform += ` scale(${fromValue})`;
                                break;
                            case 'rotation':
                                transform += ` rotate(${fromValue})`;
                                break;
                            case 'blur':
                                filter += ` blur(${fromValue})`;
                                break;
                            case 'radius':
                                borderRadius = fromValue;
                                break;
                        }
                    }
                });
            }
            
            // Combine translate with animation transform
            const finalTransform = translateValue ? `${translateValue} ${transform}`.trim() : transform;
            
            // Apply styles
            element.style.transform = finalTransform || 'none';
            element.style.opacity = opacity;
            element.style.filter = filter || 'none';
            element.style.borderRadius = borderRadius || '';
        }
        
        function resetLayerToFinalState(layer) {
            const element = document.getElementById(layer.id);
            if (!element) return;
            
            // Get current transform to preserve translate/position
            const currentTransform = element.style.transform || '';
            const translateMatch = currentTransform.match(/translate\([^)]*\)/);
            const translateValue = translateMatch ? translateMatch[0] : '';
            
            // Build transform, opacity, filter, and borderRadius from effects
            let transform = '';
            let opacity = '1';
            let filter = '';
            let borderRadius = '';
            
            // Apply effect "to" values (always use 'in' state)
            if (layer.effectsIn && layer.effectsIn.length > 0) {
                layer.effectsIn.forEach(effect => {
                    const toValue = effectValues[effect.type]?.[effect.to];
                    if (toValue !== undefined) {
                        switch(effect.type) {
                            case 'alpha':
                                opacity = toValue;
                                break;
                            case 'scale':
                                transform += ` scale(${toValue})`;
                                break;
                            case 'rotation':
                                transform += ` rotate(${toValue})`;
                                break;
                            case 'blur':
                                filter += ` blur(${toValue})`;
                                break;
                            case 'radius':
                                borderRadius = toValue;
                                break;
                        }
                    }
                });
            }
            
            // Combine translate with animation transform
            const finalTransform = translateValue ? `${translateValue} ${transform}`.trim() : transform;
            
            // Apply styles
            element.style.transform = finalTransform || 'none';
            element.style.opacity = opacity;
            element.style.filter = filter || 'none';
            element.style.borderRadius = borderRadius || '';
        }
        
        function showLayerAtProgress(layer, progress) {
            const element = document.getElementById(layer.id);
            if (!element) return;
            
            // Get pattern data
            let pattern = layer.pattern;
            const patternData = patternCategories[layer.category]?.[pattern];
            
            // Get current transform to preserve translate/position
            const currentTransform = element.style.transform || '';
            const translateMatch = currentTransform.match(/translate\([^)]*\)/);
            const translateValue = translateMatch ? translateMatch[0] : '';
            
            // Build transform, opacity, filter, and borderRadius
            let transform = '';
            let opacity = '1';
            let filter = '';
            let borderRadius = '';
            
            // Start with pattern initial state
            if (patternData) {
                transform = patternData.transform || '';
                opacity = patternData.opacity !== undefined ? patternData.opacity : '1';
            }
            
            // Interpolate between from and to values based on progress (always use 'in' state)
            if (layer.effectsIn && layer.effectsIn.length > 0) {
                layer.effectsIn.forEach(effect => {
                    const fromValue = effectValues[effect.type]?.[effect.from];
                    const toValue = effectValues[effect.type]?.[effect.to];
                    
                    if (fromValue !== undefined && toValue !== undefined) {
                        // Parse numeric values for interpolation
                        let fromNum, toNum;
                        
                        switch(effect.type) {
                            case 'alpha':
                                fromNum = parseFloat(fromValue);
                                toNum = parseFloat(toValue);
                                opacity = fromNum + (toNum - fromNum) * progress;
                                break;
                            case 'scale':
                                fromNum = parseFloat(fromValue);
                                toNum = parseFloat(toValue);
                                transform += ` scale(${fromNum + (toNum - fromNum) * progress})`;
                                break;
                            case 'rotation':
                                fromNum = parseFloat(fromValue.replace('deg', ''));
                                toNum = parseFloat(toValue.replace('deg', ''));
                                transform += ` rotate(${fromNum + (toNum - fromNum) * progress}deg)`;
                                break;
                            case 'blur':
                                fromNum = parseFloat(fromValue.replace('px', ''));
                                toNum = parseFloat(toValue.replace('px', ''));
                                filter += ` blur(${fromNum + (toNum - fromNum) * progress}px)`;
                                break;
                            case 'radius':
                                // Handle both px and % values
                                if (fromValue.includes('%') || toValue.includes('%')) {
                                    borderRadius = progress < 0.5 ? fromValue : toValue;
                                } else {
                                    fromNum = parseFloat(fromValue.replace('px', ''));
                                    toNum = parseFloat(toValue.replace('px', ''));
                                    borderRadius = `${fromNum + (toNum - fromNum) * progress}px`;
                                }
                                break;
                        }
                    }
                });
            }
            
            // Combine translate with animation transform
            const finalTransform = translateValue ? `${translateValue} ${transform}`.trim() : transform;
            
            // Apply styles
            element.style.transform = finalTransform || 'none';
            element.style.opacity = opacity;
            element.style.filter = filter || 'none';
            element.style.borderRadius = borderRadius || '';
        }
        
        function animateLayerAtTime(layer, progress) {
            // This will be called during scrubbing to show intermediate states
            // For now, we'll just restart the animation with adjusted delay
            const element = document.getElementById(layer.id);
            if (!element) return;
            
            // Calculate the adjusted delay to show the animation at this progress
            const adjustedDelay = -(layer.duration * progress);
            animateLayer(layer, false, adjustedDelay);
        }
        
        function updateTimeline() {
            if (!timelineOpen) return;
            
            const labelsContainer = document.getElementById('timelineLabels');
            const rulerContainer = document.getElementById('timelineRuler');
            const tracksContainer = document.getElementById('timelineTracks');
            
            // Clear
            labelsContainer.innerHTML = '';
            rulerContainer.innerHTML = '';
            tracksContainer.innerHTML = '';
            
            // Update playhead position
            updatePlayheadPosition();
            
            // Setup playhead drag handlers
            setupPlayheadDrag();
            
            // Setup timeline canvas click handler for scrubbing
            setupTimelineScrub();
            
            // Add spacer to labels to align with ruler
            const spacer = document.createElement('div');
            spacer.className = 'timeline-labels-spacer';
            labelsContainer.appendChild(spacer);
            
            // Render ruler
            for (let i = 0; i <= 3000; i += 250) {
                const mark = document.createElement('div');
                mark.className = 'ruler-mark';
                mark.style.left = `${i * pixelsPerMs}px`;
                mark.innerHTML = `<span>${i}ms</span>`;
                rulerContainer.appendChild(mark);
            }
            
            // Color palette from Qonto design tokens (blue shades)
            const timelineColors = [
                '#C6E6FB', // blue-100
                '#A8D9F8', // blue-200
                '#8ACCF5', // blue-300
                '#6CBFF2', // blue-400
                '#4EB2EF', // blue-500
                '#30A5EC', // blue-600
                '#1298E9', // blue-700
                '#0F7AB8', // blue-800
            ];
            
            // Render tracks
            layers.forEach((layer, index) => {
                // Label with double-click rename and click to select
                const label = document.createElement('div');
                label.className = 'timeline-track-label';
                label.textContent = layer.name;
                label.dataset.layerId = layer.id;
                
                // Click to select with highlight
                label.addEventListener('click', () => {
                    selectLayer(layer.id);
                    // Add highlight to timeline label
                    setTimeout(() => {
                        document.querySelectorAll('.timeline-track-label').forEach(l => {
                            l.classList.remove('selected');
                        });
                        label.classList.add('selected');
                    }, 0);
                });
                
                // Double-click to rename
                label.addEventListener('dblclick', () => {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = layer.name;
                    input.className = 'timeline-label-input';
                    input.style.cssText = 'width: 100%; padding: 4px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg); color: var(--text-primary);';
                    
                    const finishRename = () => {
                        const newName = input.value.trim();
                        if (newName && newName !== layer.name) {
                            layer.name = newName;
                            renderLayersPanel();
                            updateTimeline();
                        } else {
                            label.textContent = layer.name;
                        }
                    };
                    
                    input.addEventListener('blur', finishRename);
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            finishRename();
                        } else if (e.key === 'Escape') {
                            label.textContent = layer.name;
                        }
                    });
                    
                    label.innerHTML = '';
                    label.appendChild(input);
                    input.focus();
                    input.select();
                });
                
                // Add eye icon for visibility (same as layers panel)
                const eyeIcon = document.createElement('span');
                eyeIcon.className = 'timeline-eye-icon';
                eyeIcon.title = layer.visible ? 'Hide layer' : 'Show layer';
                eyeIcon.innerHTML = layer.visible ? 
                    '<svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 12.0088C18.2007 12.0088 20.0013 13.8093 20.0013 16.01C20.0013 18.2107 18.2007 20.0113 16 20.0113C13.7993 20.0113 11.9987 18.2107 11.9987 16.01C11.9987 13.8093 13.7993 12.0088 16 12.0088ZM16 10.0081C12.679 10.0081 9.99812 12.689 9.99812 16.01C9.99812 19.331 12.679 22.0119 16 22.0119C19.321 22.0119 22.0019 19.331 22.0019 16.01C22.0019 12.689 19.321 10.0081 16 10.0081Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.01563 16.01C6.43701 2.50579 25.543 2.50579 29.9644 16.01C25.543 29.5142 6.43701 29.5142 2.01563 16.01ZM31.925 16.5102C26.9634 32.015 5.03657 32.015 0.0750234 16.5102C-0.0250078 16.1701 -0.0250078 15.83 0.0750234 15.4898C5.03657 -0.0149975 26.9634 -0.0149975 31.925 15.4898C32.025 15.83 32.025 16.1701 31.925 16.5102Z" fill="currentColor"/></svg>' :
                    '<svg width="16" height="16" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.7818 14.45L19.9812 16.25C19.8612 18.27 18.2607 19.87 16.2401 19.99L14.4595 21.79C14.9397 21.93 15.4598 22.01 16 22.01C19.321 22.01 22.0019 19.33 22.0019 16.01C22.0019 15.47 21.9219 14.95 21.7818 14.45ZM16 10.01C12.679 10.01 9.99812 12.69 9.99812 16.01C9.99812 16.55 10.0781 17.07 10.2182 17.55L12.0188 15.75C12.1388 13.75 13.7393 12.15 15.7399 12.03L17.5405 10.21C17.0603 10.09 16.5402 10.01 16 10.01Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0.0750234 15.51C-0.0250078 15.83 -0.0250078 16.19 0.0750234 16.51C0.995311 19.35 2.47577 21.67 4.31635 23.47L5.71679 22.05C4.11629 20.49 2.81588 18.47 2.01563 16.01C4.85652 7.31 13.8193 4.21 21.0016 6.75L22.5621 5.19C14.2194 1.73 3.37605 5.17 0.0750234 15.51ZM31.925 15.51C31.0047 12.67 29.5242 10.35 27.6837 8.55L26.2632 9.95C27.8637 11.51 29.1641 13.53 29.9844 16.01C27.1235 24.71 18.1607 27.81 10.9784 25.27L9.43795 26.83C17.7806 30.29 28.6239 26.85 31.925 16.51C32.025 16.19 32.025 15.83 31.925 15.51Z" fill="currentColor"/><path d="M29.6843 3.71L26.1632 7.25L24.7227 8.67L20.8815 12.53L19.4411 13.97L13.9794 19.45L9.01782 24.41L7.53736 25.91L3.73617 29.71C3.5361 29.91 3.27602 30.01 3.03595 30.01C2.77587 30.01 2.51579 29.91 2.31572 29.71C1.9156 29.33 1.9156 28.69 2.31572 28.29L5.83682 24.77L7.25727 23.33L12.5589 18.03L18.0206 12.55L19.4611 11.11L22.9622 7.59L24.4626 6.11L28.2638 2.29C28.4639 2.09 28.724 1.99 28.964 1.99C29.2241 1.99 29.4842 2.09 29.6843 2.29C30.0844 2.67 30.0844 3.31 29.6843 3.71Z" fill="currentColor"/></svg>';
                eyeIcon.style.cssText = 'margin-left: 16px; margin-right: 8px; cursor: pointer; opacity: ' + (layer.visible ? '1' : '0.3') + '; display: inline-flex; align-items: center; width: 12px; height: 12px; color: var(--text-secondary);';
                eyeIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleLayerVisibility(layer.id);
                });
                
                const labelWrapper = document.createElement('div');
                labelWrapper.style.cssText = 'display: flex; align-items: center;';
                labelWrapper.appendChild(eyeIcon);
                labelWrapper.appendChild(label);
                labelsContainer.appendChild(labelWrapper);
                
                // Track
                const track = document.createElement('div');
                track.className = 'timeline-track';
                
                if (layer.pattern) {
                    // Use layer.duration (the actual value being used for animation)
                    // NOT layer.durationOverride (which is just the override flag)
                    const duration = layer.duration || 300; // Fallback to 300ms if undefined
                    const delay = layer.delay || 0; // Fallback to 0ms if undefined
                    
                    console.log(`ðŸ“Š Timeline bar for ${layer.name}:`, {
                        duration: duration,
                        delay: delay,
                        durationOverride: layer.durationOverride,
                        pattern: layer.pattern
                    });
                    
                    const bar = document.createElement('div');
                    bar.className = 'animation-bar';
                    if (selectedLayerId === layer.id) {
                        bar.classList.add('selected');
                    }
                    if (!layer.visible) {
                        bar.style.opacity = '0.3';
                    }
                    bar.dataset.layerId = layer.id;
                    bar.style.left = `${delay * pixelsPerMs}px`;
                    bar.style.width = `${duration * pixelsPerMs}px`;
                    bar.style.background = timelineColors[index % timelineColors.length];
                    bar.textContent = `${duration}ms`;
                    
                    // Add resize handles
                    const leftHandle = document.createElement('div');
                    leftHandle.className = 'resize-handle left';
                    leftHandle.dataset.handle = 'left';
                    leftHandle.dataset.layerId = layer.id;
                    
                    const rightHandle = document.createElement('div');
                    rightHandle.className = 'resize-handle right';
                    rightHandle.dataset.handle = 'right';
                    rightHandle.dataset.layerId = layer.id;
                    
                    bar.appendChild(leftHandle);
                    bar.appendChild(rightHandle);
                    
                    // Drag bar to adjust delay
                    bar.addEventListener('mousedown', (e) => {
                        if (e.target.classList.contains('resize-handle')) return;
                        startDragBar(e, layer);
                    });
                    
                    // Resize handles
                    leftHandle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        startResize(e, layer, 'left');
                    });
                    
                    rightHandle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        startResize(e, layer, 'right');
                    });
                    
                    track.appendChild(bar);
                }
                
                tracksContainer.appendChild(track);
            });
        }
        
        function startDragBar(e, layer) {
            draggedBar = layer;
            dragStartX = e.clientX;
            dragStartDelay = layer.delay;
            
            document.addEventListener('mousemove', onDragBar);
            document.addEventListener('mouseup', stopDragBar);
            
            selectLayer(layer.id);
        }
        
        function onDragBar(e) {
            if (!draggedBar) return;
            
            const deltaX = e.clientX - dragStartX;
            const deltaMs = Math.round(deltaX / pixelsPerMs / 10) * 10; // Snap to 10ms
            
            draggedBar.delay = Math.max(0, dragStartDelay + deltaMs);
            
            updateTimeline();
            if (selectedLayerId === draggedBar.id) {
                document.getElementById('delayInput').value = draggedBar.delay;
            }
        }
        
        function stopDragBar() {
            draggedBar = null;
            document.removeEventListener('mousemove', onDragBar);
            document.removeEventListener('mouseup', stopDragBar);
        }
        
        function startResize(e, layer, handle) {
            draggedBar = layer;
            resizeHandle = handle;
            dragStartX = e.clientX;
            dragStartDuration = layer.duration;
            dragStartDelay = layer.delay;
            
            document.addEventListener('mousemove', onResize);
            document.addEventListener('mouseup', stopResize);
            
            selectLayer(layer.id);
        }
        
        function onResize(e) {
            if (!draggedBar) return;
            
            const deltaX = e.clientX - dragStartX;
            const deltaMs = Math.round(deltaX / pixelsPerMs / 10) * 10; // Snap to 10ms
            
            if (resizeHandle === 'left') {
                // Adjust delay and duration
                const newDelay = Math.max(0, dragStartDelay + deltaMs);
                const delayChange = newDelay - dragStartDelay;
                draggedBar.delay = newDelay;
                draggedBar.duration = Math.max(50, dragStartDuration - delayChange);
            } else {
                // Adjust duration only
                draggedBar.duration = Math.max(50, dragStartDuration + deltaMs);
            }
            
            updateTimeline();
            if (selectedLayerId === draggedBar.id) {
                document.getElementById('delayInput').value = draggedBar.delay;
                document.getElementById('durationInput').value = draggedBar.duration;
            }
        }
        
        function stopResize() {
            draggedBar = null;
            resizeHandle = null;
            document.removeEventListener('mousemove', onResize);
            document.removeEventListener('mouseup', stopResize);
            checkForSuggestions();
        }
        
        function adjustLayerScale(delta) {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) return;
            
            const currentScale = layer.scale || 100;
            const newScale = Math.max(10, Math.min(500, currentScale + delta));
            layer.scale = newScale;
            
            // Update all scale inputs (there might be multiple - one in properties panel, one in canvas popup)
            const scaleInputs = document.querySelectorAll('#layerScaleInput');
            scaleInputs.forEach(input => {
                input.value = newScale;
            });
            
            applyLayerScale(layer.id, newScale);
        }
        
        function adjustLayerOpacity(delta) {
            const layer = layers.find(l => l.id === selectedLayerId);
            if (!layer) return;
            
            const currentOpacity = layer.opacity !== undefined ? layer.opacity : 100;
            const newOpacity = Math.max(0, Math.min(100, currentOpacity + delta));
            layer.opacity = newOpacity;
            
            const opacityInput = document.getElementById('layerOpacityInput');
            if (opacityInput) {
                opacityInput.value = newOpacity;
            }
            
            applyLayerOpacity(layer.id, newOpacity);
        }
        
        function applyLayerOpacity(layerId, opacity) {
            const element = document.getElementById(layerId);
            if (element) {
                element.style.opacity = opacity / 100;
            }
        }
        
        function applyLayerShadow(layerId, shadow) {
            const element = document.getElementById(layerId);
            if (!element) return;
            
            if (shadow > 0) {
                // Apply drop-shadow filter
                element.style.filter = `drop-shadow(0 ${shadow}px ${shadow * 2}px rgba(0, 0, 0, 0.15))`;
                
                // Ensure parent containers allow overflow
                element.style.overflow = 'visible';
                if (element.parentElement) {
                    element.parentElement.style.overflow = 'visible';
                }
                
                // Find canvas container and ensure it allows overflow
                const canvasContainer = document.getElementById('canvasContainer');
                if (canvasContainer) {
                    canvasContainer.style.overflow = 'visible';
                }
                
                const composition = document.querySelector('.composition-area');
                if (composition) {
                    composition.style.overflow = 'visible';
                }
                
                console.log('ðŸŽ¨ Applied shadow:', shadow, 'px to', layerId);
            } else {
                // Remove shadow
                element.style.filter = 'none';
                console.log('ðŸŽ¨ Removed shadow from', layerId);
            }
        }
        
        function applyAllLayerShadows() {
            // ONLY apply shadows to selected layers, not all layers
            const selectedLayers = selectedLayerIds.size > 0 
                ? Array.from(selectedLayerIds).map(id => layers.find(l => l.id === id))
                : (selectedLayerId ? [layers.find(l => l.id === selectedLayerId)] : []);
            
            // Remove shadows from all layers first
            layers.forEach(layer => {
                const element = document.getElementById(layer.id);
                if (element) {
                    element.style.filter = 'none';
                }
            });
            
            // Apply shadow only to selected layers that have shadow set
            selectedLayers.forEach(layer => {
                if (layer && layer.shadow !== undefined && layer.shadow > 0) {
                    applyLayerShadow(layer.id, layer.shadow);
                }
            });
        }
        
        function applyLayerScale(layerId, scale) {
            const stackTrace = new Error().stack;
            const caller = stackTrace.split('\n')[2] || 'unknown';
            console.log('ðŸ” applyLayerScale called:', layerId, 'scale:', scale, 'from:', caller.trim());
            
            const element = document.getElementById(layerId);
            if (!element) return;
            
            const scaleValue = scale / 100;
            const img = element.querySelector('img');
            if (!img) return;
            
            // Function to apply scale
            const applyScale = () => {
                // Get natural dimensions
                const naturalWidth = img.naturalWidth;
                const naturalHeight = img.naturalHeight;
                
                if (naturalWidth && naturalHeight) {
                    // Get current transform to preserve translate
                    let currentTransform = element.style.transform || '';
                    const translateMatch = currentTransform.match(/translate\([^)]*\)/);
                    const translateValue = translateMatch ? translateMatch[0] : '';
                    
                    // Calculate new dimensions
                    let newWidth = naturalWidth * scaleValue;
                    let newHeight = naturalHeight * scaleValue;
                    let constrainedScale = scale;
                    
                    // In side-by-side mode, constrain to grid size
                    if (previewMode === 'side-by-side') {
                        const container = document.getElementById('canvasContainer');
                        const compositions = Array.from(container.querySelectorAll('.composition-area'))
                            .sort((a, b) => parseInt(a.dataset.squareIndex) - parseInt(b.dataset.squareIndex));
                        
                        // Find the grid this layer is in
                        let gridSize = null;
                        const elementRect = element.getBoundingClientRect();
                        const elementCenterX = elementRect.left + elementRect.width / 2;
                        const elementCenterY = elementRect.top + elementRect.height / 2;
                        
                        compositions.forEach(comp => {
                            const compRect = comp.getBoundingClientRect();
                            
                            if (elementCenterX >= compRect.left && elementCenterX <= compRect.right &&
                                elementCenterY >= compRect.top && elementCenterY <= compRect.bottom) {
                                const margin = 90; // Margin for breathing room (2x45px)
                                gridSize = {
                                    maxWidth: compRect.width - margin,
                                    maxHeight: compRect.height - margin
                                };
                            }
                        });
                        
                        // Constrain scale to fit within grid
                        if (gridSize) {
                            const maxScale = Math.min(
                                gridSize.maxWidth / naturalWidth,
                                gridSize.maxHeight / naturalHeight
                            );
                            
                            if (scaleValue > maxScale) {
                                constrainedScale = Math.floor(maxScale * 100);
                                console.log(`âš ï¸ Scale constrained to ${constrainedScale}% to fit grid`);
                                newWidth = naturalWidth * maxScale;
                                newHeight = naturalHeight * maxScale;
                                
                                // Update layer scale value
                                const layer = layers.find(l => l.id === layerId);
                                if (layer) {
                                    layer.scale = constrainedScale;
                                }
                                
                                // Update scale input
                                const scaleInputs = document.querySelectorAll('#layerScaleInput');
                                scaleInputs.forEach(input => input.value = constrainedScale);
                            }
                        }
                    }
                    
                    // Apply scale by setting width/height on wrapper
                    element.style.width = `${newWidth}px`;
                    element.style.height = `${newHeight}px`;
                    element.style.maxWidth = 'none';
                    element.style.maxHeight = 'none';
                    element.style.minWidth = '0';
                    element.style.minHeight = '0';
                    
                    // Make sure img fills the wrapper
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.maxWidth = 'none';
                    img.style.maxHeight = 'none';
                    img.style.objectFit = 'contain';
                    
                    // Restore translate transform if it exists (for stacked mode centering)
                    if (translateValue) {
                        element.style.transform = translateValue;
                    } else {
                        element.style.transform = '';
                    }
                } else {
                    // Fallback: use transform scale if natural dimensions not available
                    let currentTransform = element.style.transform || '';
                    const translateMatch = currentTransform.match(/translate\([^)]*\)/);
                    const translateValue = translateMatch ? translateMatch[0] : '';
                    
                    // Remove any existing scale
                    currentTransform = currentTransform.replace(/scale\([^)]*\)/g, '').trim();
                    
                    // Add new scale
                    element.style.transform = `${translateValue} scale(${scaleValue})`.trim();
                }
            };
            
            // Wait for image to load
            if (img.complete && img.naturalWidth && img.naturalHeight) {
                applyScale();
            } else {
                // Try immediately in case dimensions are available
                if (img.naturalWidth && img.naturalHeight) {
                    applyScale();
                } else {
                    // Wait for load event
                    img.addEventListener('load', applyScale, { once: true });
                    // Also try after a short delay
                    setTimeout(() => {
                        if (img.naturalWidth && img.naturalHeight) {
                            applyScale();
                        }
                    }, 100);
                }
            }
        }
        
        // Setup event listeners for action buttons
        window.addEventListener('load', () => {
            // Initialize position manager
            positionManager.init();
            
            // Use event delegation for create folder button (more reliable)
            const createFolderRow = document.getElementById('createFolderRow');
            if (createFolderRow) {
                createFolderRow.addEventListener('click', (e) => {
                    if (e.target.closest('#createFolderBtn') || e.target.id === 'createFolderBtn') {
                        e.stopPropagation();
                        e.preventDefault();
                        createNewFolder();
                    }
                });
            }
            
            const splitLayerBtn = document.getElementById('splitLayerBtn');
            const deleteLayerBtn = document.getElementById('deleteLayerBtn');
            
            if (splitLayerBtn) {
                console.warn('âœ… Split button found, adding listener');
                splitLayerBtn.addEventListener('click', (e) => {
                    console.warn('âœ… Split button CLICKED!');
                    e.stopPropagation();
                    if (!splitLayerBtn.disabled) {
                        console.warn('âœ… Split button not disabled, calling toggleSplitLayer');
                        toggleSplitLayer();
                    } else {
                        console.warn('âŒ Split button is DISABLED');
                    }
                });
            } else {
                console.error('âŒ Split button NOT FOUND!');
            }
            
            if (deleteLayerBtn) {
                deleteLayerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!deleteLayerBtn.disabled) {
                        // Delete selected items
                        if (selectedLayerId) {
                            deleteLayer(selectedLayerId);
                        } else if (selectedFolderId) {
                            deleteFolder(selectedFolderId);
                        } else if (selectedLayerIds.size > 0) {
                            // Delete multiple layers
                            Array.from(selectedLayerIds).forEach(id => deleteLayer(id));
                            selectedLayerIds.clear();
                        } else if (selectedFolderIds.size > 0) {
                            // Delete multiple folders
                            Array.from(selectedFolderIds).forEach(id => deleteFolder(id));
                            selectedFolderIds.clear();
                        }
                    }
                });
            }
            
            // Initial button state
            updateActionButtons();
            
            // Update panel visibility on load
            updatePanelVisibility();
            
            // Setup panel collapse/expand functionality
            document.querySelectorAll('.panel-header').forEach(header => {
                header.addEventListener('click', () => {
                    const isCollapsed = header.classList.contains('collapsed');
                    const collapseIcon = header.querySelector('.collapse-icon');
                    const expandIcon = header.querySelector('.expand-icon');
                    
                    if (isCollapsed) {
                        header.classList.remove('collapsed');
                        if (collapseIcon) collapseIcon.style.display = '';
                        if (expandIcon) expandIcon.style.display = 'none';
                    } else {
                        header.classList.add('collapsed');
                        if (collapseIcon) collapseIcon.style.display = 'none';
                        if (expandIcon) expandIcon.style.display = '';
                    }
                });
            });
        });
    </script>
</body>
</html>


